### Prompt 1 ###
I need to implement a **64b/66b top-level codec module** that integrates a **data encoder (`encoder_data_64b66b`), a control encoder (`encoder_control_64b66b`), and a combined data/control decoder (`decoder_data_control_64b66b`)**. The top-level module should be created at **`/code/rtl/top_64b66b_codec.sv`** and must manage the full encode-decode flow for 64b/66b encoding, supporting data, and control paths.

The encoder must select between data and control encoding based on the `enc_control_in` value and produce a 66-bit encoded output (`enc_data_out`). The decoder must process incoming 66-bit data and output 64-bit decoded data, associated control signals, and any sync or decoding errors.

The RTL source files are located as follows:
- `/code/rtl/encoder_data_64b66b.sv`
- `/code/rtl/encoder_control_64b66b.sv`
- `/code/rtl/decoder_data_control_64b66b.sv`

The documentation, located under the`/code/docs/specification.md` directory, provides design requirements and behavior specifications. 

This integrated module should operate with **minimal latency and full protocol compliance**, as defined in the provided documentation.

### Prompt 2 ###
I have a SystemVerilog testbench named `tb_top_64b66b_codec` in the `verif` directory. It provides comprehensive stimulus to the `top_64b66b_codec` RTL module, which implements 64b/66b encoding and decoding functionality. The corresponding design specification can be found in the `docs/specification.md` file. The given testbench exercises many scenarios, including data-only, control, mixed-mode, and invalid input cases for both the encoder and decoder paths.

Modify the SystemVerilog testbench `tb_top_64b66b_codec.sv` in the `verif` directory by adding checker logic to verify the outputs from the `top_64b66b_codec` module.

**Modify the testbench as follows:**

- **Encoder Checker Logic:**
  - Implement a reference model that predicts the expected 66-bit encoder output given a 64-bit data input and 8-bit control input.
  - The checker should:
    - Validate the sync header (`2'b01` for data-only, `2'b10` for control/mixed-mode).
    - Derive and verify the `type` field for control/mixed-mode cases.

- **Decoder Checker Logic:**
  - Add reference model logic to decode `decoder_data_in` (with sync header and type field) and generate the expected `decoder_data_out` and `decoder_control_out`
  - When `decoder_data_valid_in` is asserted:
    - Compare the DUT's outputs against reference outputs.
    - Check that protocol errors (invalid sync or type field) correctly trigger `decoder_error_out` and/or `sync_error`.

### Prompt 3 ###
Based on the contents of specification `docs/decoder_specification.md`, implement a complete SystemVerilog RTL design for the decoder module and create an accompanying SystemVerilog testbench.

**RTL Module Implementation**  
- **Specification:** Refer to `docs/decoder_specification.md` for detailed functional requirements, performance constraints, and expected behavior.
- **Module Functionality:**  
  - Convert a 10-bit encoded input into an 8-bit decoded output.
  - Utilize separate decoding paths for control symbols and data symbols, determined by a dedicated control signal.
  - Ensure robust handling of clock, reset, and input-valid signals.
- **Location:** Save the RTL module file (`decoder_8b10b.sv`) in the `rtl` directory.

**Testbench Implementation:**  
- **Testbench File:** Create a SystemVerilog testbench (`tb_decoder_8b10b.sv`) that generates stimulus only and save it in the `verif` directory.
- **Responsibilities:**  
  - Develop comprehensive test cases that cover all aspects of the decoder’s operation, including both control symbol and data symbol decoding.
  - Simulate various scenarios such as normal operation, reset behavior, and potential edge cases to achieve maximum coverage.

### Prompt 4 ###
The `aes128_encrypt` module in `rtl` folder performs **AES-128 encryption** by first generating **11 round keys** (one for the initial state and 10 rounds) from the **128-bit cipher key** using a **recursive key expansion process**. It begins by treating the key as **four 32-bit words** (`W[0]` to `W[3]`) and deriving new words using the **previously generated ones**. Every **fourth word (`W[i]`)** undergoes the **key schedule core transformation**, which includes a **byte-wise left rotation (`RotWord`)**, substitution via the **S-box (`SubWord`)**, and XOR of the left-most byte of `SubWord` with a **round constant (`Rcon`)**. The transformed word is XORed with the word from **four positions earlier (`W[i-4]`)** to produce the next word. Each remaining word is generated by XORing the previous word with the word four positions earlier. The key expansion process does not run serially; instead, it **generates the first necessary round keys, allowing encryption to start in parallel** while the remaining keys continue to be derived. This process continues until all **44 words (`W[0]` to `W[43]`)** are generated and grouped into **11 round keys**.

# AES-128 Encryption Overview

The encryption process begins by **loading the 128-bit plaintext block** into a **4×4 state matrix**, which undergoes **11 transformations** (one for the initial round and 10 for encryption rounds). In the **initial round**, the state is XORed with the first round key.  

Each of the **10 encryption rounds** consists of four main transformations:  

- **SubBytes** – Replaces each byte using the **AES S-box** to introduce non-linearity.  
- **ShiftRows** – Cyclically shifts the rows of the state matrix to introduce diffusion.  
- **MixColumns** – Transforms each column of the state matrix by multiplying it with a fixed **GF(2⁸) polynomial matrix** (over **Rijndael’s finite field**) to diffuse data across bytes. This operation ensures that changes in one byte affect all four bytes of a column.  

  The transformation is defined as a **matrix multiplication** where each column of the state is multiplied by the following constant matrix:

     |  8'h02  |  8'h03  |  8'h01  |  8'h01  |
     |:-------:|:-------:|:-------:|:-------:|
     |  8'h01  |  8'h02  |  8'h03  |  8'h01  |
     |  8'h01  |  8'h01  |  8'h02  |  8'h03  |
     |  8'h03  |  8'h01  |  8'h01  |  8'h02  |

  ## **Mathematical Basis in GF(2⁸)**
  - **Rijndael’s finite field (GF(2⁸))** is defined by the **irreducible polynomial**: $`x^8 + x^4 + x^3 + x + 1`$ **or** `0x11B` in hexadecimal. This polynomial is used for modular reduction when performing field operations.  
  - **Addition in GF(2⁸)** is simply **bitwise XOR**.  
  - **Multiplication in GF(2⁸)** follows standard polynomial multiplication, but results are reduced **modulo ($`x^8 + x^4 + x^3 + x + 1`$)** to ensure results stay within the field.  
  - To implement multiplication by `{02}` (0x02) in hardware, a left shift (`x << 1`) is used, followed by XOR with `0x1B` if the most significant bit was set (to ensure modular reduction).  
  - Multiplication by `{03}` (0x03) is computed as `{02} ⊕ {01}`, This is expressed as `{03} * x = ({02} * x) ⊕ x`.

  This operation is **skipped in the final round** to maintain proper decryption symmetry.  

- **AddRoundKey** – XORs the state matrix with the corresponding round key.  

After **10 rounds**, the final state matrix is transformed into the **128-bit ciphertext output**, completing the AES-128 encryption process.


The key expansion and the encryption can happen simultaneously, by asserting both `i_start` and `i_update_key`. Also, if the stored expanded key is the one that should be used for the encryption, only an `i_start` signal may be asserted and the key will not be updated.

During testing, the module failed to produce the expected output, leading to incorrect results. The `sbox_enc` module and the `Rcon` values were previously tested, and they have no errors.
The module and its testbench are available in the current working directory for debugging, and the expected output is available in the testbench. Could you help debug and fix the RTL to ensure correct functionality?

### Prompt 5 ###
The `aes128_decrypt` module in the `rtl` folder performs **AES-128 decryption** by first using the `aes128_key_expansion` module to generate **11 round keys** (one for the initial state and 10 rounds) from the **128-bit cipher key** using a **recursive key expansion process**. It begins by treating the key as **four 32-bit words** (`W[0]` to `W[3]`) and deriving new words using the **previously generated ones**. Every **fourth word (`W[i]`)** undergoes the **key schedule core transformation**, which includes a **byte-wise left rotation (`RotWord`)**, substitution via the **S-box (`SubWord`)**, and XOR of the left-most byte of `SubWord` with a **round constant (`Rcon`)**. The transformed word is XORed with the word from **four positions earlier (`W[i-4]`)** to produce the next word. Each remaining word is generated by XORing the previous word with the word four positions earlier. The key expansion process runs serially, that is, if a key update is required, it first needs to expand it so only then can it perform the decryption operation. This process continues until all **44 words (`W[0]` to `W[43]`)** are generated and grouped into **11 round keys**.

# AES-128 Decryption Overview

AES-128 decryption operation is done in the `aes128_decrypt` module and it is a process that **recovers the original plaintext** from a **128-bit ciphertext** by applying a series of transformations. The **ciphertext** is loaded into a **4×4 state matrix**, which undergoes **11 transformations** (one initial AddRoundKey step and 10 decryption rounds).  

## **Decryption Process**

1. **Initial Step**:  
   - **AddRoundKey** – The state matrix is XORed with a round key derived from the original secret key (cipher key).  

2. **9 Main Decryption Rounds** (Repeated 9 times):  
   - **InvShiftRows** – The last three rows of the state matrix are **cyclically shifted to the right** by 1, 2, and 3 bytes, respectively, keeping the first row unchanged.  
   - **InvSubBytes** – Each byte in the state is replaced using a **fixed substitution table** known as the **inverse AES S-box**, which maps each byte to a new value in a non-linear way.  
   - **AddRoundKey** – The state matrix is XORed with a round key derived from the original secret key.  
   - **InvMixColumns** – A mathematical transformation that modifies each column of the state by multiplying it with a fixed **4×4 matrix** in **GF(2⁸)**, ensuring that the data is spread across multiple bytes.  

3. **Final Round** (10th Round, Without InvMixColumns):  
   - **InvShiftRows**  
   - **InvSubBytes**  
   - **AddRoundKey**  

## **Mathematical Basis of InvMixColumns in GF(2⁸)**  

To apply **InvMixColumns**, each column of the state matrix is multiplied by the following **fixed matrix**:

|  8'h0E  |  8'h0B  |  8'h0D  |  8'h09  |
|:-------:|:-------:|:-------:|:-------:|
|  8'h09  |  8'h0E  |  8'h0B  |  8'h0D  |
|  8'h0D  |  8'h09  |  8'h0E  |  8'h0B  |
|  8'h0B  |  8'h0D  |  8'h09  |  8'h0E  |

This multiplication follows special rules defined in **GF(2⁸)** (Galois Field of 256 elements), a mathematical structure that allows modular arithmetic on 8-bit values.

  ## **Mathematical Basis in GF(2⁸)**
  - **Rijndael’s finite field (GF(2⁸))** is defined by the **irreducible polynomial**: $`x^8 + x^4 + x^3 + x + 1`$ **or** `0x11B` in hexadecimal. This polynomial is used for modular reduction when performing field operations.  
  - **Addition in GF(2⁸)** is simply **bitwise XOR**.  
  - **Multiplication in GF(2⁸)** follows standard polynomial multiplication, but results are reduced **modulo ($`x^8 + x^4 + x^3 + x + 1`$)** to ensure results stay within the field.  
  - To implement multiplication by `{02}` (0x02) in hardware, a left shift (`x << 1`) is used, followed by XOR with `0x1B` if the most significant bit was set (to ensure modular reduction).  
  - **Multiplication by constants** follows these rules:  
    - Multiplication by `{0E}` (0x0E) is computed as `{02} ⊕ {04} ⊕ {08}`  
    - Multiplication by `{0B}` (0x0B) is computed as `{02} ⊕ {08} ⊕ 1`  
    - Multiplication by `{0D}` (0x0D) is computed as `{04} ⊕ {08} ⊕ 1`  
    - Multiplication by `{09}` (0x09) is computed as `{08} ⊕ 1`  

  This operation is **skipped in the final round** to maintain proper decryption symmetry.  

- **AddRoundKey** – XORs the state matrix with the corresponding round key.  

These rules ensure that **InvMixColumns** correctly modifies the state matrix so that information from each byte is distributed across multiple columns.

## **Final Decryption Steps**
After **10 decryption rounds**, the state matrix is transformed back into the **128-bit plaintext**, completing the AES-128 decryption process.

---

The key expansion, when asserted by `i_update_key` and `i_start`, must happen before the decryption algorithm, so the proper key is used in the operation. If the stored expanded key is the one that should be used for the decryption, only an `i_start` signal may be asserted and the key will not be updated.

During testing, the module failed to produce the expected output, leading to incorrect results. The `sbox`, `inv_sbox` modules and the `Rcon` values were previously tested, and they have no errors.
The modules and the testbench are available in the current working directory for debugging, and the expected output is available in the testbench. Could you help debug and fix the RTL to ensure correct functionality? You can change the interface of internal blocks as you see fit, but you may not change the interface from `aes128_decrypt`.

### Prompt 6 ###
Modify the `aes_encrypt` module in the `rtl` directory, which originally performs an AES-128 encryption, to perform only an AES-256 encryption. A testbench to test the updated design is provided in `verif` directory, and the `sbox` module does not need to be changed. The AES-128 version takes a 128-bit key and a 128-bit data and encrypts it, while the AES-256 version receives a 256-bit key and a 128-bit data and encrypts it. Below is a description of the changes that need to be made:

### 1. **Update Interface Parameters**

- Change the key input size from 128 to 256 bits: Instead of copying 4 32-bit words into the first part of the expanded key, copy 8 32-bit words from the 256-bit input key.

### 2. **Modify Key Expansion Loop**

- In AES-128, for each 32-bit word `w[i]` where `i` is a multiple of `4`, you apply:
  - For each `i >= 4`:
    - `Temp = RotWord(w[i-1])`
    - `Temp = SubWord(Temp)`
    - `Temp = Temp XOR Rcon[i/4 - 1]`
    - `w[i] = w[i - 4] XOR Temp`

(`Temp` is used to demonstrate intermediate calculation storage during each step of calculation)

- In **AES-256**, the logic changes:
  - For each `i >= 8`:
    - If `i % 8 == 0`:
      - `Temp = RotWord(w[i-1])`
      - `Temp = SubWord(Temp)`
      - `Temp = Temp XOR Rcon[i/8 - 1]`
    - Else if `i % 8 == 4`:
      - `Temp = SubWord(w[i-1])`
      - **No rotation, no Rcon**
    - Else:
      - `Temp = w[i-1]`
    - Then:
      - `w[i] = w[i - 8] XOR Temp`

Make sure to implement this conditional branching properly in the loop.

### 3. **Rcon Handling**

- Rcon is only applied when `i % 8 == 0` (i.e., every 8 words in AES-256).
- Do **not** apply Rcon when `i % 8 == 4`.
- **If any Rcon value is not needed, remove it from the code**.

### 4. **Update Encryption Flow**

- **Increase round counter** to go up to 14.
- **Expand the key schedule** to generate and store **15 round keys**, each 128 bits (i.e., 240 bytes or 60 words of 32 bits total).
- Update loops that iterate over rounds so they only use 128 bits of the expanded key for each round.

### 5. **Initial Round Key Addition**
- Ensure the first round key is generated correctly from the first 128 bits of the expanded 256-bit key.

### 6. **Internal Buffers and Registers**
- Update the size of any registers or memory arrays that store round keys from 44 32-bit words (AES-128) to 60 32-bit words (AES-256)

### Prompt 7 ###
Modify the `aes_decrypt` and `aes_ke` modules in the `rtl` directory, which originally perform an AES-128 decryption and AES-128 key expansion, to perform an AES-256 decryption and an AES-256 key expansion. A testbench to test the updated design is provided in the `verif` directory, and the `sbox` and `inv_sbox` modules do not need to be changed. The AES-128 version takes a 128-bit key and a 128-bit data and decrypts it, while the AES-256 version receives a 256-bit key and a 128-bit data and decrypts it. Below is a description of the changes that need to be made:

### 1. **Update Interface Parameters**

- Change the key input size from 128 to 256 bits: Instead of copying 4 32-bit words into the first part of the expanded key, copy 8 32-bit words from the 256-bit input key.

### 2. **Modify Key Expansion Loop**

- In AES-128, for each 32-bit word `w[i]` where `i` is a multiple of `4`, you apply:
  - For each `i >= 4`:
    - `Temp = RotWord(w[i-1])`
    - `Temp = SubWord(Temp)`
    - `Temp = Temp XOR Rcon[i/4 - 1]`
    - `w[i] = w[i - 4] XOR Temp`

(`Temp` is used to demonstrate intermediate calculation storage during each step of calculation)

- In **AES-256**, the logic changes:
  - For each `i >= 8`:
    - If `i % 8 == 0`:
      - `Temp = RotWord(w[i-1])`
      - `Temp = SubWord(Temp)`
      - `Temp = Temp XOR Rcon[i/8 - 1]`
    - Else if `i % 8 == 4`:
      - `Temp = SubWord(w[i-1])`
      - **No rotation, no Rcon**
    - Else:
      - `Temp = w[i-1]`
    - Then:
      - `w[i] = w[i - 8] XOR Temp`

Make sure to implement this conditional branching properly in the loop.

### 3. **Rcon Handling**

- Rcon is only applied when `i % 8 == 0` (i.e., every 8 words in AES-256).
- Do **not** apply Rcon when `i % 8 == 4`.
- **If any Rcon value is not needed, remove it from the code**.

### 4. **Update Decryption Flow**

- **Increase round counter** of the decryption operation to go up to 14. Make sure to wait while the key is being expanded.
- **Expand the key schedule** to generate and store **15 round keys**, each 128 bits (i.e., 240 bytes or 60 words of 32 bits total).
- Update loops that iterate over rounds so they use the appropriate 128-bit portion of the expanded key in **reverse order**, starting from the last round and moving toward the first.
- Ensure the decryption steps are correctly sequenced:
  - Initial AddRoundKey
  - 13 rounds of: ShiftRows → SubBytes → AddRoundKey → MixColumns
  - Final round: ShiftRows → SubBytes → AddRoundKey (no MixColumns)

### 5. **Initial Round Key Addition**
- Ensure the first round key added corresponds to the last round key from the AES-256 key schedule.

### 6. **Internal Buffers and Registers**
- Update the size of any registers or memory arrays that store round keys from 44 32-bit words (AES-128) to 60 32-bit words (AES-256)

### Prompt 8 ###
Update `aes_enc_top` and `aes_dec_top` RTLs so that the CTR block cipher mode changes how it concatenates the IV with the counter. The first 16 bits should be the 16 MSB of the counter, the next 96 should be the bits [111:16] from the IV and the next 16 bits should be the 16 LSB from the counter. As an example:

- `IV = 128'h00112233445566778899aabbccddeeff` and `counter = 32'h55443322`, the combination of them (used in the input of the encryption module in both `aes_dec_top` and `aes_enc_top`) should be `enc_in = 128'h55442233445566778899aabbccdd3322`.

Also, create a new module that instantiates both `aes_enc_top` and `aes_dec_top` modules and uses them to perform encryption or decryption depending on the `i_encrypt` control signal. This module should add support for four different padding modes used in block ciphers. The testbench to validate this functionality is provided in the `verif` directory, and no other changes, besides those described above, are required in any other RTL. This new module is described below:

### Specifications

- **Module Name**: `padding_top` (defined in `rtl/padding_top.sv`)
- **Parameters**:
    - `NBW_KEY`: Bit width of the encryption/decryption key.
        - Default: 256.
        - Related interface signals: `i_key`.
    - `NBW_DATA`: Bit width of the input and output data blocks.
        - Default: 128.
        - Related interface signals: `i_data`, `o_data`, `i_iv`.
    - `NBW_MODE`: Bit width for cipher mode selection.
        - Default: 3.
        - Related interface signals: `i_mode`.
    - `NBW_CNTR`: Bit width of the counter (used in CTR mode).
        - Default: 32.
    - `NBW_PADD`: Bit width to represent padding length.
        - Default: 4.
        - Related interface signals: `i_padding_bytes`.
    - `NBW_PMOD`: Bit width to represent padding mode.
        - Default: 2.
        - Related interface signals: `i_padding_mode`.
    - `W3C_BYTE`: Byte used for W3C padding.
        - Default: 8'hAF.

### Interface signals

- **Clock** (`clk`): Synchronizes operation on the rising edge.
- **Asynchronous Reset** (`rst_async_n`): Active low. Resets internal registers including the padding mode.
- **Encryption Mode** (`i_encrypt`): When high, the encryption path is selected; otherwise, the decryption path is selected. It should remain at the desired value while configuring the IV, mode and resetting the counter, until the operation is done.
- **Padding Mode Update** (`i_update_padding_mode`): When high, updates the internal padding mode register with `i_padding_mode`.
- **Padding Mode Selection** (`[NBW_PMOD-1:0] i_padding_mode`): Selects the padding logic to apply.
- **Padding Byte Count** (`[NBW_PADD-1:0] i_padding_bytes`): Indicates how many bytes of the input should be padded.
- **Reset Counter** (`i_reset_counter`): Reset signal for CTR mode. It resets the internal counter.
- **IV Update** (`i_update_iv`): When high, updates internal IV register with `i_iv`.
- **IV Data** (`[NBW_DATA-1:0] i_iv`): Input initialization vector.
- **Mode Update** (`i_update_mode`): When high, updates the internal cipher mode register with `i_mode`.
- **Mode** (`[NBW_MODE-1:0] i_mode`): Indicates which cipher mode to use (e.g., ECB, CBC, etc.).
- **Key Update** (`i_update_key`): When high and `i_start` is asserted, updates the key.
- **Key** (`[NBW_KEY-1:0] i_key`): Encryption/decryption key.
- **Start Operation** (`i_start`): Triggers encryption or decryption depending on `i_encrypt`.
- **Input Data** (`[NBW_DATA-1:0] i_data`): The plaintext or ciphertext block to be processed.
- **Done** (`o_done`): Indicates operation completion.
- **Output Data** (`[NBW_DATA-1:0] o_data`): The processed (encrypted or decrypted) data block.

### Internal Behavior

- The internal padding mode register is updated sequentially when `i_update_padding_mode` is high. It is cleared asynchronously when `rst_async_n` is low.
- The padding logic is combinational and modifies the least significant bytes of the input data block according to the selected padding mode.
- No padding is done when `i_padding_bytes == 0`, regardless of the selected padding mode.
- Given that the **Input Data** `i_data` is a fixed size (16 bytes), the padding is done by replacing the least significant bytes, instead of adding them (assuming that those bytes marked for padding are invalid in the input data).
- Since the **Padding Byte Count** is at most 15, the 16th byte of the **Input Data** will never be padded. The **Padding Byte Count** is limited to 15 given that for the 16th byte to be padded, the padding byte count should be 16 (which, again, is not allowed), and no data would be encrypted/decrypted, only the padding.
- The `aes_enc_top` used only when `i_encrypt == 1`.
- The `aes_dec_top` used only when `i_encrypt == 0`.
- Control signals like `i_update_iv`, `i_update_mode`, `i_update_key`, `i_reset_counter`, and `i_start` are gated so only the selected AES module receives them.

### Supported Padding Modes

- **PKCS#7** (`PKCS = 2'b00`):
    - Each padding byte is filled with the number of padding bytes.
    - Example: If 2 bytes are padded, both are `8'h02`.

- **One-And-Zeroes** (`ONEANDZEROES = 2'b01`):
    - First padding byte(most significant) is `8'h80`, remaining padded bytes are `8'h00`.

- **ANSI X9.23** (`ANSIX923 = 2'b10`):
    - All padding bytes are `8'h00`, except the last one(least significant), which contains the number of padded bytes.

- **W3C** (`W3C = 2'b11`):
    - All padding bytes are filled with the `W3C_BYTE` parameter (default is `8'hAF`), except the last one which contains the number of padded bytes.

### Prompt 9 ###
I have a hierarchical AES encryption design with 3 main modules:
- `aes_enc_top` (top-level interface: key, mode, IV, counter, control),
- `aes_encrypt` (core round logic and key expansion).
- `sbox` (byte substitution in the AES rounds).

These modules are located in the `rtl` directory. Please enhance the design by adding **SystemVerilog Assertions (SVA)** to verify control logic, functional behavior, round sequencing, and mode-dependent correctness.

---

### Assertion Requirements

Implement assertions to cover the following conditions:

1. **Reset Behavior**  
   On reset (`rst_async_n`), all outputs and internal registers must be cleared.

2. **Ciphertext Update Timing**  
   `o_ciphertext` must update only when encryption is completed.

3. **Done Signal Validity**  
   `o_done` must deassert only on new `i_start`.

4. **Key Register Update**  
   `key_ff` must update only when a valid key update occurs during start.

5. **CTR Counter Control**  
   `counter_ff` must increment only in CTR mode after encryption.

6. **Encryption Round Progression**  
   `round_ff` must increment on every valid encryption cycle, and `o_done` must assert when round 14 is reached.

7. **Key Expansion Handling**  
   When `i_update_key` is asserted, `expanded_key_ff` must load `i_key`.

8. **Initial XOR Logic**  
   First-round `current_data_ff` values must be the result of a valid XOR between `i_data` and either `i_key` or `expanded_key_ff`..

---

### Expected Behavior

If any of the above conditions are violated, the assertion must fail and produce an informative error message that clearly identifies the failure scenario and expected behavior.

---

### Notes

- All assertions must use **SystemVerilog Assertions (SVA)** syntax.
- Only the `rtl` directory files should be modified to implement this.

### Prompt 10 ###
Create a module that implements the **Data Encryption Standard (DES)** encryption algorithm. This module performs bit-accurate DES encryption on a 64-bit plaintext block using a 64-bit key. The module must support synchronous encryption with a valid interface. It must suport burst operation, where `i_valid` is asserted for multiple cycles in a row. A testbench, `tb_des_enc.sv`, file is provided to test this new module. The description and requirements for the module are provided below:

---

## Specifications

- **Module Name**: `des_enc` (to be added in `rtl` directory)

- **Parameters**:
    - `NBW_DATA`: Bit width of the input and output data blocks.
        - Default: 64.
        - Related interface signals: `i_data`, `o_data`.
    - `NBW_KEY`: Bit width of the key.
        - Default: 64.
        - Related interface signals: `i_key`.
- **Latency**: The block's latency, from when `i_valid` is read until `o_valid` is asserted, must be equal to the number of rounds: 16 cycles.

---

## Interface Signals

| Signal              | Direction | Width            | Description                                                                                                            |
|---------------------|-----------|------------------|-------------------------------------------------------------------------------------------------------------------     |
| `clk`               | Input     | 1                | Drives the sequential logic on the rising edge.                                                                        |
| `rst_async_n`       | Input     | 1                | Active-low asynchronous reset; clears all internal registers and state.                                                |
| `i_valid`           | Input     | 1                | Active high. Indicates that `i_data` and `i_key` are valid and can be processed.                                       |
| `i_data`            | Input     | [1:NBW_DATA]     | 64-bit plaintext input block (MSB-first).                                                                              |
| `i_key`             | Input     | [1:NBW_KEY]      | 64-bit encryption key.                                                                                                 |
| `o_valid`           | Output    | 1                | Asserted high when `o_data` contains valid encrypted data. It is asserted for as many cycles as `i_valid` is asserted  |
| `o_data`            | Output    | [1:NBW_DATA]     | 64-bit ciphertext output block (MSB-first).                                                                            |
---

## Internal Behavior

In this module description, the first `n` bits of a value declared as [1:NBW] are `1, 2, 3, ... , n-1, n`, and the last `n` bits are `NBW-(n-1), NBW-(n-2), ... , NBW-1, NBW`.

The `des_enc` module implements the standard **16-round Feistel structure** of DES. The process is divided into the following stages:

### 1. Initial Permutation (IP)

The 64-bit input block undergoes a fixed initial permutation. The description for this step is available at the "Permutations.md" file.

The first 32 bits are stored in $`L_0`$ and the last 32 bits in $`R_0`$.

---

### 2. Key Schedule

- The 64-bit input key is reduced to 56 bits via a **parity drop**.
- It is then split into two 28-bit halves.
- Each half is rotated left based on a fixed schedule per round.
- A **PC-2** permutation compresses the result to 48-bit round keys (`K1` to `K16`).

The "Key_schedule.md" file describes this operation in more detail.

---

### 3. Feistel Rounds

Each of the 16 rounds updates the left and right halves as follows:

$`L_n = R_{n-1}`$

$`R_n = L_{n-1} ⊕ F(R_{n-1}, K_n)`$

Where `F` is the round function consisting of:

- **Expansion (E)**: Expands 32-bit R to 48 bits using a fixed table. Described in the "Permutations.md" file.
- **Key Mixing**: Uses the expanded value from the **Expansion (E)** operation and XORs it with the 48-bit round key $`K_n`$.
- **S-box Substitution**: 48 bits are split into 8 groups of 6 bits, passed through S-boxes S1–S8. Each S-box is a 4x16 table (64 entries) mapping a 6-bit input to a 4-bit output. Those operations are described in the "S_box_creation.md" file.
- **Permutation (P)**: 32-bit output of S-boxes is permuted via a fixed permutation. Described in the "Permutations.md" file.

---

### 4. Final Permutation (FP)

After the 16th round, the L and R halves are concatenated in reverse order and passed through the **Final Permutation**, which is the inverse of IP. This concatenation is described in the "Permutations.md" file.

---

## Substitution box files

To perform the operations S1, S2, ... , S8 described in "S_box_creation.md"; create the files `S1.sv`, `S2.sv`, `S3.sv`, `S4.sv`, `S5.sv`, `S6.sv`, `S7.sv`, `S8.sv` and place them at the `rtl` directory.

### Prompt 11 ###
The module `des_enc` performs the **Data Encryption Standard (DES)** encryption. Use it as a reference to create a new module that performs the inverse operation, the **DES** decryption. The module should be defined as `des_dec` and placed in the `rtl` directory as `des_dec.sv`.

The new module must perform bit-accurate DES decryption on a 64-bit plaintext block using a 64-bit key. The module must support synchronous decryption with a valid interface. It must support burst operation, where `i_valid` is asserted for multiple cycles in a row. A testbench, `tb_des_dec.sv`, file is provided to test this new module. No changes to the substitution boxes `S1`, `S2`, `S3`, `S4`, `S5`, `S6`, `S7`, and `S8` are required.

- The module's interface must not be changed.
- The module's latency must not be changed. 
- The files in `docs` folder describe the encryption process, and the changes required from the encryption algorithm to the decryption algorithm are described below.

---

## DES Decryption

To decipher it is only necessary to apply the very same algorithm 'f' of the encryption to an enciphered message block, taking care that at each iteration of the computation, the same block of key bits `K_n` is used during decipherment as was used during the encipherment of the block. Since the encryption uses:

$`L_n = R_{n-1}`$
$`R_n = L_{n-1} ⊕ f(R_{n-1},K_n)`$

By setting the `R_{n-1}` and `L_{n-1}` as the value that is being calculated, this equation can be expressed as:

$`R_{n-1} = L_n`$
$`L_{n-1} = R_n ⊕ f(L_n,K_n)`$

Where now the concatenation of `R_{16}` and `L_{16}` is the permuted, following **IP** permutation, input block for the deciphering calculation and the concatenation of `L_0` and `R_0` is the 'last_perm' wire, that is permutated following the **FP** permutation. 

After applying the initial permutation (IP) to the input, the encrypted data is arranged so that its first 32 bits are `R_{16}` and its last 32 bits are `L_{16}`. This concatenated block (`R_{16}`‖`L_{16}`) serves as the starting, permuted input for decryption. For the decipherment calculation with `R_{16}L_{16}` as the permuted input, `K_{16}` is used in the first iteration, `K_{15}` in the second, and so on, with `K_{1}` used in the 16th iteration. After the decryption rounds, the two halves `L_{0}` and `R_{0}` are concatenated into the wire called `last_perm`({`L_{0}`, `R_{0}`}),  which is then processed by the final permutation (FP) to yield the correct plaintext output. 

The DES encryption algorithm description is available in the `Encryption.md` file and other supporting documentation, and a testbench to verify the expected behavior of the decryption design is available.

### Prompt 12 ###
Integrate the `des_enc` and `des_dec` modules to perform the Triple Data Encryption Standard (TDES) encryption. This new module must allow burst operation, where in multiple cycles in a row the valid signal can be asserted with a new data and a new key. No changes are required in any of the RTLs provided. A testbench for this module is available at `verif/tb_3des_enc.sv`.

---

## Specifications

- **Module Name**: `des3_enc`

- **File Name**: `des3_enc.sv` (to be added in `rtl` directory)

- **Parameters**:
    - `NBW_DATA`: Bit width of the input and output data blocks.
        - Default: 64.
        - Related interface signals: `i_data`, `o_data`.
    - `NBW_KEY`: Bit width of the key.
        - Default: 192.
        - Related interface signal: `i_key`.  
        - The 192-bit key is interpreted as three concatenated 64-bit DES keys (K1, K2, K3) used for Triple DES encryption, where `K1 = i_key[1:64]`, K2 = `i_key[65:128]`, and `K3 = i_key[129:192]`.

- **Functionality**: Implements 3DES encryption in EDE (Encrypt-Decrypt-Encrypt) mode using three 64-bit keys (K1, K2, K3). The input plaintext is encrypted with K1, decrypted with K2, and encrypted again with K3.

- **Latency**: The block's latency, from when `i_valid` is read until `o_valid` is asserted, is **48 cycles**, where each DES stage takes 16 cycles and the process is fully pipelined.

---

## Interface Signals

  | Signal              | Direction | Width            | Description                                                                                                              |
  |---------------------|-----------|------------------|---------------------------------------------------------------------------------------------------------------------     |
  | `clk`               | Input     | 1                | Drives the sequential logic on the rising edge.                                                                          |
  | `rst_async_n`       | Input     | 1                | Active-low asynchronous reset; clears all internal registers and state.                                                  |
  | `i_valid`           | Input     | 1                | Active high. Indicates that `i_data` and `i_key` are valid and ready to be processed.                                    |
  | `i_data`            | Input     | [1:NBW_DATA]     | 64-bit plaintext input block (MSB-first).                                                                                |
  | `i_key`             | Input     | [1:NBW_KEY]      | 192-bit 3DES key, treated as three concatenated 64-bit keys: `{K1, K2, K3}`.                                             |
  | `o_valid`           | Output    | 1                | Asserted high when `o_data` contains valid encrypted data. It is asserted for as many cycles as `i_valid` is asserted.   |
  | `o_data`            | Output    | [1:NBW_DATA]     | 64-bit ciphertext output block (MSB-first).                                                                              |

### Prompt 13 ###
Integrate the `des_enc` and `des_dec` modules to perform the Triple Data Encryption Standard (TDES) decryption. This new module must not allow burst operations; instead, it must perform start/done controlled operations, where whenever a start occurs, the done signal must be de-asserted, and any data, key, or start signals are ignored until the done signal is asserted again. A testbench for this new module is available at `verif/tb_3des_dec.sv`.

Also, update the `des_enc` and `des_dec` so that the `o_valid` signal from their interface and all logic related to them are removed, and `i_valid` input signal is renamed to `i_start`.

---

## Specifications

- **Module Name**: `des3_dec`

- **File Name**: `des3_dec.sv` (to be added in `rtl` directory)

- **Parameters**:
    - `NBW_DATA`: Bit width of the input and output data blocks.
        - Default: 64.
        - Related interface signals: `i_data`, `o_data`.
    - `NBW_KEY`: Bit width of the key.
        - Default: 192.
        - Related interface signal: `i_key`.  
        - The 192-bit key is interpreted as three concatenated 64-bit DES keys (K1, K2, K3) used for Triple DES decryption, where `K1 = i_key[1:64]`, K2 = `i_key[65:128]`, and `K3 = i_key[129:192]`.

- **Functionality**: Implements 3DES decryption in DED (Decrypt-Encrypt-Decrypt) mode using three 64-bit keys (K3, K2, K1). The input ciphertext is decrypted with K3, encrypted with K2, and decrypted again with K1.

- **Latency**: The block's latency, from when `i_start` is read until `o_done` is asserted, is **48 cycles**, where each DES stage takes 16 cycles.

---

## Interface Signals

  | Signal              | Direction | Width            | Description                                                                                                                           |
  |---------------------|-----------|------------------|---------------------------------------------------------------------------------------------------------------------------------------|
  | `clk`               | Input     | 1                | Drives the sequential logic on the rising edge.                                                                                       |
  | `rst_async_n`       | Input     | 1                | Active-low asynchronous reset; clears all internal registers and state.                                                               |
  | `i_start`           | Input     | 1                | Active high. Indicates that `i_data` and `i_key` are valid and ready to be processed.                                                 |
  | `i_data`            | Input     | [1:NBW_DATA]     | 64-bit ciphertext input block (MSB-first).                                                                                            |
  | `i_key`             | Input     | [1:NBW_KEY]      | 192-bit 3DES key, treated as three concatenated 64-bit keys: `{K1, K2, K3}`.                                                          |
  | `o_done`            | Output    | 1                | Asserted high when `o_data` contains valid encrypted data. It remains asserted until a new `i_start` signal is received.              |
  | `o_data`            | Output    | [1:NBW_DATA]     | 64-bit plaintext output block (MSB-first). After the decryption is calculated, it must remain stable until a next decryption is done. |

### Prompt 14 ###
Design a `Min_Hamming_Distance_Finder` module in SystemVerilog. Refer to the specification provided in `docs/min_hamming_distance_finder_spec.md` to design the RTL. The specification describes a parameterized module that computes the minimum Hamming distance between a query vector and a set of reference vectors. The module accepts one input query and a configurable number of reference vectors and outputs the index of the reference vector with the smallest Hamming distance, along with the corresponding distance value.

## Design Considerations

- The design should be hierarchical, with the **Min_Hamming_Distance_Finder** module as the top-level and the following submodules:
  - **Bit_Difference_Counter**: Calculates the Hamming distance between two vectors.
  - **Data_Reduction**: Performs bitwise reduction (e.g., XOR) on paired bits from two vectors.
  - **Bitwise_Reduction**: Handles the actual logic operation specified (XOR in this case).
- The design should be parameterized using **BIT_WIDTH** and **REFERENCE_COUNT** to allow flexibility in vector width and number of references.
- The code should be well-documented with clear comments explaining the functionality of each major block and how the minimum distance and best match index are computed.
- The design should follow best practices in **SystemVerilog** coding, ensuring readability, modularity, and maintainability.

### Prompt 15 ###
Extend the existing RTL folder that includes `Min_Hamming_Distance_Finder`(`rtl/Min_Hamming_Distance_Finder.sv`) , `Data_Reduction`(`rtl/Data_Reduction.sv`), and `Bitwise_Reduction` (`rtl/Bitwise_Reduction.sv`) to add a new top-level module named `Adaptive_Binary_Pattern_Classifier`. This new module has to integrate Hamming distance-based matching, Gray-code-like feature extraction, and input uniformity detection into a single design suitable for binary pattern classification. The design reuses the existing Min_Hamming_Distance_Finder, Data_Reduction, and Bitwise_Reduction modules and adds configurable parameters for data width, reference count, and label width. The following files are to be present in `rtl` directory.

- `rtl/Bitwise_Reduction.sv`
- `rtl/Data_Reduction.sv`
- `rtl/Bit_Difference_Counter.sv`
- `rtl/Min_Hamming_Distance_Finder.sv`
- `rtl/Adaptive_Binary_Pattern_Classifier.sv`

---

## Key Module: `Adaptive_Binary_Pattern_Classifier`

### Purpose

Performs binary input classification by comparing an input vector against a set of reference vectors using Hamming distance, extracting a set of bitwise features, and checking for uniformity. Outputs include the predicted label from the closest match, distance, match index, features, and uniformity status.

### Parameters

- `BIT_WIDTH`: Defines the width of each input and reference pattern in bits, with a default value of 8. This must be a positive integer greater than or equal to 1.
- `REFERENCE_COUNT`: Defines the number of reference patterns used for comparison, with a default value of 8. This must be a positive integer greater than or equal to 1.
- `LABEL_WIDTH`: Defines the bit-width of the output label associated with each reference pattern, with a default value of 4. This must be a positive integer sufficient to represent all unique labels.
---

### Inputs

- `input_query [BIT_WIDTH-1:0]`: A binary vector representing the input pattern to be classified. Its width is defined by the parameter BIT_WIDTH.
- `reference_data [REFERENCE_COUNT*BIT_WIDTH-1:0]`: A concatenated array of binary reference patterns. Each reference is BIT_WIDTH bits wide, and there are REFERENCE_COUNT references.
- `reference_labels [REFERENCE_COUNT*LABEL_WIDTH-1:0]`: A concatenated array of class labels corresponding to each reference pattern. Each label is LABEL_WIDTH bits wide, and there are REFERENCE_COUNT labels.

---

### Outputs

- `predicted_label [LABEL_WIDTH-1:0]`: The output label corresponding to the reference pattern that best matches the input_query. The label is LABEL_WIDTH bits wide.
- `min_distance [$clog2(BIT_WIDTH+1)-1:0]`: The minimum Hamming distance between the input_query and all reference patterns. Its width is calculated as the ceiling of log₂(BIT_WIDTH+1) to accommodate the maximum possible distance.
- `match_index [$clog2(REFERENCE_COUNT)-1:0]`: The index of the reference pattern which has the minimum Hamming distance to the input_query. Its width is determined by the ceiling of log₂(REFERENCE_COUNT).
- `bitwise_features [BIT_WIDTH-1:0]`: A set of features extracted by performing a bitwise XOR between the original input_query and its 1-bit right-shifted version, resulting in a BIT_WIDTH-bit output.
- `is_input_uniform`: A single-bit flag indicating whether all bits in `input_query` are uniform. A high signal indicates that the input is uniform.

---

### Functional Description

#### Best Match Identification:
- The module instantiates the `Min_Hamming_Distance_Finder` to calculate the Hamming distance between the `input_query` and each reference in `reference_data`. The module produces both the best match index (`match_index`) and the associated minimum distance (`min_distance`).

#### Label Prediction:
- Using the best match index generated by the Hamming distance module, the corresponding label is selected from `reference_labels` and output as `predicted_label`.

#### Bitwise Feature Extraction:
- The `input query` is shifted right by one bit. The module then applies the `Data_Reduction` block with a 2-input XOR reduction on the concatenated original and shifted vectors. The result is provided as `bitwise_features`, representing extracted Gray-coded features.

#### Uniformity Check:
- The module uses a `Bitwise_Reduction` block performing an AND reduction on the original input_query bits to set the `is_input_uniform` flag. This flag indicates if all bits of the input are uniform.

---

## Example Operation

**Input:**
- `input_query` = `8'b11001100`
- `reference_data` = `{8'b11001101, 8'b10011001, 8'b11110000, 8'b11001110}`
- `reference_labels` = `{4'b0001, 4'b0010, 4'b0011, 4'b0100}`

**Expected Outputs:**
- `predicted_label` = `4'b0001`
- `min_distance` = `1`
- `match_index` = `0`
- `bitwise_features` = `8'b10101010` 
- `is_input_uniform` = `0` 

## Testbench Implementation:

### Testbench File: 
- Create a SystemVerilog testbench (`tb_Min_Hamming_Distance_Finder.sv`) that generates stimulus only and save it in the verif directory.

### Module Instance:
- Instantiate the Adaptive_Binary_Pattern_Classifier module as uut (Unit Under Test) within the testbench. The module should be parameterized with BIT_WIDTH, REFERENCE_COUNT, and LABEL_WIDTH, and properly wired to the testbench signals.

### Tasks:
- Implement reusable and clearly defined tasks to drive different stimulus scenarios for verifying the classifier module's functionality. The tasks should include the following:

#### 1. Corner Case Testing Task 
- Test various edge-case scenarios to validate correctness and robustness:
   - Scenario 1: All references are identical to the input query (expected minimum Hamming distance = 0).
   - Scenario 2: All references are completely different from the input (maximum possible distance).
   - Scenario 3: Only one reference perfectly matches the input.
   - Scenario 4: Two or more references result in tied minimum Hamming distances.
   - Scenario 5: Input query is all zeros with nonzero reference patterns.

- Each scenario should include structured logging using a custom task that prints query, reference data, labels, predicted label, computed distance, match index, and feature vector.

#### 2. Feature Extraction & Uniformity Testing Task 
- Test feature logic that computes the bitwise Gray code and detects uniform input patterns:
   - Test 1: Input is all 1s – check that is_input_uniform is high.
   - Test 2: Input is all 0s – check expected behavior of bitwise_features and is_input_uniform.
- Each test prints status messages and confirms logic correctness through readable output.

#### 3. Randomized Testing Task 
- Randomly generate input queries, reference vectors, and labels to stimulate the module under varied conditions:
- Run at least 50 randomized test cases.
- For each case:
   - Randomize input_query.
   - Generate and assign random values to reference_data and reference_labels.
   - Optionally track the expected minimum Hamming distance and index to cross-check correctness.
   - Print detailed output for review using the print task.

#### 4. Structured Input Application Task 
- Provide a reusable task for consistent and informative logging of test case details. The task should display the following:
  - Query vector.
  - Each reference's data and associated label.
  - Output from the DUT: predicted label, index of closest match, minimum Hamming distance.
  - Feature extraction result and uniformity detection flag.

### Test Execution Control:
- Start simulation by displaying a header.
- First call the Corner Case Testing Task.
- Then invoke the feature extraction & uniformity testing task.
- Follow with a loop calling the randomized testing task repeatedly.
- End simulation cleanly using $finish after completing all stimulus.

### Prompt 16 ###
I have a SystemVerilog testbench  `tb_Min_Hamming_Distance_Finder` for the `Min_Hamming_Distance_Finder` module located in `verif/tb_Min_Hamming_Distance_Finder.sv`. The testbench needs to be enhanced to include comprehensive checker functionality that validates the correctness of the design across multiple scenarios, including both edge-case inputs and random test vectors. The following enhancements are required:

## Reference Calculation in Each Test

- Introduce a function that computes the expected Hamming distance between the input query and each reference.
- Determine the minimal distance among all references and the corresponding best match index.
- Ensure these expected results are recalculated for each test scenario (edge cases, random inputs, etc.) so that they remain accurate and relevant.

## Centralized Checker Task

- Create a dedicated checker task that compares the outputs of the DUT (specifically, best_match_index and min_distance) to the expected reference values computed above.
- Print detailed PASS/FAIL messages based on the comparison results.
- If the output matches the expected values, log a PASS and increment the passed-test counter.
- If it does not match, log a FAIL, show the expected vs. actual values, and increment the failed-test counter.
- This checker task should be invoked each time the testbench applies new inputs, ensuring every scenario is automatically validated.

## Coverage Tracking and Summary

- Track the total number of tests run, along with how many passed and how many failed.
- After all tests complete, print a summary message displaying the counts of passed and failed tests.
- If any tests fail, display an appropriate error message to guide debugging efforts. Otherwise, indicate that all tests passed successfully.

## Testbench Features

- Dynamic Reference Calculation: The expected best match index and minimum distance are recalculated for each scenario, guaranteeing that the checker always compares against correct expected values.
- Error Logging: Whenever a test fails, the testbench logs the mismatch with enough detail to pinpoint the error (input query, references, expected results, and actual DUT outputs).
- Test Coverage Reporting: The testbench prints a concise summary of pass/fail statistics, making it easy to assess overall design correctness.

### Prompt 17 ###
Design a `pcie_endpoint` module in System Verilog which is responsible for handling `PCIe transactions`, interfacing with a `DMA engine`, and managing `MSI-X interrupts`. It processes `PCIe Transaction Layer Packets` (TLPs), decodes them, and executes the corresponding read/write operations. This module follows a `Finite State Machine` (FSM) approach to ensure proper sequencing of PCIe endpoint write and read transactions. The design is parameterizable, allowing flexibility in configuring data width and address width. Please refer to the specification provided in `docs/specs.md` for detailed design description.

## **Parameterization**
- **Address Width (`ADDR_WIDTH`)**: Default **64 bits**, configurable for different PCIe address sizes.
- **Data Width (`DATA_WIDTH`)**: Default **128 bits**, supporting high-speed PCIe transfers.

## **1. Features**
### **PCIe Transaction Handling**
- Receives PCIe TLPs and processes valid transactions.
- Decodes received TLPs and forwards them for execution.
- Transmits processed transactions.

### **DMA Engine Interface**
- Supports DMA requests and generates corresponding complete requests.
- Provides `dma_address` and `dma_data` signals to interact with external memory controllers.

### **MSI-X Interrupt Management**
- Generates MSI-X interrupts upon DMA completion.
- Ensures proper sequencing of interrupt generation to prevent missed events.

## **2. Functional Description**
The `pcie_endpoint` module consists of multiple FSMs, each handling a distinct function:

### **PCIe Transaction FSM**
- Manages the reception and processing of incoming PCIe TLPs.
- Decodes received transactions and prepares them for further execution.

### **PCIe Data Link FSM**
- Handles transmission of PCIe transactions.
- Ensures data integrity and proper sequencing of outgoing TLPs.

### **DMA FSM**
- Manages the interaction with the DMA engine.
- Tracks DMA requests and ensures completion of memory operations.

### **MSI-X FSM**
- Generates MSI-X interrupts upon successful completion of DMA operations.
- Ensures correct signaling of interrupts to the host system.

## **3. Transaction Flow**
### **PCIe Write Transaction**
1. Receives a PCIe TLP.
2. Decodes and processes the transaction.
3. Stores the data in the appropriate memory location.

### **PCIe Read Transaction**
1. Receives a read request from PCIe.
2. Fetches the required data from memory.
3. Sends the data as a PCIe response.

### **DMA Transaction**
1. Receives a DMA request.
2. Reads or writes data from/to memory.
3. Signals DMA completion.

### **MSI-X Interrupt Generation**
1. Detects completion of DMA operations.
2. Generates an MSI-X interrupt signal.
3. Waits for acknowledgment before resetting the interrupt state.

## **4. SystemVerilog Best Practices**
- **Modular Design:** FSMs are independently implemented for different functions, ensuring better maintainability.
- **Parameterization:** Address and data width are configurable to accommodate various PCIe configurations.
- **Clock Domain Handling:** All FSMs operate under a single `clk` domain to maintain synchronization.
- **Reset Handling:** The `rst_n` signal ensures proper initialization of all FSMs and state registers.

The code follows best practices in SystemVerilog, ensuring readability, reusability, and maintainability. Proper comments and documentation are included to explain the functionality of each major block.

### Prompt 18 ###
I have an `alu_core` module available in the `rtl` directory, and its specification is in the `docs` directory. Kindly modify the module by adding SystemVerilog assertions. The assertions should ensure that the module correctly handles valid opcodes (`0` through `7`) and that each arithmetic operation produces a result within the valid signed 32-bit range.

## **Assertion Details**  
The assertions should verify the following conditions:
1. **Opcode Valid Range Check**: Ensure that the input `opcode` is within the range `0–7`. If an invalid `opcode` is detected, it should trigger an **error message**.
2. **Overflow Checks**:  
   - **Addition/Subtraction**: Verify no overflow occurs for 32-bit signed addition and subtraction.  
   - **Multiplication**: Verify that the product is within the valid 32-bit signed range.  
   - **Division**: Verify that division by zero does not occur.
3. **Result Bounds Check**: Confirm that the final `result` always remains within the valid signed 32-bit range after each operation.

## **Expected Behavior**  
If any of the assertions fail, they should generate an **error message** indicating the incorrect behavior.

### Prompt 19 ###
We currently have a SystemVerilog testbench `alu_core_tb.sv` in the `verif` directory that provides stimulus for the `alu_core` module. The design specification of `alu_core` is outlined in `docs` directory. We want to enhance this testbench to not only drive inputs but also verify the DUT (Device Under Test) output against expected results using a reference function.

**Goal**  
1. Implement checker logic in the testbench to compare DUT output (`result`) with the expected result computed using a reference model.  
2. Use a function to model expected outputs based on the opcode and operand values.  
3. Maintain a fail counter to track any mismatches and report the final status at the end of simulation.

---

## Required Additions

1. **Function to Compute Expected Output**  
   - Implement a `golden` reference function that accepts the operation code (`opcode`) and the three signed input operands (`operand1`, `operand2`, and `operand3`).  
   - Based on the opcode, compute the expected result as follows:  
     - For opcode `0x0`, perform signed addition of all three operands.  
     - For opcode `0x1`, perform signed subtraction of the second and third operands from the first.  
     - For opcode `0x2`, perform signed multiplication of all three operands.  
     - For opcode `0x3`, perform signed division of the first operand by the second, and then the result by the third.  
     - For opcode `0x4`, perform bitwise AND of all three operands.  
     - For opcode `0x5`, perform bitwise OR of all three operands.  
     - For opcode `0x6`, perform bitwise XOR of all three operands.  
     - For any unsupported opcode, return a default value (e.g., zero).  

2. **Checker Logic**  
   - For each test case, drive `opcode`, `operand1`, `operand2`, and `operand3` to the DUT.  
   - After a short simulation delay, compute the expected result using the `golden` function.  
   - Compare the DUT's `result` with the expected value and print a "PASS" or "FAIL" message accordingly.  
   - Keep a counter (`fail_count`) that increments on each mismatch to track total failures.

3. **Random and Deterministic Test Scenarios**  
   - Use the `run_test` task to apply a series of fixed test cases covering different arithmetic and logic operations.  
   - Additionally, apply a set of random test vectors by randomly generating `opcode`, `operand1`, `operand2`, and `operand3` values.  
   - For each random case, verify the result against the expected output from the `golden` function and log the result.

4. **Final Result Summary**  
   - At the end of the testbench, display the total number of mismatches encountered using the `fail_count`.  
   - If the counter is non-zero, report that failures occurred during testing.  
   - If no mismatches are found, report that all tests passed successfully.

---

### Prompt 20 ###
### **Bug Fix Request in Arithmetic progression generator RTL**  

I have the Arithmetic progression generator RTL in the current directory, and I need assistance in fixing the following bugs:  

#### **Identified Bugs:**  
1. **Overflow Handling:** Overflow occurs in `out_val` and `counter` when the input values reach their maximum limits.  
2. **Missing Condition for Sequence Length Zero:** The design lacks a check for a sequence length of `0`, leading to incorrect behavior when `0` is applied, as operations continue instead of being skipped.
  
Could you help resolve these bugs in the RTL?

### Prompt 21 ###
Design a `async_fifo` module in SystemVerilog. Refer to the specification provided in `docs/fifo.md` and ensure you understand its content.

### Prompt 22 ###
Create a self-checking test bench in SystemVerilog for a Verilog module named `async_fifo`. The **async_fifo** design is a parameterizable asynchronous FIFO module. It uses separate clock domains for writing and reading, providing safe data transfer between two clock domains. The design employs dual-port memory and Gray-coded pointers for reliable synchronization. The test bench should systematically generate input vectors along with checkers and apply them to the module under test (MUT).

# Stimulus and checker Generation

Below are all test cases designed to verify the `async_fifo` module.

**Setup:**
- `p_data_width = 8`
- `p_addr_width = 4`
- Write clk = 10 ns, Read clk = 12 ns

---

## Test Case 1: Basic Write-Read

**Description:**  
Write a sequence of data and read it back with asynchronous clocks.

**Sequence:**
1. Deassert resets.
2. Write 8 sequential values.
3. Read back all values.

**Expected Output:**
- Read data matches write data in order.
- `o_fifo_empty` = 1 after final read.
- `o_fifo_full` remains 0.

---

## Test Case 2: Fill-and-Drain (Full/Empty Flag Test)

**Description:**  
Completely fill and then completely drain the FIFO.

**Sequence:**
1. Write 16 items to FIFO.
2. Observe `o_fifo_full = 1`.
3. Read all data.
4. Observe `o_fifo_empty = 1`.

**Expected Output:**
- Full flag asserted on 16th write.
- Empty flag asserted after final read.
- Data preserved in order.

---

## Test Case 3: Pointer Wrap-Around

**Description:**  
Test pointer wrap-around logic at FIFO depth boundaries.

**Sequence:**
1. Continuously write 20 items.
2. Slowly read back data.

**Expected Output:**
- No data corruption.
- Flags assert/deassert correctly.
- Wrap-around handled correctly i.e data will not be overwritten. 

---

## Test Case 4: Write Domain Reset

**Description:**  
Test behavior when only the write side is reset.

**Sequence:**
1. Write till Fifo is full.
2. Reset `i_wr_rst_n`.
3. Read Back.

**Expected Output:**
- Write pointer resets.
- o_fifo_full should dessert.
- Read should all be 0.

---

## Test Case 5: Read Domain Reset

**Description:**  
Test behavior when only the read side is reset.

**Sequence:**
1. Continuously write data.
2. Reset `i_rd_rst_n`.
3. Read Back.

**Expected Output:**
- Read pointer resets and o_fifo_empty should assert.
- Read should all be 0.

---

## Test Case 6: Simultaneous Reset

**Description:**  
Reset both domains simultaneously.

**Sequence:**
1. Write and read some data.
2. Assert both resets.
3. Resume operation.

**Expected Output:**
- FIFO is reset (empty).
  - o_fifo_full should dessert.
  - o_fifo_empty should assert.
- No data corruption.
- Full functionality restored.

---

### Prompt 23 ###
Create a test bench in SystemVerilog for a Verilog module named `async_fifo`. The **async_fifo** design is a parameterizable asynchronous FIFO module. It uses separate clock domains for writing and reading, providing safe data transfer between two clock domains. The design employs dual-port memory and Gray-coded pointers for reliable synchronization. The test bench should systematically generate input vectors, apply them to the module under test (MUT) and aim to achieve 100% or the maximum possible coverage.

# Stimulus Generation

Below are all test cases designed to maximize coverage of the `async_fifo` module.

**Setup:**
- `p_data_width = 8`
- `p_addr_width = 4`
- Write clk = 10 ns, Read clk = 12 ns

---

## Test Case 1: Basic Write-Read

**Description:**  
Write a sequence of data and read it back with asynchronous clocks.

**Sequence:**
1. Deassert resets.
2. Write 8 sequential values.
3. Read back all values.

---

## Test Case 2: Fill-and-Drain (Full/Empty Flag Test)

**Description:**  
Completely fill and then completely drain the FIFO.

**Sequence:**
1. Write 16 items to FIFO.
2. Observe `o_fifo_full = 1`.
3. Read all data.
4. Observe `o_fifo_empty = 1`.

---

## Test Case 3: Pointer Wrap-Around

**Description:**  
Test pointer wrap-around logic at FIFO depth boundaries.

**Sequence:**
1. Continuously write 20 items.
2. Slowly read back data.


---

## Test Case 4: Write Domain Reset

**Description:**  
Test behavior when only the write side is reset.

**Sequence:**
1. Write till Fifo is full.
2. Reset `i_wr_rst_n`.
3. Read Back.

---

## Test Case 5: Read Domain Reset

**Description:**  
Test behavior when only the read side is reset.

**Sequence:**
1. Continuously write data.
2. Reset `i_rd_rst_n`.
3. Read Back.

---

## Test Case 6: Simultaneous Reset

**Description:**  
Reset both domains simultaneously.

**Sequence:**
1. Write and read some data.
2. Assert both resets.
3. Resume operation.

---

### Prompt 24 ###
I have multiple modules with below functionalities.
#### 1. `read_to_write_pointer_sync`
Synchronizes the Gray-coded read pointer from the read clock domain to the write clock domain.

#### 2. `write_to_read_pointer_sync`
Synchronizes the Gray-coded write pointer from the write clock domain to the read clock domain.

#### 3. `wptr_full`
Handles the write pointer logic, updates the pointer upon valid writes, and detects FIFO full condition.

#### 4. `fifo_memory`
Dual-port RAM used to store the FIFO data. Supports simultaneous write and read using separate clocks.

#### 5. `rptr_empty`
Handles the read pointer logic, updates the pointer upon valid reads, and detects FIFO empty condition.

Refer to the specification provided in `docs/fifo.md` and ensure you understand its content. I want you to integrate all these modules to create a top level module named `async_fifo`.

### Prompt 25 ###
Create an `async_filo` module in SystemVerilog to implement a First-In-Last-Out (FILO) memory buffer with asynchronous read and write clock domains. Refer to the specification in `docs/spec.md`, which details the design requirements.

### The module must:

  - Support independent read and write clocks (r_clk and w_clk)
  - Be parameterized for data width and depth
  - Handle push and pop operations in a FILO manner
  - Safely synchronize read and write pointers across clock domains using Gray coding
  - Generate status flags:
    - `w_full`: asserted when the FILO is full from the write domain
    - `r_empty`: asserted when the FILO is empty from the read domain

### Prompt 26 ###
Modify `axi4lite_to_pcie_cfg_bridge` module with read functionality, which is a critical part of any `AXI4-Lite` interface. In an `AXI4-Lite-based` system, both write and read transactions are required to allow the CPU or other `master` devices to communicate with peripherals and memory-mapped registers effectively. Refer to the specification provided in docs/axilite_to_pcie_config_module.md to implement the RTL for Read transaction.

## Modifications to the RTL for Read Support :
#### To support read transactions, we need to introduce:
- New Read-Related Ports in the module interface.
- FSM Modifications to handle read transactions.
- Additional Internal Logic to drive the read response.
---
### Proposed Modifications 

This module is parameterized, allowing flexibility in configuring **data width, address width**.

- **`DATA_WIDTH`**: Configures the bit-width of data. Default value is **32 bits**.
- **`ADDR_WIDTH`**: Determines the config memory size by specifying the number of address bits. Default value is **8 bits**.
 
#### Here is a table describing the ports to be added newly for handling read transactions:

#### **IO Ports Description**
| Port Name | Direction | Width   | Description                        |
|-----------|-----------|---------|------------------------------------|
| araddr    | Input     | 8-bits  | Read address from AXI4-Lite master |
| arvalid   | Input     | 1-bit   | Read address valid signal          |
| arready   | Output    | 1-bit   | Read address ready signal          |
| rdata     | Output    | 32-bits | Read data output                   |
| rvalid    | Output    | 1-bit   | Read data valid signal             |
| rready    | Input     | 1-bit   | Read data ready signal             |
| rresp     | Output    | 2-bit   | Read response signal               |

**Read FSM Implementation**

The read transaction follows a similar FSM pattern as the write transaction but includes the following states:
- `IDLE` – Waits for `arvalid` to be asserted.
- `ADDR_CAPTURE` – Captures the read address.
- `PCIE_READ` – Initiates a read operation from PCIe configuration space.
- `SEND_RESPONSE` – Sends the read data back to the AXI4-Lite master.

These states ensure that the read request is handled efficiently while maintaining AXI4-Lite protocol compliance.

---

### **Module Specification: `axi4lite_to_pcie_cfg_bridge`**

This section specifies the current version of the module before modification. The axi4lite_to_pcie_cfg_bridge module implements AXI4Lite write functionality.

The AXI4-Lite to PCIe Configuration Space Bridge provides an interface for writing configuration data to the PCIe Configuration Space using the AXI4-Lite protocol. This ensures seamless communication between the AXI4-Lite master and PCIe configuration registers. The bridge translates AXI4-Lite transactions into PCIe-compatible signals, enabling system configurations and status updates through register writes.

Write Port Descriptions:
|    Port Name   | Direction |  Width  |                  Description                  |
|:--------------:|:---------:|:-------:|:---------------------------------------------:|
| awaddr         | Input     | 8-bits  | Write address from AXI4-Lite master.          |
| awvalid        | Input     | 1-bit   | Write address valid signal.                   |
| awready        | Output    | 1-bit   | Write address ready signal.                   |
| wdata          | Input     | 32-bits | Write data from AXI4-Lite master.             |
| wstrb          | Input     | 4-bits  | Write strobe signal to indicate active bytes. |
| wvalid         | Input     | 1-bit   | Write data valid signal.                      |
| wready         | Output    | 1-bit   | Write data ready signal.                      |
| bresp          | Output    | 2-bit   | Write response (OKAY, SLVERR, etc.).          |
| bvalid         | Output    | 1-bit   | Write response valid signal.                  |
| bready         | Input     | 1-bit   | Write response ready signal.                  |
| pcie_cfg_addr  | Output    | 8-bits  | PCIe configuration address for transaction.   |
| pcie_cfg_wdata | Output    | 32-bits | Data to be written into PCIe config space.    |
| pcie_cfg_wr_en | Output    | 1-bit   | Write enable for PCIe configuration space.    |
| pcie_cfg_rdata | Input     | 32-bits | Data read from PCIe configuration space.      |
| pcie_cfg_rd_en | Input     | 1-bit   | Read enable for PCIe configuration space.     |

---

### Write Transaction Flow
The write process consists of the following steps:
**Address Phase:**
- The AXI4-Lite master sends the write address (`awaddr`) along with `awvalid`.
- The bridge asserts `awready` when it is ready to accept the address.

**Data Phase:**
- The master provides the write data (`wdata`) and write strobes (`wstrb`).
- The bridge asserts `wready` to indicate it is ready to accept the data.

**PCIe Write Transaction:**
- The bridge forwards the write address (`pcie_cfg_addr`) and data (`pcie_cfg_wdata`) to the PCIe Configuration Space.
- `pcie_cfg_wr_en` is asserted to signal a valid PCIe write operation.

**Write Response:**
- Once the write is complete, the bridge asserts `bvalid` with an acknowledgment response (`bresp`).
- The master acknowledges by asserting `bready`, completing the transaction.

**Write Process Example**
***Input***
|  Signal |     Value    |            Description           |
|:-------:|:------------:|:--------------------------------:|
| awaddr  | 32'h00000010 | Address to write data to.        |
| awvalid | 1'b1         | Address is valid.                |
| wdata   | 32'hAABBCCDD | Data to be written.              |
| wstrb   | 4'b1111      | Writing all 4 bytes.             |
| wvalid  | 1'b1         | Write data is valid.             |
| bready  | 1'b1         | Ready to receive write response. |

***Output***
|     Signal     |     Value    |          Description          |
|:--------------:|:------------:|:-----------------------------:|
| awready        | 1'b1         | Write address is accepted.    |
| wready         | 1'b1         | Write data is accepted.       |
| pcie_cfg_addr  | 8'h10        | PCIe address for transaction. |
| pcie_cfg_wdata | 32'hAABBCCDD | Data to be written to PCIe.   |
| pcie_cfg_wr_en | 1'b1         | PCIe write enable asserted.   |
| bvalid         | 1'b1         | Write response is valid.      |
| bresp          | 2'b00 (OKAY) | Write successful response.    |

The code should be well-documented with clear comments explaining the functionality of each major block. Follow best practices in SystemVerilog coding to ensure readability, reusability, and maintainability.

### Prompt 27 ###
I have a AXI4Lite to PCIe config module `axi4lite_to_pcie_cfg_bridge.sv` available in the `rtl` directory. Please modify the module by adding SystemVerilog Assertions (SVA) to check its internal functionality comprehensively. The assertions should verify the following conditions:

**awready_assertion** – 
- Ensures (`awready`) asserts within 2 cycles after (`awvalid`) is asserted.

**wready_assertion** – 
- Checks that (`wready`) asserts within 2 cycles after (`wvalid`) is asserted.

**bvalid_assertion** – 
- Verifies that (`bvalid`) asserts within 5 cycles after both (`awvalid and wvalid`) handshake.

**rvalid_assertion** – 
- Ensures (`rvalid`) asserts within 10 cycles after an (`arvalid and arready`) handshake.

**arready_assertion** – 
- Checks that (`arready`) asserts within 2 cycles after (`arvalid`) is asserted.

**rvalid_deassertion** – 
- Ensures (`rvalid`) deasserts within 3 cycles after (`rready`) is asserted.

**bvalid_deassertion** – 
- Checks that (`bvalid`) deasserts within 3 cycles after (`bready`) is asserted.

**arready_deassertion** – 
- Ensures (`arready`) deasserts within 5 cycles after (`arvalid and arready`) handshake.

If any of these conditions are violated during simulation, an appropriate error message should be displayed.

### Prompt 28 ###
The `axis_broadcast` module is an AXI Stream broadcast unit that takes a single AXI Stream input and distributes it to three output channels while ensuring synchronized data flow. It ensures that data is only forwarded when all receiver are ready to receive the data. the module should also be able to handle back pressure from the receiver.

During testing it is found that when one or more receiver system is not ready to receive the data, the data broadcasted for the same cycle is lost.

**Bug Description:**
   - In the provided RTL, when one of the master axi stream ready signal  `m_axis_tready_*` is not high, the current data will not be transmitted as data is only forwarded when all receiver are ready to receive the data. but the `s_axis_tready` will be updated in next cycle only 
   - As a result of this the current data from slave will be lost.

Below is a table showing the expected and actual behavior of the `axis_broadcast` module

| `slave_data` | Expected `master_data out` | Actual `master_data out` | `master_ready out` | Expected `slave_ready out` |
|--------------|----------------------------|--------------------------|--------------------|----------------------------|
| `0xA5`       | `x`                        | `x`                      | 1                  | 1                          |
| `0x5A`       | `0xA5`                     | `0xA5`                   | 0                  | 1                          |
| `0x5B`       | `0xA5`                     | `0xA5`                   | 1                  | 0                          |
| `0x5B`       | **`0x5A`**                 | **`0x5B`**               | 1                  | 1                          |


The module and its testbench are available in the current working directory for further debugging.

### Prompt 29 ###
Design an `axis_to_uart_tx` module in SystemVerilog. Refer to the specification provided in `docs/axis_to_uart_tx_specs.md` and ensure you fully understand its content. The specification details the module’s parameterization for clock frequency (`CLK_FREQ`), UART bit rate (`BIT_RATE`), word size (`BIT_PER_WORD`), optional parity (0 for none, 1 for odd, 2 for even using combinational parity calculation), and configurable stop bits (`STOP_BITS_NUM`). It also describes the finite state machine (FSM) that controls the transmission process through states such as IDLE, START, DATA, PARITY, STOP1, and STOP2. The module must interface with an AXI-Stream input (using `aclk`, `aresetn`, `tdata`, `tvalid`, and `tready`) and generate a serial UART output (`TX`) with proper timing derived from a clock counter computed using the formula:

```
Cycle_per_Period = (CLK_FREQ * 1,000,000) / BIT_RATE
```

Implement the full RTL code that handles data latching from the AXI-Stream, serial output generation including start bit, data bits (transmitted LSB first), optional parity, and stop bits; correctly manage clock timing and state transitions; and ensure proper reset behavior.

### Prompt 30 ###
Design a `uart_rx_to_axis` module in SystemVerilog. Refer to the specification provided in `docs/uart_rx_to_axis_specs.md` and ensure you fully understand its content. The specification details the module’s parameterization for clock frequency (`CLK_FREQ`), UART bit rate (`BIT_RATE`), word size (`BIT_PER_WORD`), optional parity (0 for none, 1 for odd, 2 for even), and configurable stop bits (`STOP_BITS_NUM`). It also describes the finite state machine (FSM) that controls the reception process through states such as IDLE, START, DATA, PARITY, STOP1, STOP2, and OUT_RDY. The module must interface with a serial UART input (`RX`), detect and sample the start bit, data bits (received LSB first), an optional parity bit, and stop bit(s); then reconstruct the parallel data and output it on an AXI-Stream interface (using `tdata`, `tuser` for parity error indication, and `tvalid`). Proper timing is achieved by using a clock counter computed with the formula:

```
Cycle_per_Period = (CLK_FREQ * 1,000,000) / BIT_RATE
```

Implement the full RTL code that handles:
- Detection of the start bit (using falling-edge detection),
- Sampling of the incoming bits according to the UART timing,
- Correct ordering of data bits using an appropriate shift register implementation,
- Parity computation and verification when enabled,
- Generation of AXI-Stream outputs with correct data (`tdata`), parity error flag (`tuser`), and valid strobe (`tvalid`),
- Proper reset behavior that returns the FSM to the IDLE state.

### Prompt 31 ###
I have a hierarchical UART design consisting of three SystemVerilog modules located in the `/code/rtl` directory:

1. **axis_to_uart_tx.sv**  
   This module converts AXI‑Stream data into a serial UART output. It supports configurable clock frequency, bit rate, word size, optional parity (none, odd, or even), and configurable stop bits. It employs a state machine (states: IDLE, START, DATA, PARITY, STOP1, STOP2) that drives the TX line accordingly.

2. **uart_rx_to_axis.sv**  
   This module converts an incoming UART serial stream into an AXI‑Stream data output. It samples the RX line using a synchronizer and implements its state machine (states: IDLE, START, DATA, PARITY, STOP1, STOP2, OUT_RDY). Based on the received data, it also computes a parity error flag.

3. **axis_to_uart.sv (Top-level module)**  
   This module instantiates the TX and RX blocks, connecting the AXI‑Stream interfaces and physical UART signals.

### Assertion Requirements

Please enhance the design by adding **SystemVerilog Assertions (SVA)** to verify functional correctness and safety across the modules. The assertions should meet the following requirements:

#### For **axis_to_uart_tx.sv**  
- **Reset and Idle Check:**  
  Assert that when the FSM is in the IDLE state, the TX output is high (idle level) and that the module asserts tready.
  
- **START State Check:**  
  Assert that one clock cycle after the FSM enters the START state, the TX signal is low (indicating a proper start bit).
  
- **DATA State Check:**  
  While in the DATA state and during the mid‑bit period (when the clock counter is not zero), assert that TX equals the current data bit from the shift register.
  
- **PARITY State Check:**  
  In the PARITY state, add an assertion to cover the parity check:  
  - When parity is disabled (PARITY_BIT == 0), the FSM must never enter the PARITY state.  
  - When parity is enabled (PARITY_BIT != 0), assert that one cycle after entering the PARITY state, TX equals the computed parity value.
  
- **STOP State Check:**  
  Assert that one cycle after entering either STOP1 or STOP2, TX is high.

#### For **uart_rx_to_axis.sv**  
- **IDLE and OUT_RDY Validity:**  
  Assert that when the FSM is in IDLE, tvalid is low; and when in OUT_RDY, tvalid is high.
  
- **Parity Checking:**  
  Once the FSM is in the PARITY state and the bit period is complete (Clk_Count_Done), wait one clock cycle and then verify that the computed parity error flag (Parity_Err) correctly reflects the comparison between the received parity bit and the computed parity for the data.
  
- **Output Acknowledgment:**  
  Assert that in the OUT_RDY state, if the downstream interface asserts tready, then the FSM should transition to IDLE.

#### For the **axis_to_uart.sv** Top Module  
- **Reset Behavior:**  
  Assert that during reset (when aresetn is low), the top-level outputs (e.g., TX and the AXI‑Stream out interface) remain at their idle values (TX high, out_tvalid low).

### Implementation Notes

- Use SVA syntax to structure your properties, for example using `property ... endproperty` blocks and assertions with `assert property(...) else $error("...")`.
- For the parity assertion in the TX block, consider splitting the check using conditional implications (or a combination of separate properties) such that:  
  - If PARITY_BIT is 0 then the assertion passes if the PARITY state is never entered, and  
  - If PARITY_BIT is nonzero then after one clock cycle in the PARITY state, TX equals Parity_Value.
- Ensure that the tests (for example, via our cocotb testbench) exercise all states of the FSM so that these assertions achieve 100% coverage.
- Do not include your complete RTL code in your submission—only the assertion additions should be provided for each module.

Please generate all the SVA properties for the TX, RX, and top modules according to these requirements.

### Prompt 32 ###
The barrel shifter module is designed to shift a given input data by a specified number of bits either to the left or right, based on a control signal. However, during testing, it was observed that the module failed to produce the expected output, leading to incorrect results. Specifically, when tested with data_in=00100100, shift_bits=1, and left_right=1, the expected output was 01001000, but the module produced 00000000. The module and its testbench are available in the current working directory for debugging.

### Prompt 33 ###
Modify the barrel shifter module to support both logical and arithmetic shift modes and its current functionality (logical shift). The module should shift the input data based on the specified shift amount and direction while ensuring proper sign extension for arithmetic shifts. A new `shift_mode` input control signal should is also introduced to differentiate between logical and arithmetic shift modes.

---

### **Design Specification**

The `barrel_shifter` module is a digital circuit that shifts an input data word left or right by a specified amount. The module shall support arithmetic shift, in addition to the current logical shift functionality. The new control signal, `shift_mode`, selects the corresponding shift mode.

**Modes of Operation**
	1.	**Logical Shift (Default Behavior)**
	- When `shift_mode` = 0, the module performs a logical shift.
	-	For a logical left shift (LSL), zeroes (0s) are shifted into the least significant bits (LSBs).
	-	For a logical right shift (LSR), zeroes (0s) are shifted into the most significant bits (MSBs).
	2.	**Arithmetic Shift**
	-	When `shift_mode` = 1, the module performs an arithmetic shift.
	-	For an arithmetic right shift (ASR), the sign bit (MSB of the original data) is replicated into the vacated MSB positions to preserve the signed value.
	-	For an arithmetic left shift (ALSL), the behavior remains the same as a logical left shift (zeroes shifted into LSBs), since left shifts do not require sign extension.

**Shift Direction Control**
	-	`left_right` = 1: Left Shift (LSL or ALSL, depending on shift_mode)
	-	`left_right` = 0: Right Shift (LSR or ASR, depending on shift_mode)

### **Example Operations**

**Example 1: Logical Right Shift (LSR)**
-	**Input**:
  `shift_mode` = 0, `left_right` = 0, `shift_bits` = 3
  `data_in` = 8'b10110011
- **Expected Output**:
  `data_out` = 8'b00010110

**Example 2: Arithmetic Left Shift (ALSL)**
-	**Input**:
  `shift_mode` = 1, `left_right` = 1, `shift_bits` = 2
  `data_in` = 8'b10101001
- **Expected Output**:
  `data_out` = 8'b10100100 (Same as LSL, no sign extension needed)

### Prompt 34 ###
I have a `barrel_shifter ` module available in the `rtl` directory. Kindly modify the module by adding an `SVA` immediate assertion. The assertion should specifically cover signal validation. This assertion should display error messages when the following condition is violated during simulation.

**Out signal Priority Validation**: 
Ensure that the `data_out ` signals are correctly calculated shift of `data_in` in `left_right` direction for `shift_bits` number of bits and `shift_mode` define the logical or arithmatic. If the result is incorrect, an error message should be displayed.

Following should be the interface of the RTL design of Barrel Shift module named `barrel_shifter `.
## Interface:
### **Input**:
`data_in(8-bit,[7:0])`: 8-bit for input data which need be shifted `barrel_shifter` adder.
`shift_bits(3-bit,[2:0])`: 3-bit for amout of shift `barrel_shifter` adder.
`shift_mode(1-bit)`: 0 for logical or 1 for arithmetic mode selection bit `barrel_shifter` adder.
`left_right(1-bit)`: 0 for Right or 1 for Left shift `barrel_shifter` adder.

### **Output**:
`data_out(8-bit,[7:0])`: 8-bit ouput shift data generated by the `barrel_shifter`.

### Prompt 35 ###
Modify the existing single-digit BCD adder module to support multi-digit BCD addition, subtraction, and comparison. The updated design introduces parameterized modules that process N-digit BCD numbers by chaining single-digit BCD arithmetic. A top-level module is added to perform subtraction-based comparisons using reusable arithmetic logic. Update the `bcd_adder` module to include a `cin` (carry-in) input for chaining, remove invalid input checks (delegating it to higher-level module), and focus solely on single-digit BCD addition with proper decimal correction.

## Design Overview

### Key Modules

1. **bcd_adder**
   - Include a carry-in (`cin`) input for chaining multiple `bcd_adder` blocks in multi-digit designs.
   - Remove invalid output checks (`invalid`) to simplify the module; higher-level modules (like `multi_digit_bcd_add_sub`) must ensure valid BCD input.
   - Focus on single-digit BCD addition with decimal correction—no direct subtraction or invalid input logic.

2. **multi_digit_bcd_add_sub**  
   - Handles N-digit BCD addition and subtraction.
   - Operates on digit-by-digit BCD values (4 bits per digit).
   - Supports both modes of operation: addition and subtraction (9's complement for subtraction).
   - Carries or borrows are propagated between digits.

3. **bcd_top**  
   - Compares two N-digit BCD values using subtraction-based logic by instances of `multi_digit_bcd_add_sub`.
   - Determines if `A` is less than, equal to, or greater than `B`.

### Parameters:
- **N**: Defines the number of BCD digits to process, with a default value of 4. This must be a positive integer greater than or equal to 1.

---

## Module Specifications

### **Single-Digit Arithmetic Module: `bcd_adder`**

**Inputs**
- `a[3:0]`: A single Binary-Coded Decimal (BCD) digit (4-bit).
- `b[3:0]`: A single Binary-Coded Decimal (BCD) digit (4-bit).
- `cin`: A single-bit carry-in for the addition.

**Outputs**

- `sum[3:0]`: The 4-bit BCD sum of the two input digits.
- `cout`: A single-bit carry-out, which indicates an overflow beyond the valid BCD range (i.e., when the result exceeds 9).

**Functionality**
- Adds two 4-bit BCD digits (a and b) along with an optional carry-in (cin).
- Corrects the raw binary sum to produce a valid BCD digit (sum).
- Generates a carry-out (cout) to handle overflow when the resulting sum exceeds 9 in decimal.

---

### **Multi-Digit Arithmetic Module: `multi_digit_bcd_add_sub #(parameter N = 4)`**

**Inputs**  
- `A[4*N-1:0]`: N-digit Binary-Coded Decimal (BCD) input, with each digit represented as a 4-bit binary value 
- `B[4*N-1:0]`: N-digit Binary-Coded Decimal (BCD) input, with each digit represented as a 4-bit binary value 
- `add_sub`: 1-bit Operation selection signal. A high signal (1) selects addition, and a low signal (0) selects subtraction.

**Outputs**  
- `result[4*N-1:0]`: N-digit Binary-Coded Decimal (BCD) result of the operation, each digit represented as a 4-bit binary value
- `carry_borrow`: Single-bit output that indicates a carry-out from addition or a borrow-out from subtraction.

**Functionality**  
- Performs digit-wise BCD arithmetic using instances of `bcd_adder`.
- Carries or borrows are passed between digits.
- In subtraction mode, it automatically handles 9’s complement conversion and the initial carry-in.

---

### **Top-Level Module: `bcd_top #(parameter N = 4)`**

**Inputs**  
- `A[4*N-1:0]`: N-digit Binary-Coded Decimal (BCD) input, with each digit represented as a 4-bit binary value
- `B[4*N-1:0]`: N-digit Binary-Coded Decimal (BCD) input, with each digit represented as a 4-bit binary value

**Outputs**  
- `A_less_B`: Single-bit output is high when A is less than B; otherwise, it remains low.  
- `A_equal_B`: Single-bit output is high when A is equal to B; otherwise, it remains low.
- `A_greater_B`:  Single-bit output is high when A is greater than B; otherwise, it remains low.

**Functionality**  
- Performs subtraction of `A - B` using instances of `multi_digit_bcd_add_sub`.
- Uses the result and the final borrow output to determine comparison flags.



---

## Example Operations

### Example 1: `A Less Than B`

**Input**  
- `A = 8'b00100101`  // BCD for 25  
- `B = 8'b00111000`  // BCD for 38

**Expected Output**  
- `A_less_B = 1`  
- `A_equal_B = 0`  
- `A_greater_B = 0`

### Example 2: `A Equal to B`

**Input**  
- `A = 8'b01000101`  // BCD for 45  
- `B = 8'b01000101`  // BCD for 45

**Expected Output**  
- `A_less_B = 0`  
- `A_equal_B = 1`  
- `A_greater_B = 0`

### Example 3: `A Greater Than B`

**Input**  
- `A = 8'b01010010`  // BCD for 52  
- `B = 8'b00111001`  // BCD for 39

**Expected Output**  
- `A_less_B = 0`  
- `A_equal_B = 0`  
- `A_greater_B = 1`

---

### Prompt 36 ###
I have a `bcd_adder` module implemented in the RTL directory. Write a SystemVerilog testbench `tb_bcd_adder.sv` in the verif directory that generates stimuli to thoroughly test and achieve maximum coverage for the bcd_adder module.

Include the following in the generated testbench:

### Module Instance
Instantiate the `bcd_adder` module as `uut`, ensuring all input and output ports (`a`, `b`, `sum`, `cout`, `invalid`) are properly connected.

### Test Stimulus Task
Implement a reusable task `bcd_addition` that drives inputs `a` and `b` with 4-bit values and displays the outputs with context for traceability and debug.

### Test Scenarios
- Apply all combinations of 4-bit inputs from 0 to 15 for both `a` and `b` to test BCD-valid and BCD-invalid input pairs.
- Display the results of each operation with `a`, `b`, `sum`, `cout`, and `invalid` values.
- Highlight test coverage for both valid and invalid BCD inputs.

### Test Execution Control
- Include a task that systematically iterates over all input combinations using nested loops.
- Print headers and structured logs for traceability.

### Simulation Control
- Use an initial block to trigger the tests and call `$finish` after completion.
- Include waveform dumping via `$dumpfile` and `$dumpvars` for post-simulation analysis.

Do not include scoreboard/checker logic or internal assertions. The testbench should focus solely on stimulus generation and visibility into the DUT response for debug purposes.

### Prompt 37 ###
I have a SystemVerilog testbench named `tb_bcd_adder.sv` in the verif directory, which currently provides basic stimulus for a BCD adder module called `bcd_adder`. The design specification for the adder is located in the docs directory named `bcd_adder_spec.md`. Create a testbench to include checker logic that verifies the outputs of the `bcd_adder` against expected values, as well as maintain coverage metrics and pass/fail summaries.

Modify the existing testbench `tb_bcd_adder.sv` by:

- **Adding Coverage Tracking**
     - Keep track of total, passed, and failed tests.
- **Implementing Thorough Checker Logic**
     - Calculate the expected sum, expected carry-out, and expected invalid signal.
     - Compare them to the module’s outputs.
     - Report pass or fail for each test case.

- **Displaying Test Summary**
     - Print the total number of tests, the number passed, and the number failed at the end.
     - Display a final message indicating success or failure.

### Prompt 38 ###
I have three RTL files in the `rtl` directory named `bcd_top.sv`, `multi_digit_bcd_add_sub.sv`, and `bcd_adder.sv`. Please modify these modules by adding appropriate and comprehensive SystemVerilog Assertions (SVA) to verify their internal functionality, including clear, descriptive $error messages for debugging. Additionally, provide an implementation for `check_done` in each module. This signal should be used to delay assertion evaluation until the outputs have fully stabilized.

## Common `check_done` description:
- The `check_done` signal is a control flag used to ensure that assertions are only evaluated after the outputs and internal signals have stabilized following a change. This prevents false error detections during transient states. Implement `check_done` such that it is set to a valid state (e.g., 1'b1) after the relevant outputs have settled, and then use it to conditionally enable all assertions within the module.

## Module : bcd_top.sv
### Mutual Exclusivity of Comparison Outputs:
- Assert that exactly one of the outputs (`A_less_B, A_equal_B, A_greater_B`) is asserted at any time.

### Correct Comparison Functionality:
- When A == B, assert that only A_equal_B is asserted (with `A_less_B and A_greater_B` deasserted).
- When A < B, assert that only A_less_B is asserted.
- When A > B, assert that only A_greater_B is asserted.

## Module : multi_digit_bcd_add_sub.sv
### BCD Digit Validity:
- For each digit of the input numbers `A` and `B`, and for the computed result, assert that the value does not exceed 9.

## Module : bcd_adder.sv
### Correction Logic Check:
- If the binary sum exceeds 9, assert that the carry-out (cout) is asserted.
- Assert that the final BCD sum is a valid BCD digit (i.e., it is less than or equal to 9).

### Prompt 39 ###
I have a specification of a `bcd_to_excess_3` module in the docs directory and a testbench that only generates stimulus for that design. Modify the System Verilog testbench `bcd_to_excess_3_tb.sv` in the `verif` directory to verify the results of the design in the `bcd_to_excess_3` module.

Add the following in the generated testbench:

- Add a mechanism to calculate the expected Excess-3 code for valid BCD inputs (0–9).
- Extend the testbench to compare the DUT output with the expected output for each BCD input and verify correctness.
- Display detailed pass/fail messages for each test case.
- If any test case fails, print a mismatch message and exit the simulation with an error.

### Prompt 40 ###
I have a module `search_binary_search_tree` in the `rtl` directory that performs a search for a given `search_key` in a binary search tree (BST) which is given as an array of unsigned integers with a parameterizable size, `ARRAY_SIZE` (greater than 0). The module locates the position of the `search_key` in the array sorted with the constructed BST. The position where the `search_key` is located is based on its **position in the sorted array** (sorted such that the smallest element is at index 0 and the largest element is at index `ARRAY_SIZE`-1). Modify the existing SystemVerilog code to a module named `delete_node_binary_search_tree` to correctly implement the deletion of a node in the given BST input after its searching is completed. The renamed module should be in the same file `rtl/search_binary_search_tree.sv`. The specification of the new module is available in `docs` directory.
The module should handle the following scenarios:

1. When the node to search and delete has both left and right children.
2. When the node to search and delete has only a left child.
3. When the node to search and delete has only the right child.
4. When the node to search and delete has no children.

The module should also ensure that the BST structure is maintained after deletion, and invalid keys and pointers are correctly updated. The interfaces for the modified code must remain similar to that of the existing code with some additional interfaces relevant to the deletion logic. The `search_key`, `complete_found`and `search_invalid` input in the `search_binary_search_tree` module must be replaced with `delete_key`, `complete_deletion` and `delete_invalid` to adapt better to the deletion operation. Additional outputs relevant to the deletion logic must include modified BST consisting of key, left_child, and right_child with the `delete_key` deleted, and invalid keys and pointers correctly updated.

The latency for the total deletion for the modified code depends on the depth of the tree to search the node. In the worst case, the FSM will traverse the depth of the tree. The latency of the search algorithm must be maintained similar to the existing algorithm. 

---

### Task

1. **Review the Existing Code:**
   - Ensure the FSM correctly transitions between states.
   - Verify that the search logic correctly identifies the node to delete.
   - The search logic determines the index of the node to be deleted and information about its left and right child.

2. **Implement the Deletion Logic:**
   - Handle all deletion scenarios in the `S_DELETE` state.
   - Ensure that the BST structure is maintained after deletion.
   - Update the `modified_keys`, `modified_left_child`, and `modified_right_child` arrays correctly.

3. **Handle Invalid Keys and Pointers:**
   - Replace deleted keys and pointers with the appropriate invalid values.
   - Ensure that any references to the deleted node are updated to point to invalid values.

4. **Handle Reset of Outputs and Control Flags:**
   - After the deletion is complete for a given input BST and `delete_key`, ensure the output and control flags are reset to their reset value.

---

### Example Test Cases for DATA_WIDTH = 6
1. **Delete Node with Both Children:**
   - Input: `keys = [10, 5, 15, 3, 7, 12, 20]`, `left_child = [1, 3, 5, 15, 15, 15, 15]`, `right_child = [2, 4, 6, 15, 15, 15, 15]`, `delete_key = 10`
   - Expected Output: `modified_keys = [12, 5, 15, 3, 7, 63, 20]`, `modified_left_child = [1, 3, 15, 15, 15, 15, 15]`, `modified_right_child = [2, 4, 6, 15, 15, 15, 15]`

2. **Delete Node with Only Left Child:**
   - Input: `keys = [10, 5, 15, 3, 63, 12, 20]`, `left_child = [1, 3, 5, 15, 15, 15, 15]`, `right_child = [2, 4, 6, 15, 15, 15, 15]`, `delete_key = 5`
   - Expected Output: `modified_keys = [10, 3, 15, 63, 63, 12, 20]`, `modified_left_child = [1, 15, 5, 15, 15, 15, 15]`, `modified_right_child = [2, 4, 6, 15, 15, 15, 15]`

3. **Delete Node with No Children:**
   - Input: `keys = [10, 5, 15, 3, 7, 12, 20]`, `left_child = [1, 3, 5, 15, 15, 15, 15]`, `right_child = [2, 4, 6, 15, 15, 15, 15]`, `delete_key = 3`
   - Expected Output: `modified_keys = [10, 5, 15, 63, 7, 12, 20]`, `modified_left_child = [1, 15, 5, 15, 15, 15, 15]`, `modified_right_child = [2, 4, 6, 15, 15, 15, 15]`

---

### Deliverables
Ensure that the modified SystemVerilog code correctly implements the deletion logic for all scenarios and maintains the BST structure.

### Prompt 41 ###
Implement a System Verilog testbench named `delete_node_binary_search_tree_tb.sv` in `verif` directory to generate stimuli and a checker that validates output for a `delete_node_binary_search_tree` module that deletes a node for a given `delete_key` in a binary search tree (BST). The task is to provide the required stimuli and add checker logic to validate the correctness of the output from the design for the given stimulus. The specification is located in the `docs` directory for the `delete_node_binary_search_tree` module.

### Testbench Requirements: The testbench should generate stimuli and then implement checker logic.

**Instantiation**

- **Module Instance**: The module `delete_node_binary_search_tree` should be instantiated as `dut`, with all input and output signals connected for testing.

**Input Generation**

- **BST Generation**: 
    - The testbench must generate multiple test cases with possible combinations for `keys`, `left_child`, and `right_child` which abides by the structure of the BST to achieve maximum coverage. 
    - To accurately construct a BST including `keys`, `left_child`, and `right_child`, create a separate submodule `BST_SUB_TREE` in a file named `bst_sub_tree.sv` in the `verif` directory that generates different BSTs based on the input array provided from the testbench. To generate a BST, different input arrays can be provided as input to the new submodule responsible for constructing the BST. Make sure that the keys are not duplicated. The module, key outputs should be the same as the key inputs, but it should generate left and right child pointers to make the array a BST.

- Interface of  `BST_SUB_TREE` : 
          
    - Inputs:
           - `[ARRAY_SIZE*DATA_WIDTH-1:0]  data_in`: A packed array for which the BST is to be constructed. 
           - `start`: Active high signal to initiate the BST generation.
           - `clk` and `reset`: Clock and reset signals. Submodule should be triggered on the posedge of the clk, and reset should be active high asynchronous

    - Outputs:
           - `done`: Active high signal to show that the BST is generated.
           - `[ARRAY_SIZE*DATA_WIDTH-1:0] keys`: A packed array containing the node values of the BST.
           - `[ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] left_child`: A packed array containing the left child pointers for each node in the BST.
           - `[ARRAY_SIZE*($clog2(ARRAY_SIZE)+1)-1:0] right_child`: A packed array containing the right child pointers for each node in the BST.
 

- **Delete Key (`delete_key`) Generation**: 
    - The testbench must generate different random values of `delete_key`  to achieve different scenarios of possible keys to be deleted to achieve maximum coverage
  
- **Control Signal Handling**:

  - The `start` signal should be asserted to trigger the deletion process, and the testbench must wait until the `complete_deletion` signal is asserted (to wait for the deletion to be completed) when the delete is valid or wait until the `delete_invalid` is asserted when the `delete_key` is not found within the tree or when the tree is empty. 
  - The new inputs `keys`, `left_child`,  `right_child`, and `delete_key`  along with the `start` signal must only be asserted after the `complete_deletion` or `delete_invalid` signal for the previous input array is asserted to high. This process must be repeated to cover different sequences of the input array, which means different BSTs will be generated. 

### Output Validation: 

The testbench should be implemented to include the following checker logic:

 - **Validating assertion of Control signals**:  The assertion of the control signals `complete_deletion` and `delete_invalid` should be validated. 
 
 - **Reference Model**: Use a reference model `delete_bst_key` that deletes a given node.  If the `delete_key` node doesn’t exist in the BST, it does nothing. If the node has 0 or 1 child, it directly replaces the node’s key/pointers with its child (or invalidate if leaf). If the node has 2 children, it finds the inorder successor in the right subtree, copies that key up, and then removes or replaces the successor node with its immediate right node if it exists. 


### Latency Validation:

- The testbench should verify the latency until either the `complete_deletion` signal or the `delete_invalid` signal is asserted. The number of clock cycles between the `start` and `complete_deletion` or `delete_invalid` signals should be checked against the expected latency. Due to the complex nature of the `delete_node_binary_search_tree` design, it is difficult to calculate latency for different input scenarios. The testbench must, therefore, restrict the expected latency calculation to only some simple and worst-case scenarios in skewed trees and latency for searching an empty tree, as described in the RTL specification.
-----

### Simulation Control
- Execute the test cases using procedural blocks, monitoring the process with appropriate delays and synchronization methods.
- Use `$display` for logging results and `$error` for mismatches to facilitate debugging.

### Test Procedure

1. Initialization and Reset: An initial reset to the dut before starting the test sequence should be applied.
2. Generate the input stimuli for different cases as mentioned in **BST Generation** and **Delete Key Generation**
3. Provide the set of test cases as inputs to the design.
4. Use the reference deletion implementation on the provided `delete_key` and the **BST** to find out if the `delete_key` is present and to generate the modified BST with the `delete_key` replaced or deleted according to the different deletion scenarios. 
5. Validate the output for the generated stimuli as explained in Output Validation.
6. Validate the latency calculated against the expected latency only for the above-mentioned scenarios. 


## Deliverables
Provide a **complete SystemVerilog testbench** that effectively generates the test cases and includes checker logic that verifies the `delete_node_binary_search_tree` module's functionality to ensure it correctly performs the deletion of the given input key.

### Prompt 42 ###
You are provided with three SystemVerilog modules in the rtl/ directory. You need to integrate these three modules into a top-level module called `bst_operations`,  which should support the operations described further in the specification in the docs/bst_operations.md. 

1. `search_binary_search_tree` — performs key search in a binary search tree (BST)  
2. `delete_node_binary_search_tree` — deletes a node with the given key from the BST  
3. `binary_search_tree_sort_construct` — performs both BST construction and  sorting  via in-order traversal 

---

### Required Modifications

1. The module `binary_search_tree_sort_construct` currently combines **BST construction** and **sorting** into one module.  
   Create **two separate functional modules** using `binary_search_tree_sort_construct` as the reference to be able to provide a BST input to the `search_binary_search_tree` and `delete_node_binary_search_tree` modules and optionally sort after the operations. While creating modules for separating the operations, add necessary input/output ports to the new submodules to propagate data between modules. (Only top module consistency needs to be retained as per the spec).
   - `bst_tree_construct`: builds the BST
   - `binary_search_tree_sort`: performs in-order traversal to output sorted keys

2. You must **connect these new modules** inside `bst_operations` along with  `search_binary_search_tree` and  `delete_node_binary_search_tree`

3. No additional latency other than that for handling completion flags must be added in between operations. 

---

### Key Handling Consistency

There is an inconsistency in how **invalid keys** are handled across the modules. The original `binary_search_tree_sort_construct`  module uses `0` to indicate **invalid keys**. In contrast, both `search_binary_search_tree` and `delete_node_binary_search_tree` use **all 1s** (`{DATA_WIDTH{1'b1}}`) to represent invalid key values

- Ensure that all modules within `bst_operations` use **consistent invalid key and pointer representations**  
- Recommended:
  - `INVALID Key = {DATA_WIDTH{1'b1}}`
  - `INVALID Pointer = {($clog2(ARRAY_SIZE)+1){1'b1}}`

---

###  Top-Level Interface

The `bst_operations` module must:
- Accept input data as a flattened array (`data_in`)
- Accept a key (`operation_key`) and operation selector (`operation`)
- Output the updated BST structure and, optionally, sorted keys
- Output flags to indicate operation completion and validity
---

### Prompt 43 ###
Design a `binary_to_gray` module in SystemVerilog. Refer to the specification in `docs/specs.md`, which details a parameterized `WIDTH` for an N-bit binary-to-Gray code converter. The module should take an N-bit binary input and generate an N-bit Gray code output using a purely combinational approach. The design must follow the standard Gray code conversion rule where:

  - The most significant bit (`MSB`) remains unchanged.
  - Each subsequent bit is computed as the `XOR` of the current and previous binary bits.

**Requirements:**
  - Implement the next-state computation using a bitwise `XOR` operation.
  - Ensure a fully combinational design with no `clock` or `reset`.
  - The module should be parameterized to support different bit widths.

### Prompt 44 ###
I have a SystemVerilog testbench named `tb_branch_control_unit.sv` in the verification directory that simulates a branch control unit design. The design specification is provided in the `docs/specs.md` directory. The testbench drives 4‑bit input vectors (`i_3`, `i_2`, `i_1`, `i_0`) along with corresponding 4‑bit test control signals (`test_3`, `test_2`, `test_1`, `test_0`) to stimulate various operational modes of the branch control unit, and it then monitors the outputs (`o_3`, `o_2`, `o_1`, `o_0`) for correct branch decision behavior.

Modify the existing testbench `tb_branch_control_unit.sv` by

## Adding Output Validation Mechanism

**Input Decoding and Expected Output Calculation**

The testbench uses a nested case and casex structure in a dedicated checker task (`check_output`) to decode the 4‑bit input vector and further interpret the test control bits.

For each combination of inputs and test signals, an expected output vector is computed. Don’t‑care conditions (indicated by ‘x’ in the test vector) allow the testbench to match a range of acceptable behaviors while still enforcing correct branch decision outcomes.

## Adding Checker Functionality: Branch Output Verification

**Output Comparison**:
On every test cycle, the checker task should compare the actual outputs with the computed expected outputs.

**Error Reporting**:
If any output bit mismatches the expected value, then testbench should report an error. The error message should include the current simulation time, the values of the input vector, the test control bits, and both the expected and actual outputs. This detailed reporting assists in pinpointing exactly which branch condition failed.

**Pass Confirmation**:
When the outputs match the expected branch decision, the testbench should log a pass message with the relevant input and test control conditions.

### Prompt 45 ###
Design a `custom_byte_enable_ram` module in SystemVerilog. Refer to the specification provided in `docs/specs.md` and ensure you understand its content. The specification details parameterization (XLEN=32, LINES=8192), dual-port RAM operation with independent address, enable ,  byte-enable, data signals, synchronous input registration, and initial RAM reset. It also specifies conflict resolution rules when both ports access the same address—updating each byte according to its respective byte-enable signal with port A taking precedence over port B. Generate complete RTL code that implements the `custom_byte_enable_ram` module with proper handling of simultaneous writes and correct data output for both ports.

### Prompt 46 ###
I have a specification of a custom_byte_enable_ram module in the docs directory. Write a SystemVerilog testbench `tb_custom_byte_enable_ram.sv` in the verif directory to apply stimulus and achieve maximum coverage for the `custom_byte_enable_ram` module.

Include the following in the generated testbench:

**Module Instance**:
Instantiate the `custom_byte_enable_ram` module as `uut`, ensuring that all input and output ports (covering both port A and port B) are properly connected.

**Clock Generation**:
Implement a clock generator with a 10ns period.

**Stimulus Scenarios**:
In the testbench’s initial block, apply a series of stimulus sequences with delays and $display statements (without using tasks) that cover the following 13 test cases:

- **Test 1**: Full write via port A at address 0 followed by a read-back.

- **Test 2**: Partial write via port B at address 1 followed by a read-back.

- **Test 3**: Dual-port simultaneous write at address 2 with port A writing lower bytes and port B writing upper bytes, then reading back from both ports.

- **Test 4**: Sequential partial writes on port A at address 3, with an initial write using one byte-enable pattern and a subsequent write using a complementary pattern, then reading back.

- **Test 5**: Independent full writes on port A (at address 5) and port B (at address 6) with subsequent reads.

- **Test 6**: Dual-port full write at the same address (address 4) by both ports, then reading the final value (noting that port A’s bytes have priority).

- **Test 7**: Dual-port overlapping partial write at address 7 with interleaved byte enables, then reading back.

- **Test 8**: Dual-port write at address 9 where port A has no active byte enables and port B performs a full write, followed by a read-back.

- **Test 9**: Sequential writes at address 10 with an initial full write via port A and a subsequent partial update via port B, then reading back.

- **Test 10**: A no-update scenario at address 11 where an initial full write is not altered by a cycle with both ports enabled but with zero byte enables, then reading back.

- **Test 11**: Write at address 25 with only port B enabled, then reading back from both ports.

- **Test 12**: Read at addresses 100 and 101 with both ports disabled to verify unchanged memory.

- **Test 13**: Separate partial writes at different addresses (address 12 via port A and address 13 via port B) with subsequent reads.

The testbench should structure these stimulus sequences directly within an initial block using appropriate delays and $display calls for traceability and debugging. Do not include checker logic or internal state validation—this testbench is solely for generating stimulus.

### Prompt 47 ###
I have a SystemVerilog testbench named `tb_custom_byte_enable_ram.sv` in the verification directory that simulates a custom byte enable RAM design. The design specification is provided in the `docs/specs.md` directory. This testbench instantiates the `custom_byte_enable_ram` module and drives two independent ports (Port A and Port B) that support byte-level write enables and dual-port operations.

## Testbench Operation
## Stimulus Generation:
The testbench applies a series of stimuli to the RAM by driving address, enable, byte enable, and data input signals for both ports. It supports various write operations including full writes, partial writes, overlapping writes, and sequential updates. A continuously toggling clock ensures that all operations are synchronous.


Modify the existing testbench `tb_custom_byte_enable_ram.sv` by
## Adding Checker Tasks:
For each test case, there is a dedicated checker task that validates the output of the RAM against an expected value:

- **Test 1**: Port A writes 32'hDEADBEEF to address 0 and reads it back. The checker task verifies that `data_out_a` matches 32'hDEADBEEF.

- **Test 2**: Port B performs a partial write at address 1 expecting an output of 32'hCAFE0000.

- **Test 3**: Both ports write to address 2 with conflicting byte enables, and both outputs are expected to be 32'hABCD1234.

- **Test 4**: A sequential write on Port A at address 3 is verified for a correct update.

- **Test 5**: Full writes on two different addresses (Port A at address 5 and Port B at address 6) verify that `data_out_a` equals 32'hAAAAAAAA and `data_out_b` equals 32'h55555555.

- **Test 6**: A dual port full write at address 4 must yield 32'h11111111 on Port A.

- **Test 7**: Overlapping partial writes at address 7 should result in 32'hBBAABBAA.

- **Test 8**: When Port A’s byte enable is 0 at address 9, the checker confirms that the output remains at 32'h33333333 as written by Port B.

- **Test 9**: Sequential writes at address 10 are validated against an expected 32'hAAAA5555.

- **Test 10**: A no-update condition at address 11 confirms that the output remains at 32'h12345678.

- **Test 11**: Only Port B is enabled at address 25, and both outputs must reflect 32'hFACECAFE.

- **Test 12**: With both ports disabled at different addresses, the outputs are checked to remain unchanged at 32'hFACECAFE.

- **Test 13**: A scenario with partial updates on different addresses (Port A at address 12 and Port B at address 13) is verified with expected outputs of 32'h0000CC00 and 32'h00330000, respectively.

## Adding Error Reporting and Pass Confirmation
For every test cycle, the corresponding checker task should compare the actual output with the computed expected value. If any mismatch occurs, the testbench should report an error that includes detailed simulation time and value discrepancies. When the outputs match the expected values, the testbench should log a pass message indicating the correct behavior under that test condition.

### Prompt 48 ###
I have a `custom_byte_enable_ram.sv` module available in the rtl directory. Please modify the module by adding SystemVerilog Assertions (SVA) to check its internal functionality comprehensively. The assertions should verify the following conditions:

**1. No Write Stability on Port A (no_write_stability_A)**:
Verify that if port A was not enabled in the previous cycle (i.e. `en_a` deasserted), the output data (`data_out_a`) remains unchanged from the previous value stored in the RAM at the address provided by `addr_a`.

**2. No Write Stability on Port B (no_write_stability_B)**:
Check that if port B was not enabled in the previous cycle (i.e. `en_b` deasserted), then `data_out_b` remains equal to the previous content of the RAM at `addr_b`.

**3. Same Address Read Consistency (same_addr_read)**:
Ensure that if both ports were accessing the same memory location in the previous cycle with neither write enabled, the read outputs for both ports are identical—that is, `data_out_a` equals `data_out_b`.

**4. Output Consistency on Port A (output_consistency_A)**:
After a fixed delay (30 cycles), confirm that `data_out_a` exactly reflects the value stored in the RAM at the registered address (`addr_a_reg`).

**5. Output Consistency on Port B (output_consistency_B)**:
After a 30-cycle delay, verify that `data_out_b` equals the RAM contents at `addr_b_reg`.

**6. Simultaneous Write Priority for Port A – Lower Byte (simul_write_A_byte0_update)**:
When both ports are enabled and accessing the same address, check that if port A’s byte-enable for the lower byte (bit 0) is asserted, then after 15 cycles the RAM’s lower byte (bits [7:0]) is updated to match `data_in_a`’s lower byte. This confirms the priority of port A in simultaneous write scenarios.

**7. Simultaneous Write Priority for Port A – Second Byte (simul_write_A_byte1_update)**:
If port A’s byte-enable for byte 1 (bits [15:8]) is asserted, then after 15 cycles the check corresponding RAM byte should equal `data_in_a`’s bits [15:8].

**8. Single-Port Write Behavior for Port A – Lower Byte (single_write_A_byte0_update)**:
When only port A is performing a write (i.e. its address differs from port B’s or port B is not enabled), verify that if the byte-enable for the lower byte is active, after 15 cycles the RAM’s lower byte is updated according to `data_in_a`.

**9. Single-Port Write Behavior for Port A – Second Byte (single_write_A_byte1_update)**:
Similarly, in a single-port write condition, if port A’s byte-enable for the second byte (bits [15:8]) is asserted, then after 15 cycles the corresponding RAM byte should match `data_in_a`’s bits [15:8].

If any of these conditions are violated during simulation, an appropriate error message should be displayed.

### Prompt 49 ###
Develop a Verilog-based **cache controller** for a **direct-mapped cache** that consists of **32 entries**, each storing a **32-bit word**. The controller must efficiently handle **read and write operations** issued by a **CPU**, interact with a **main memory module**, and ensure **coherence** between the cache and memory.

## Key Functional Requirements

### 1. Tag Comparison & Hit/Miss Detection
- The cache must store **5-bit tags** to identify unique memory blocks.
- The controller should check if the requested address matches a valid tag.
- A **hit** occurs when a valid tag is found in the cache; otherwise, it results in a **miss**.

### 2. Read Operation
- If a **cache hit** occurs, data should be provided to the CPU immediately.
- If a **cache miss** occurs, the controller must fetch the data from **main memory** and store it in the cache before responding to the CPU.

### 3. Write Operation (Write-Through Policy)
- The cache follows a **write-through** policy, meaning every write operation updates both the cache (if it contains the requested address) and the main memory simultaneously.
- Even on a cache miss, the data must be written to **main memory**.

### 4. Memory Interface
- The controller should interact with main memory using the **mem_address, mem_write, and mem_read_data** signals.
- Memory accesses must ensure proper timing by considering the **mem_ready** signal before fetching new data.

### 5. Cache Validity & Initialization
- The controller must initialize all cache entries as **invalid** upon reset.
- Each cache line must have a corresponding **valid bit** to indicate if it contains valid data.

### Prompt 50 ###
The `caesar_cipher` module is designed to shift each alphabetic character by a specified key using the Caesar cipher encryption technique. The module correctly identifies uppercase and lowercase letters, applying the appropriate shift. However, testing revealed that the module fails to generate the correct cipher output for some inputs, indicating an issue in the shifting logic and compromising the expected encryption functionality.

## Errors Observed During Simulation

- `'hello'` with key 3: expected `khoor`, got `QNUUX`.
- `'WORLD'` with key 4: expected `ASVPH`, got `WORLD`.
- `'Caesar'` with key 5: expected `Hfjxfw`, got `CLPDLC`

The module and its testbench are available for further debugging in the current working directory.

### Prompt 51 ###
I have a `caesar_cipher` module available in the `rtl` directory, and its specification is in the `docs` directory. Kindly modify the module by adding SystemVerilog assertions. The assertions should ensure that the Caesar cipher module correctly encrypts and decrypts ASCII characters within expected ranges, handles shifts correctly, and provides valid outputs for both alphabetic and non-alphabetic cases.

## **Assertion Details**  
1. **Shift Key Range Check**:  
   - Confirm that the `shift_val` does not exceed 5 bits (i.e., must be `<= 31`).  
   - If any invalid shift exceeds this range, it should trigger an **error message**.

2. **Alphabetic Character Handling**:  
   - **Lowercase**: Ensure that when encrypting lowercase characters (`a` to `z`), the output remains within `a–z`.  
   - **Uppercase**: Ensure that when encrypting uppercase characters (`A` to `Z`), the output remains within `A–Z`.  
   - **Decryption**: Validate that encrypted alphabetic characters correctly wrap back into the same case range.

3. **Non-Alphabetic Character Handling**:  
   - In encryption mode, non-alphabetic ASCII characters should have their ASCII value incremented by the shift.  
   - In decryption mode, these characters should have their ASCII value decremented by the shift.  
   - If these operations push the character code outside of printable ASCII (`0x00–0x7F`), an **error message** should be triggered.

4. **Zero Shift Check**:  
   - If `shift_val` is zero, encryption or decryption should leave the input unchanged.  
   - Assert that if `shift_val == 0`, `output_char` remains identical to `input_char`.

## **Expected Behavior**  
- All assertions must generate an **error message** if their conditions are violated.  
- Any attempt to encrypt or decrypt characters outside the valid ASCII range (`0x00–0x7F`) should cause an assertion to fail with an **error**.
- Alphabetic characters should remain in their respective alphabetic range after encryption or decryption.

### Prompt 52 ###
Design a `pseudoRandGenerator_ca` module in SystemVerilog. Refer to the specification in `docs/specs.md` which details a 16-bit state and a 2-bit rule selector for a cellular automata pseudorandom generator supporting Rule 30 and Rule 110. Generate complete RTL code that implements next-state computation using wrap-around indexing and synchronous state updates with reset initialization.

### Prompt 53 ###
Design a `cic_decimator` module in SystemVerilog. Refer to the specification provided in `docs/specs.md` and ensure you understand its content. The specification details parameterization (WIDTH=16, RMAX=2, M=1, N=2, REG_WIDTH defined as WIDTH + $clog2((RMAX * M)**N)), a cascaded integrator section, a comb section with delay registers, and a decimation control mechanism using a cycle counter. Generate complete RTL code that implements the CIC decimation filter with proper valid-ready handshaking for input and output interfaces.

### Prompt 54 ###
I have a CIC decimator module `cic_decimator.sv" available in the rtl directory. Please modify the module by adding SystemVerilog Assertions (SVA) to check its internal functionality comprehensively. The assertions should verify the following conditions:

**Reset Cycle Register**:
Ensure that when the reset signal (rst) is asserted ACTIVE HIGH, the cycle counter (`cycle_reg`) is reset to 0.

**Reset Integrator Register 0**:
Verify that the first integrator register (`int_reg[0]`) is reset to 0 when rst is asserted ACTIVE HIGH.

**Reset Integrator Register 1**:
Verify that the second integrator register (`int_reg[1]`) is reset to 0 when rst is asserted ACTIVE HIGH.

**Reset Comb Register 0**:
Ensure that the first comb register (`comb_reg[0]`) is reset to 0 upon `rst` is asserted ACTIVE HIGH .

**Reset Comb Register 1**:
Ensure that the second comb register (`comb_reg[1]`) is reset to 0 upon `rst` is asserted ACTIVE HIGH.

**Output Valid Signal Constraint**:
Confirm that the output valid signal (`output_tvalid`) is asserted ACTIVE HIGHonly when the cycle counter (`cycle_reg`) is 0.

**Input Ready Signal Relation**:
Verify that the input ready signal (`input_tready`) is correctly driven by the condition:
`input_tready` equals (`output_tready` OR (`cycle_reg ≠ 0`)).

**Cycle Counter Behavior**:
When a valid input transfer occurs (i.e., when both `input_tvalid` and `input_tready` are true), check that the cycle counter increments by 1 if its previous value is less than both (`RMAX - 1`) and (`rate - 1`); otherwise, it should reset to 0.

**Integrator Stage 0 Update**:
On the cycle following a valid input transfer, ensure that the first integrator register (`int_reg[0]`) updates to the sum of its previous value and the previous value of `input_tdata`.

**Integrator Stage 1 Update**:
On a valid input transfer, verify that the second integrator register (`int_reg[1]`) updates to the sum of its previous value and the previous value of the first integrator (`int_reg[0]`).

**Comb Stage 0 Update**:
When a valid output transfer occurs (i.e., when both `output_tvalid` and `output_tready` are true), verify that the first comb register (`comb_reg[0]`) updates to the difference between the previous value of the last integrator (`int_reg[N-1]`) and the delayed value (e.g., `delay_reg[0]`) within comb stage 0.

**Comb Stage 1 Update**:
Similarly, when a valid output transfer occurs, check that the second comb register (`comb_reg[1]`) updates to the difference between the previous value of the first comb register (`comb_reg[0]`) and the delayed value (e.g., `delay_reg[0]`) within comb stage 1.

If any of these conditions are violated during simulation, an appropriate error message should be displayed.

### Prompt 55 ###
Design a `cipher` module in SystemVerilog based on the specification provided in `docs/specs.md`. Ensure you fully understand its structure, including its Feistel-based encryption mechanism with an 8-round iterative transformation. The design should partition the 32-bit `data_in` into two 16-bit halves (`left` and `right`), apply a round function (`f_function`) to process the right half with a dynamically generated subkey, and XOR the result with the left half before swapping them. Implement a state machine with three states (`IDLE`, `ROUND`, `FINISH`) to control encryption flow, handling input data when `start` is asserted and signaling completion via the `done` output. Use a key schedule to generate unique round keys via bitwise rotation and XOR with the round index. Ensure synchronous operation with `clk` and asynchronous reset via `rst_n`. The final encrypted output should be correctly swapped and assigned to `data_out` at the end of all rounds. Implement proper reset handling, FSM state transitions, and ensure the module is synthesizable and optimized for hardware deployment. Refer to `docs/specs.md` for detailed implementation requirements, state transitions, and key schedule handling.

### Prompt 56 ###
I have a testbench that only generates stimulus for a `coffee_machine` design. The design specification of the `coffee_machine` module used is provided in `docs` directory. Modify the System Verilog testbench `coffee_machine_testbench.sv` in the `verif` directory to add checker logic to verify the results of the design in `coffee_machine` module.

Add the following in the given testbench:
- Modify the existing `execute_operation` task to check the outputs and latency.
- Irrespective of the input stimulus ensure that the simulation doesnt get stuck in any infinite loop and all the different input stimulus are tested.

### Prompt 57 ###
Design a `continuous_adder` module in SystemVerilog within a file `continuous_adder.sv` at the location: `rtl/continuous_adder.sv`. Refer to the specification provided in `docs/continuous_adder_specification.md` and ensure you understand its content. The specification details the functionality of a configurable continuous accumulation adder with the following parameters:

- **DATA_WIDTH**: Configurable width of the input data.
- **ENABLE_THRESHOLD**: Enables or disables threshold-based accumulation.
- **THRESHOLD**: Defines the value at which the sum is considered complete.
- **REGISTER_OUTPUT**: Determines whether the output is registered.

The module processes incoming data by continuously accumulating values when `valid_in` and `accumulate_enable` signals are asserted. The accumulated sum is stored internally and can be flushed using the `flush` signal. If `ENABLE_THRESHOLD` is enabled and the accumulated sum reaches the specified `THRESHOLD`, the sum is output and the `sum_valid` signal is asserted.

### Functional Behavior

1. **Accumulation Logic:**  
   - Data is continuously added to an internal sum register when `valid_in` and `accumulate_enable` are high.
   - If `flush` is asserted, the sum register resets to zero.

2. **Threshold Handling:**  
   - If `ENABLE_THRESHOLD` is set, the module checks whether `sum_reg` has reached `THRESHOLD`.
   - When the threshold is met, the sum is output and `sum_valid` is asserted.

3. **Registering Output (Optional):**  
   - If `REGISTER_OUTPUT` is enabled, the `sum_out` and `sum_valid` outputs are updated synchronously with `clk` and `rst_n`.
   - If `REGISTER_OUTPUT` is disabled, `sum_out` and `sum_valid` are updated combinationally.

Generate the complete RTL code for the `continuous_adder`, ensuring optimized performance and compliance with the given specification.

### Prompt 58 ###
I have a `continuous_adder` module available in the `rtl` directory, and its specification is in the `docs` directory. Kindly modify the module by adding SystemVerilog assertions. The assertions should ensure that the module correctly implements continuous accumulation and valid flush behavior.

## **Assertion Details**  
The assertions should verify the following conditions:  
- **Flush Behavior:** Ensure that the `flush` signal correctly resets the accumulator register.  
- **Accumulate Behavior:** Verify that the sum is updated accurately on every valid input cycle, only when `accumulate_enable` is high.  
- **Threshold Detection (if enabled):** Confirm that the `threshold_reached` logic correctly detects when the current sum exceeds the threshold parameter (if `ENABLE_THRESHOLD` is set).  
- **Output Registration (if enabled):** Check that the module's outputs are registered (i.e., pass through flip-flops at the output stage) when `REGISTER_OUTPUT` is enabled.

## **Expected Behavior**  
If any of the assertions fail, they should generate an **error message** to highlight the incorrect behavior in the continuous accumulator logic.

### Prompt 59 ###
Develop assertion properties to verify the liveness properties of the FSM in the `rtl/blake2s_core` module. These assertions must ensure that each FSM state is reachable from its expected previous state under valid conditions.

Target the FSM states held by the `blake2s_ctrl_reg` signal: `{CTRL_IDLE, CTRL_INIT_ROUND, CTRL_G_ROW, CTRL_G_DIAGONAL, CTRL_COMP_DONE, CTRL_FINISH}`.

The following requirements must be addressed:
- The properties must be placed in a separate module named `blake2s_core_state_liveness_check`, which instantiates `blake2s_core` as the Device Under Test (DUT).  
- The properties must directly reference internal DUT signals for verification.

### Prompt 60 ###
Develop assertion properties to verify the sanity of the `blake2s_core` module. These assertions must ensure that the module behaves as expected under its intended usage.

The assertion properties must cover the following behaviors:

1. The module becomes ready after reset.  
2. The `CTRL_IDLE` state indicates that the module is ready.  
3. The `init` operation takes two cycles to complete, after which the module is ready again.  

Since we are verifying the expected behavior under the intended usage of the design, use helper assumptions alongside the assertion properties to constrain and validate correct usage patterns:

1. The `init` operation must not be triggered alongside `update` or `finish`.  
2. An operation is considered ongoing once the module becomes ready and one of `init`, `update`, or `finish` is activated. The module must remain not ready until the operation completes. No new operation may be started while the module is not ready.

The following implementation requirements must be met:

- The assertion properties must be placed in a separate module named `blake2s_core_reset_and_ready_sanity_check`, which instantiates `blake2s_core` as the Device Under Test (DUT).  
- The properties must reference internal DUT signals directly for verification.

### Prompt 61 ###
Develop assertion properties to verify the sanity of the `blake2s_core` module. These assertions must ensure that the module behaves as expected under its intended usage.

The assertion properties must cover the following behaviors:

1. The module must not be set to ready immediately after an `update` operation has started.  
2. The module must be ready 24 cycles after an `update` operation has started.  
3. The module must not be set to ready immediately after a `finish` operation has started.  
4. The module must be ready 24 cycles after a `finish` operation has started.

Since we are verifying the expected behavior under the intended usage of the design, use helper assumptions alongside the assertion properties to constrain and validate correct usage patterns:

1. An operation is considered ongoing once the module becomes ready and one of `init`, `update`, or `finish` is activated. The module must remain not ready until the operation completes. No new operation may be started while the module is not ready.

The following implementation requirements must be met:

- The assertion properties must be placed in a separate module named `blake2s_core_finish_and_update_sanity_check`, which instantiates `blake2s_core` as the Device Under Test (DUT).  
- The properties must reference internal DUT signals directly for verification.

### Prompt 62 ###
Develop assertion properties to verify the addresses of the `blake2s` module that are **not** readable.

1. **As a first step**, for the predefined addresses:  
   `{ ADDR_NAME0, ADDR_NAME1, ADDR_VERSION, ADDR_CTRL, ADDR_STATUS, ADDR_BLOCKLEN, ADDR_BLOCK0, ADDR_BLOCK15, ADDR_DIGEST0, ADDR_DIGEST7 }`,  
   identify which addresses are not readable.

2. **As a second step**, for each **non-readable** address, write an assertion property to verify that:
   - the address is indeed not readable, and  
   - the value returned is always the default value for `read_data`.

   If multiple addresses represent a contiguous range of the same type (e.g., `ADDR_BLOCK0` to `ADDR_BLOCK15`), cover them using a single property if feasible.

Implementation requirements:
- The assertion properties must be placed in a separate module named `blake2s_not_readable_addresses_check`, which instantiates the `blake2s` module as the Device Under Test (DUT).  
- The properties must reference internal DUT signals directly for verification purposes.

### Prompt 63 ###
Develop a SystemVerilog-based `csr_apb_interface` that supports read and write access to internal control, data, and interrupt registers. The module must handle APB transactions using standard protocol signals (`pselx`, `penable`, `pwrite`) and expose register data through a 32-bit bus. It should also support interrupt status flag handling, write protection for specific registers, and expose the current FSM state via a debug output.

## **Key Functional Requirements**

### 1. APB Protocol Compliance
The module must support the AMBA APB protocol, managing read and write operations through the standard `pselx`, `penable`, and `pwrite` signals.  
All transactions must follow the three-phase handshake:  
**IDLE → SETUP → ACCESS**

### 2. Register Map and Access
The controller provides access to four key registers via the APB interface:

- DATA_REG (0x10):
  Holds `data1` (bits 19:10), `data2` (bits 9:0), and 12 bits of reserved data (31:20).

- CONTROL_REG (0x14): 
  Includes `enable`, `mode`, and 30 bits of reserved control fields.

- INTERRUPT_REG (0x18): 
  Stores interrupt enable bits: `overflow_ie`, `sign_ie`, `parity_ie`, and `zero_ie`, along with 28 reserved bits.

- ISR_REG (0x1C): 
  Holds interrupt status flags (`*_is`). These flags can be cleared by writing `1` to the corresponding enable bits in the `INTERRUPT_REG`.

### 3. FSM State Management
The design uses a finite-state machine with four states:

- IDLE:  
  Waits for `pselx` to be asserted.

- SETUP:
  Accepts and processes transaction requests, transitions to `READ_STATE` or `WRITE_STATE`.

- READ_STATE: 
  Outputs register data on `prdata` based on the address. Transitions back to `IDLE`.

- WRITE_STATE: 
  Writes data into registers from `pwdata`, with a protection mechanism for `ISR_REG` (writes are blocked). Transitions back to `IDLE`.

### 4. Write Protection Mechanism
The `ISR_REG` is write-protected. Any attempt to write to it should assert `pslverr`.  
Writes to `INTERRUPT_REG` can clear corresponding ISR bits by writing `1` to the enable flags.

### Prompt 64 ###
I have a `csr_apb_interface` module in the `rtl` directory. Kindly modify the module by adding SystemVerilog assertions to ensure it conforms to the APB protocol and internal control register expectations.


## Assertion Details

The assertions should verify the following conditions:

### 1. Reset Behavior

Ensure that on the assertion of the active-low reset (`presetn == 0`), the outputs `pready`, `prdata`, `pslverr`, and internal state variables (e.g., ISR status flags) are reset to their default values.

**Expected Failure Message:**  
`Assertion Failed: Reset did not clear outputs or status flags.`

### 2. APB Protocol Compliance

Ensure that the APB protocol is respected:
- `penable` must not be high without `pselx` being high.
- On any transaction, `pready` must be high before transitioning out of READ or WRITE state.

**Expected Failure Message:**  
`Assertion Failed: PENABLE high without PSELX.`

### 3. Single FSM State Validity

Ensure that `present_state` is always one-hot or valid among the defined four FSM states: `IDLE`, `SETUP`, `READ_STATE`, and `WRITE_STATE`.

**Expected Failure Message:**  
`Assertion Failed: FSM in invalid or multiple simultaneous states.`

### 4. Write Protection of ISR Register

Ensure that any write attempt to the `ISR_REG` (Interrupt Status Register), which is read-only, sets `pslverr`.

**Expected Failure Message:**  
`Assertion Failed: Write to ISR_REG did NOT raise PSLVERR.`

### 5. Read Data Validity

Ensure that during a valid `READ_STATE`, the `prdata` output is not unknown (i.e., not X or Z).

**Expected Failure Message:**  
`Assertion Failed: Read data is unknown (X or Z) during READ_STATE.`

### 6. Correct Register Readback

During reads, ensure the `prdata` value matches what’s expected based on the register mapping:
- `DATA_REG = {data_reserved, data1, data2}`
- `CONTROL_REG = {control_reserved, enable, mode}`
- `INTERRUPT_REG = {interrupt_reserved, overflow_ie, sign_ie, parity_ie, zero_ie}`
- `ISR_REG = {28'b0, overflow_is, sign_is, parity_is, zero_is}`

**Expected Failure Message:**  
`Assertion Failed: prdata does not match expected register contents.`

### 7. Reserved Bits Stability

Ensure that reserved bits (e.g., upper bits of `CONTROL_REG` or `INTERRUPT_REG`) retain their previous values if not explicitly written to.

**Expected Failure Message:**  
`Assertion Failed: Reserved bits overwritten unexpectedly.`

### 8. ISR Reset Behavior

Upon reset, the ISR flags (`overflow_is`, `sign_is`, `parity_is`, `zero_is`) must be cleared.

**Expected Failure Message:**  
`Assertion Failed: ISR flags not cleared on reset.`

---

##  Expected Behavior on Assertion Failure

If any of the above assertions fail, the simulation should generate a **clear and descriptive error message**, with enough context to trace the violation quickly during debugging.

### Prompt 65 ###
The given `fifo_buffer` module implements a parameterizable FIFO for managing request data and error signals, where the FIFO depth is set to NUM_OF_REQS+1. It buffers incoming data (addresses, read data, and error flags) and selects between freshly arrived input and stored FIFO data to produce aligned or unaligned outputs based on the instruction alignment bits. The module also computes the next instruction address by conditionally incrementing the stored address by two or four bytes depending on whether the instruction is compressed (as indicated by specific bit patterns) and updates its registers either synchronously or asynchronously based on the ResetAll parameter. Data is efficiently shifted through the FIFO using combinational logic that determines the lowest free entry, manages push/pop operations, and generates busy signals for backpressure control.


The various test cases with  signal responses for Buggy and Bug Free RTL codes are as tabulated as follows:

**Test 1 – Clear FIFO (Aligned PC)**
| Time  | clear | in_valid | in_addr  | in_rdata | in_err | Signal        | Buggy Value | Bug Free Value |
|-------|-------|----------|----------|----------|--------|---------------|-------------|----------------|
| 30000 | 1     | 0        | 00000000 | 00000000 | 0      | out_err_plus2 | 1           | 0              |
| 35000 | 1     | 0        | 00000000 | 00000000 | 0      | out_err_plus2 | 1           | 0              |
| 40000 | 0     | 0        | 00000000 | 00000000 | 0      | out_err_plus2 | 1           | 0              |

**Test 2 – Single Instruction Fetch (Aligned)**
| Time  | clear | in_valid | in_addr  | in_rdata | in_err | Signal        | Buggy Value | Bug Free Value |
|-------|-------|----------|----------|----------|--------|---------------|-------------|----------------|
| 50000 | 0     | 1        | 00000000 | 8c218363 | 0      | out_err_plus2 | 1           | 0              |
| 60000 | 0     | 0        | 00000000 | 8c218363 | 0      | out_valid     | 0           | 1              |
| 60000 | 0     | 0        | 00000000 | 8c218363 | 0      | out_err_plus2 | 1           | 0              |

**Test 3 – FIFO Depth Test**
| Time   | clear | in_valid | in_addr  | in_rdata | in_err | Signal        | Buggy Value | Bug Free Value |
|--------|-------|----------|----------|----------|--------|---------------|-------------|----------------|
| 90000  | 0     | 1        | 00000000 | 6c2183e3 | 0      | out_addr      | 00000000    | 00000004       |
| 90000  | 0     | 1        | 00000000 | 6c2183e3 | 0      | out_err_plus2 | 1           | 0              |
| 100000 | 0     | 1        | 00000000 | 926cf16f | 0      | out_addr      | 00000000    | 00000004       |
| 100000 | 0     | 1        | 00000000 | 926cf16f | 0      | out_err_plus2 | 1           | 0              |
| 105000 | 0     | 1        | 00000000 | 926cf16f | 0      | out_addr      | 00000000    | 00000004       |
| 105000 | 0     | 1        | 00000000 | 926cf16f | 0      | out_err_plus2 | 3           | 1              |
| 110000 | 0     | 0        | 00000000 | 926cf16f | 0      | out_addr      | 00000000    | 00000004       |
| 110000 | 0     | 0        | 00000000 | 926cf16f | 0      | out_err_plus2 | 3           | 1              |
| 125000 | 0     | 0        | 00000000 | 926cf16f | 0      | out_addr      | 00000004    | 00000008       |
| 125000 | 0     | 0        | 00000000 | 926cf16f | 0      | out_err_plus2 | 1           | 0              |
| 135000 | 0     | 0        | 00000000 | 926cf16f | 0      | out_addr      | 00000008    | 0000000c       |
| 135000 | 0     | 0        | 00000000 | 926cf16f | 0      | out_err_plus2 | 1           | 0              |

**Test 4 – Unaligned Instruction Fetch**
| Time   | clear | in_valid | in_addr  | in_rdata | in_err | Signal        | Buggy Value | Bug Free Value |
|--------|-------|----------|----------|----------|--------|---------------|-------------|----------------|
| 160000 | 1     | 0        | 00000002 | 926cf16f | 0      | out_addr      | 00000008    | 0000000c       |
| 215000 | 0     | 0        | 00000002 | 763101e7 | 0      | out_valid     | 0           | 1              |
| 215000 | 0     | 0        | 00000002 | 763101e7 | 0      | out_err_plus2 | 1           | 0              |
                                                                                
**Test 5 – Error Handling**
| Time   | clear | in_valid | in_addr  | in_rdata | in_err | Signal        | Buggy Value | Bug Free Value |
|--------|-------|----------|----------|----------|--------|---------------|-------------|----------------|
| 250000 | 1     | 0        | 00000000 | 763101e7 | 0      | out_addr      | 00000004    | 00000008       |
| 250000 | 1     | 0        | 00000000 | 763101e7 | 0      | out_err_plus2 | 1           | 0              |
| 255000 | 1     | 0        | 00000000 | 763101e7 | 0      | out_err_plus2 | 1           | 0              |
| 260000 | 0     | 0        | 00000000 | 763101e7 | 0      | out_err_plus2 | 1           | 0              |
| 270000 | 0     | 1        | 00000000 | 4840006f | 1      | out_err_plus2 | 1           | 0              |
| 280000 | 0     | 0        | 00000000 | 4840006f | 1      | out_valid     | 0           | 1              |
| 280000 | 0     | 0        | 00000000 | 4840006f | 1      | out_err_plus2 | 1           | 0              |

## Identified Bugs :
### 1. Out_err_plus2 Constant in Aligned Mode:

**Reference from Test 1 and Test 2**:
In `Test 1` (Clear FIFO), the table shows that for times 30000, 35000, and 40000 the buggy design always drives `out_err_plus2` as 1 while the bug-free design expects 0. Similarly, in `Test 2` (Single Instruction Fetch – Aligned), at time 50000 and 60000 the buggy RTL again drives `out_err_plus2` as 1 when it should be 0.

**Bug Cause**:
The combinational block for the aligned case (when `out_addr_o[1]` is false) in the buggy RTL forces `out_err_plus2_o` to a constant 1'b1 instead of using the computed error signal.

### 2.Mis-indexed Data and Valid Signal Selection:

**Reference from Test 3 and Test 4**:
In Test 3 (FIFO Depth Test), the output address (`out_addr`) is observed as 00000000 at times 90000, 100000, and 105000 in the buggy design, while the bug-free design shows it should increment (e.g., 00000004 at these times). In Test 4 (Unaligned Instruction Fetch), at time 160000 the buggy design reports an out_addr of 00000008 versus the expected 0000000c.

**Bug Cause**:
The buggy code selects the rdata and err signals based on `valid_q[1]` rather than `valid_q[0]`. This off-by-one error in indexing causes the output data and addresses to be misaligned.

### 3.Incorrect Err_plus2 Signal Computation:

**Reference from Test 1, Test 2, Test 3, and Test 5**:
Across multiple tests, the out_err_plus2 value in the buggy RTL is incorrect. For instance, in Test 3 at time 105000 the buggy RTL computes `out_err_plus2` as 3 instead of 1 (as in the bug-free design). Similar discrepancies occur in Test 1, Test 2, and Test 5, where the error signal remains high when it should be low.

**Bug Cause**:
The logic for generating err_plus2 in the buggy code uses incorrect FIFO indices and logical operations, leading to miscomputation of this error flag.

### 4.FIFO Addressing and Extra/Missing Cycle Behavior:

**Reference from Test 2 and Test 3**:
In Test 2, the bug-free design produces an extra cycle at time 75000 that is missing in the buggy response. In Test 3, an extra row appears at time 95000 in the buggy design that should not exist.

**Bug Cause**:
These issues indicate that the update logic for FIFO addressing and valid signal propagation is inconsistent—likely due to the off-by-one error from mis-indexing—which leads to extra or missing FIFO cycles and misaligned output addresses.

### 5.FIFO Pop and Compressed Instruction Detection Issues:

**Reference from Test 4 (Unaligned Instruction Fetch)**:
At time 215000, the table shows that the buggy RTL incorrectly drives `out_valid` as 0 and `out_err_plus2` as 1 instead of the expected 1 and 0, respectively.

**Bug Cause**:
The FIFO pop logic in the buggy RTL is missing a crucial gating condition for handling unaligned (compressed) instructions. In the bug-free design, the FIFO pop signal is conditioned not only on the `out_ready_i` and `out_valid_o` handshake but also on whether the instruction is compressed. Specifically, the bug-free RTL uses an extra condition—such as checking (`~aligned_is_compressed | out_addr_o[1]`)—to ensure that for compressed instructions the FIFO is only popped when the second half of the instruction is ready. Without this condition, the buggy design pops the FIFO prematurely, clearing the valid signal too early and resulting in misaligned outputs and incorrect error flags.

### 6. Error Handling and Output Misalignment:

**Reference from Test 5 (Error Handling)**:
The table for Test 5 shows that, under error conditions, the output address is misaligned (e.g., 00000004 instead of 00000008 at 250000) and out_err_plus2 remains high over several cycles (times 250000, 255000, 260000, 270000, 280000) when the bug-free design expects it to be 0.

**Bug Cause**:
These issues reinforce that mis-indexing in FIFO handling and the flawed computation of the err_plus2 signal lead to incorrect behavior during error conditions, resulting in both address misalignment and persistent error flags.

## Deliverable :
During testing, the module failed to produce the expected output, leading to incorrect results. The module and its testbench are available in the current working directory for debugging, and the expected output is available in the testbench. Could you help debug and fix the RTL to ensure correct functionality?

### Prompt 66 ###
Design a `digital stopwatch` module in SystemVerilog. Refer to the specification provided in `docs/digital_stopwatch_spec.md` to design the RTL. The specification details a parameterizable stopwatch that maintains seconds, minutes, and a single-bit hour indicator, along with a start/stop control. The design should be hierarchical, with dig_stopwatch_top as the top-level module and 
dig_stopwatch implementing the core stopwatch logic. It must include:

- A clock divider that generates a 1 Hz pulse from a parameterized input clock (default 50 MHz).
- Separate counters for seconds (0–59) and minutes (0–59).
- A single-bit hour signal that is asserted upon rolling over 59 minutes.
- Output signals to indicate pulses when second, minute, or hour counters change.
- A beep mechanism that activates on each hour pulse and deactivates on the next second pulse.

The code should be well-documented with clear comments explaining the functionality of each major block. Follow best practices in SystemVerilog coding to ensure readability, reusability, and maintainability.

### Prompt 67 ###
Design a `direct_map_cache` module in SystemVerilog. Refer to the specification provided in `docs/direct_map_cache_spec.md` to design the RTL. The specification details a parameterizable direct-mapped cache supporting read/write operations, tag comparison for hit/miss detection, and valid/dirty bit management. Specifically, it must include:

## Requirements

1. **Parameterization**:
   - The design must be parameterizable for:
     - **Cache size**
     - **Data width**
     - **Tag width**
     - **Offset width**
   - This allows the design to scale easily to different systems.

2. **Tag Comparison Logic**:
   - Implement tag comparison logic to differentiate between cache hits and misses.

3. **Valid/Dirty Bit Management**:
   - Handle valid bit to mark cache lines as initialized or empty.
   - Track modifications using a dirty bit.

4. **Indexing and Offset Calculations**:
   - Address specific bytes within each cache line.
   - Include error detection for unaligned accesses.

5. **Synchronous Operations**:
   - Control read/write operations via the following signals:
     - `comp` (compare)
     - `write` (write)
     - `enable` (enable)

This document provides an overview of the `direct_map_cache` module design in SystemVerilog, outlining the key requirements, functionality, and design blocks.

### Prompt 68 ###
Modify the direct_map_cache module to implement a 2-way set associative cache with victim-way replacement and retain all current functionality (including tag comparison, write/read access, valid/dirty/error status, and LSB alignment error checking). The module should select between two cache ways during tag matches and use a victim policy for cache line replacement when both ways are valid but there is a miss. The modified module introduces a new internal victimway register to alternate replacement decisions in the absence of a direct match.

## Added/Modified Parameterization

- **N**: Number of ways per set. Default is 2 to implement a 2-way set-associative cache. its a local parameter 

## Design Modifications

### Associative Cache Structure

- Introduced 2-way set associativity by instantiating tag, data, valid, and dirty storage for two ways.
- A new internal `victimway` register implements a round-robin replacement policy on cache misses.
- Read and Write logic updated to probe both ways, handle hits/misses correctly, and update the correct way.
- Error signal continues to detect misaligned offset accesses, specifically when the LSB of the offset is high.
- Cache reset and enable handling behavior remains consistent but expanded for two-way state management.

### Hit and Miss Logic

- Hits can occur in either of the two ways, indicated by separate internal signals (`hit0`, `hit1`).
- A multiplexer selects outputs (`data_out`, `tag_out`, `valid`, `dirty`) from the correct way based on which way had a hit.

### Victim-Way Replacement Policy

- A `victim-way` register tracks which way to replace upon a miss if both ways are valid.
- On a cache miss and when both ways are valid, the victim way is used to store new data and the victim-way indicator toggles to ensure even usage of both ways.

### Misalignment Error Handling

- Continues to set the error signal high if the least significant bit of the offset is 1 (misaligned access).

## Behavioral Changes

### Operation Modes

1. **Compare Read** (`comp=1, write=0`):  
   - Checks for tag matches in both ways, updates output signals accordingly.

2. **Compare Write** (`comp=1, write=1`):  
   - Performs write if a match is found in either way or initiates victim-way replacement if a miss occurs.

3. **Access Read** (`comp=0, write=0`):  
   - Performs reads based on valid bits, without affecting victim-way tracking.

4. **Access Write** (`comp=0, write=1`):  
   - Writes data and tag inputs to both ways without victim logic engagement.

### Example Usage

#### Compare Write (Miss, Replacement)

- **comp = 1, write = 1**, `tag_in = <tag>`, `index = <idx>`, `valid_in = 1`, `data_in = <data>`, both ways valid, tag mismatch in both ways.
- Data is written into the current victim way, and the victim-way toggles for the next replacement.

#### Compare Read (Hit)

- **comp = 1, write = 0**, `tag_in = <tag>`, matching tag found in either way.
- `hit` is set high, and the correct `data_out` is returned from the matching way.

### Prompt 69 ###
I have a `direct_map_cache` module in the RTL directory. Write a SystemVerilog testbench named `tb_direct_map_cache.sv` in the verif directory that generates a wide range of read and write operations across different modes, such as compare and non-compare, and conditionally, like forced misses. 

## Module Instance

- Instantiate the `direct_map_cache` module as `uut` (Unit Under Test) in the testbench.

## Tasks 

Implement separate reusable tasks, each responsible for a specific stimulus scenario or operational mode in the cache. The tasks should cover at least the following functional areas:

### Initialization and Reset
- Prepares the environment by driving reset signals and ensuring the design is in a known state prior to applying any other inputs.

### Write with Compare Disabled
- Drives signals to perform write operations where compare logic is bypassed.
- Writes random or iterated data into cache lines to populate entries.

### Read with Compare Enabled
- Exercises a read operation that checks the tag field.

### Write with Compare Enabled
- Overwrites data in cache lines if a matching tag is detected, while compare is active.

### Read with Compare Disabled
- Retrieves data in a simpler access mode without relying on tag matching.

### Miss Scenario Generation
- Forces mismatches by selecting indices and tags unlikely to match existing entries.

### Offset Error Injection
- Applies an offset pattern that should trigger an error (e.g., least significant bit set in an address where it must remain clear).

### Coverage Corner Cases
- Specifically vary conditions that test partial hits, valid bit clearing, different dirty states, and scenarios where tags match but the valid bit is not set, or vice versa.
- Generate test sequence hits corner conditions such as:
  - A valid line with a matching tag.
  - A valid line with a mismatching tag.
  - An invalid line with a matching tag.
  - An invalid line with a mismatching tag.

Each task should display the relevant signals (e.g., indices, offsets, tags, data, and status flags) and outcomes (hit/miss, error indication) for traceability. The combination of these tasks must collectively cover the full range of operational behaviors.

## Test Scenarios & Structured Logging

- Use a systematic or random sequence that calls the above tasks multiple times with varying index, tag, and data values to ensure broad coverage.

- After each operation, print diagnostic messages that show the inputs and outputs, focusing on:
   - The action taken (read/write, compare mode or not).
   - The cache line/index/offset accessed.
   - Whether the operation resulted in a hit, miss, dirty line, or error.

## Test Execution Control

- Trigger the reset sequence to initialize the device under test.
- Call each stimulus task in an order that logically tests standard usage, corner cases, and error paths.
- Use repeat loops or nested loops (or a combination of both) to systematically cover different indices, tags, offsets, and data patterns.
- Finish the simulation using `$finish` when all tests are complete.

### Prompt 70 ###
I have a SystemVerilog testbench named `tb_direct_map_cache.sv` that currently stimulates a direct-mapped cache module named `direct_map_cache`. The testbench is located in the verif directory and already exercises various cache behaviors like read, write, compare, and error scenarios.

Modify the existing testbench tb_direct_map_cache by:

## 1. Write Without Compare 
### Checker Functionality:
- Ensure that the error signal is **not** asserted during valid aligned writes.
- Confirm the write operation completes without triggering any unexpected fault.

## 2. Read With Compare 
### Checker Functionality:
- If a cache hit occurs and the line is valid, verify that the output data matches the most recently written value.
- Flag an error if:
  - The hit is not asserted.
  - The data mismatches.
- Confirm that the error signal remains deasserted.

## 3. Write With Compare 
### Checker Functionality:
- If the line is valid and a tag match occurs, verify that it results in a hit.
- Check that the dirty bit is asserted after such a write.
- If it’s a miss or an invalid line, confirm no dirty bit is falsely set.
- Ensure that the error signal stays low during this flow.

## 4. Read Without Compare 
### Checker Functionality:
- No data validity expectations, but ensure that the error signal is **not** asserted.
- Useful for checking that non-compare reads don’t raise faults.

## 5. Miss Detection
### Checker Functionality:
- Ensure that when accessing a different index or using a mismatched tag, the operation results in a miss (i.e., `hit` is low).
- The error signal must remain deasserted during this scenario.

## 6. Misaligned Offset Error 
### Checker Functionality:
- Confirm that the error signal is asserted when the offset's least significant bit is 1 (misaligned access).
- This validates the module's error-detection logic.

## 7. Cache Hit Logic Coverage 
### Checker Functionality:
- For compare-write with valid tag match:
  - Assert that `hit = 1` and `dirty = 1`.
- For mismatched tags:
  - Ensure `hit = 0` and `dirty = 0`.
- When the valid bit is cleared:
  - Ensure that subsequent accesses do not result in a hit.
- After re-validation, check that the cache behaves as expected again.
- At every step, ensure that the error signal remains 0 unless deliberately triggering a fault.

### Prompt 71 ###
I have a Direct-Mapped Cache RTL module (`direct_map_cache.sv`) in my RTL directory. Please enhance this module by adding SystemVerilog Assertions (SVA) to comprehensively verify its internal functionality. The assertions should verify the following conditions:
## Reset Behavior for Output Signals:

- When the reset signal (`rst`) is active (active high), all critical output signals—specifically, `hit`, `dirty`, `valid`, and` data_out`—are cleared to zero in the same clock cycle.

## Misaligned Offset Handling:

- Add an assertion to detect misaligned accesses by monitoring the least significant bit of the offset. When this bit indicates misalignment, the assertion should verify that in the next clock cycle the error signal (`error`) is asserted and the hit signal remains inactive.

## Aligned Offset Handling:

 - When the offset is correctly aligned, the `error` signal remains de-asserted in the next clock cycle.

## Compare Read Operation – Hit Detection:

- Compare read operation (where the cache checks the tag for a read), verifies that if the cache line is valid and the input tag matches the stored tag, a cache hit is correctly indicated in the following clock cycle.

## Compare Write Operation – Hit and Dirty Update:

- Add an assertion for a compare-write operation that checks if the cache line is valid and the input tag matches the stored tag, then the cache should assert a hit and update the corresponding dirty bit in the following clock cycle.

## Direct Access Read Behavior:

- Write an assertion that verifies during a direct access read (non-compare read) that the cache does not erroneously signal a hit in the next clock cycle.

## Direct Access Write Behavior:

- For a direct access write that ensures, while the cache line is updated with new data and the valid bit is set, the cache `hit` signal remains inactive in the following clock cycle.

## Behavior When Module Is Disabled:

- When the module is disabled (i.e., the `enable` signal is LOW), all output signals (`hit, dirty, valid, and data_out`) are cleared in the same clock cycle.

### Prompt 72 ###
Design a `dma_xfer_engine` module in SystemVerilog. Refer to the specification provided in `docs/specs.md` and ensure you understand its content. The specification details parameterization for transfer sizes (`DMA_B`, `DMA_HW`, `DMA_W`), a 10-bit control register (`cnt`, sizes, increment enables), and 32-bit addresses and data. It also describes the internal FSM states (IDLE, WB, TR) and the interface signals for both slave register access and master bus transactions. Implement byte, halfword, or word transfers with optional address incrementing for both source and destination. Provide complete RTL code that properly handles control-register reads and writes, requests and grants from the bus arbiter, data packing, and unpacking, and an internal buffer for read-before-write. The design must also be reset correctly and returned to IDLE once the transfer count is exhausted.

### Prompt 73 ###
Design a `door_lock` module in SystemVerilog within a file `door_lock.sv` at the location: `rtl/door_lock.sv`. Refer to the specification provided in `docs/specification.md` and ensure you understand its content. The specification details the functional behavior of the door lock system, including user authentication, password storage, incorrect attempt handling, and administrative override features. It provides an overview of the required FSM, state transitions, module interface, and timing requirements. Generate the complete RTL code that implements the `door_lock` module, ensuring that it follows the expected FSM behavior for user authentication and password verification.

### Prompt 74 ###
I have a specification of a `door_lock` module in the `docs` directory. Write a SystemVerilog testbench `tb_door_lock.sv` in the `verif` directory to only generate stimuli and achieve maximum coverage for the `door_lock` module.

Include the following in the generated testbench:

- **Module Instance**: Instantiate the `door_lock` module as `door_lock_inst`, ensuring all input and output signals are properly connected for testing.
- **Clock Generation**: Implement a 10ns period clock.
- **Reset Procedure**: Include a reset task that initializes all inputs before stimulus is applied.
- **Password Entry Task**: Implement a task to drive a sequence of key inputs followed by confirmation. This task should support both correct and incorrect passwords.
- **Admin Override Task**: Create a task that drives the admin override sequence on the relevant signals.
- **Password Change Task**: Add a task to drive admin mode signals and provide a new password via stimulus.
- **Stimulus Scenarios**:
  - Apply stimulus corresponding to a correct password entry.
  - Apply stimulus for incorrect password entries.
  - Apply stimulus for multiple incorrect attempts to trigger lockout-related behavior.
  - Apply admin override stimulus.
  - Apply a sequence to change the password via admin inputs, followed by stimulus for the new password.
  - Generate random password sequences and apply them repeatedly to test behavior under stress.

Do not include checker logic or internal state validation. The testbench should be structured for applying input stimulus only and include display messages for traceability and debug.

### Prompt 75 ###
I have a `door_lock` module available in the `rtl` directory. Please enhance the module by adding **SystemVerilog Assertions (SVA)** that formally verify internal control logic, password flow, FSM transitions, and safety constraints.

### Assertion Requirements

The assertions must cover the following behavioral and functional properties:

1. **System Reset Behavior**  
   Ensure that when `srst` is asserted, the system is initialized correctly:  
   - FSM must transition to `IDLE`  
   - `door_unlock` and `lockout` must be deasserted  
   - `fail_count` should reset to 0  
   - `entered_password` and `entered_count` must reset to 0
   - `stored_password` must initialize to 4'd1

2. **Admin Override Behavior**  
   If the system is in `IDLE` and `admin_override` is asserted (with `admin_set_mode` deasserted), the FSM must transition to `PASSWORD_OK`.

3. **Admin Mode Entry**  
   FSM must enter `ADMIN_MODE` only when both `admin_override` and `admin_set_mode` are high while in  `IDLE`. 

4. **Correct Password Handling**  
   A matching password (`match == 1`) in the `CHECK_PASS` state must result in a transition to `PASSWORD_OK`.

5. **Failed Attempt Tracking**  
   In the `PASSWORD_FAIL` state, `fail_count` must increment by one if it is below the `MAX_TRIALS - 1` limit.

6. **Lockout Triggering**  
   If `fail_count` is equal to `MAX_TRIALS - 1` and in the `PASSWORD_FAIL` state, the FSM must enter `LOCKED_OUT`.

7. **Password Update Restrictions**  
   `stored_password` should only update during `ADMIN_MODE` and when `new_password_valid` is asserted.

8. **Lockout Persistence**  
   Once in `LOCKED_OUT`, the FSM must remain in that state unless `admin_override` is asserted.

9. **Confirm Timing**  
   In `ENTER_PASS`, the `confirm` signal must only be used after all digits have been entered (`entered_count == PASSWORD_LENGTH`), or it should transition to `PASSWORD_FAIL`.

10. **door_unlock State Validity**  
    The `door_unlock` signal must only be asserted during the `PASSWORD_OK` state.

11. **Input Range Validity**  
    When `key_valid` is high, `key_input` must always be between `0` and `9`.

12. **door_unlock Pulse Duration**  
    `door_unlock` should only remain high for **exactly one clock cycle**.

13. **Lockout Exit Timing**  
    Once in `LOCKED_OUT`, if `admin_override` is asserted, `lockout` must be deasserted exactly two cycles later.

14. **FSM Exit from PASSWORD_OK**  
    The FSM must transition from `PASSWORD_OK` to `IDLE` unconditionally on the next clock cycle.

### Expected Behavior

If any of the above properties are violated during simulation or formal verification, an assertion failure must be triggered with a meaningful error message identifying the faulty condition.

### Notes

- All assertions must use **SystemVerilog Assertions (SVA)** syntax.
- Only the `door_lock` module file should be modified. Do not introduce new files or modules.

### Prompt 76 ###
Design a `dramcntrl` module in SystemVerilog (filename: **dramcntrl.sv**) according to the specification detailed in `docs/specs.md`. The design must support DRAM initialization—including a 100 µs power-up delay, precharge, two auto-refresh cycles, and mode register programming—followed by normal read/write operations. Parameterize the module with:

- **del:** Delay counter width for initialization and auto-refresh.
- **len_auto_ref:** Width for the auto-refresh counter.
- **len_small:** Width for timing delays (tRCD, tRP, tRFC, etc.).
- **addr_bits_to_dram, addr_bits_from_up, ba_bits:** For DRAM and upstream addressing.

The controller must drive DRAM control signals (`addr`, `ba`, `clk`, `cke`, `cs_n`, `ras_n`, `cas_n`, `we_n`, `dqm`) via an internal FSM that sequences commands (`ACTIVE`, `READ`, `WRITE`, `BURST TERMINATE`, `PRECHARGE`, `AUTO-REFRESH`). After a defined CAS latency for read commands, it must generate a read-data-ready signal. Include functions for vector increment and decrement, proper reset handling, edge detection for new read/write requests, and auto-refresh scheduling with saturation logic.

Additionally, provide a comprehensive SystemVerilog testbench (filename: **dramcntrl_tb.sv**) aligned with the provided testbench code requirements. The testbench must:

- Generate a 100 MHz clock.
- Apply reset, verify initialization (`dram_init_done` asserted), and simulate basic write and read operations.
- Test concurrent read/write requests.
- Stress auto-refresh scheduling (including saturating the auto-refresh counter) and verify `dram_busy`.
- Force operations while busy and cover all branches of the RTL, ensuring 100% code coverage.

Provide complete RTL (`dramcntrl.sv`) and testbench (`dramcntrl_tb.sv`) code that simulates and validates all functionality together.

### Prompt 77 ###
I have a specification of a `dramcntrl` module in the `docs` directory. Write a SystemVerilog testbench `dramcntrl_tb.sv` in the `verif` directory to only generate stimuli and achieve maximum functional coverage for the `dramcntrl` module.

Include the following in the generated testbench:

- **Module Instance**: Instantiate the `dramcntrl` module as `dut`, appropriately connecting all input and output signals.
- **Clock Generation**: Use a 100 MHz clock with a 10ns period (`clk_in`).
- **Reset Procedure**: Create an `apply_reset` task that asserts reset for 10 cycles and deasserts it before the stimulus begins.

- **Basic Access Tasks**:
  - `do_write`: A task to drive valid write sequences with address stimulus.
  - `do_read`: A task to apply read transactions at given addresses.
  - `do_concurrent_rd_wr`: A task to simultaneously assert read and write operations, switching address mid-transfer.

- **Stress and Coverage Stimulus**:
  - Apply known address sequences to verify deterministic behavior.
  - Generate back-to-back `WR` → `RD` transitions to stress arbitration.
  - To test decoder coverage, access edge and extreme address ranges (`0x000000`, `0xFFFFFF`).
  - Apply randomized traffic using `random_traffic()` and long idle intervals to activate auto-refresh logic.
  - Use `saturate_no_of_refs` to increment `no_of_refs_needed` to its maximum value.
  - Repeatedly toggle the `bus_term_from_up` signal during transactions to activate toggle paths and TB vector logic.
  - Inject 1-cycle WR and RD pulses to target delayed signal conditions in the control FSM.
  - Perform transactions during refresh/busy periods to stimulate FSM edge paths.
  - Introduce reset mid-transaction to verify FSM recovery paths.
  - Reapply reset and re-initialize stimulus to force reentry into all operational states.
  - Run sequences that stimulate boundary and cross-bank transitions in memory addressing.
  - Include random WR/RD accesses with idle spacing to activate slow paths and timeouts.

- **Final Execution**:
  - Repeat WR/RD/idle sequences and concurrent access with varied spacing.
  - Ensure maximum toggle and block coverage of counters and delay registers.
  - Add display messages or timing comments only for traceability and debugging.

Do not include checkers, assertions, or internal state comparisons. The testbench should be structured strictly for applying input stimulus to the DUT and exercising its logic comprehensively.

### Prompt 78 ###
The `dual_port_memory` module is designed to provide simultaneous read and write access to two ports. However, during testing, it was observed that data corruption occurs, leading to incorrect outputs. Specifically, the testbench reports errors ("Test Failed: Last Write Dominance Issue") where written values are not correctly stored and retrieved due to unintended bit modifications and faulty read logic. The module and its testbench are available in the current working directory for debugging.

### Prompt 79 ###
Can you **modify the `dual_port_memory` module** to support **ECC-based error detection** using the **Hamming(7,4)** code, for a memory array that allows **independent dual-port access**?

---

###  Design Specification

---

### Dual-Port Architecture

The memory must support **true dual-port access** where:

- **Port A** is used for **write operations** using:  
  - `addr_a` (address)  
  - `data_in` ([3:0] data input)  
  - `we` (write enable)

- **Port B** is used for **read operations** using:  
  - `addr_b` (address)  
  - `data_out` ([3:0] data output)

- Both ports must operate **concurrently and independently**, provided they access **distinct addresses**. Address collision management is **handled by the testbench**, not internally.

---

###  ECC Encoding and Error Detection

This module integrates **Hamming(7,4)** logic, which includes 4 data bits and 3 parity bits:

- **Data bits**: `d[3:0]`  
- **Parity bits** (`p[2:0]` for `ECC_WIDTH=3`):
  - `p0 = d0 ^ d1 ^ d3`
  - `p1 = d0 ^ d2 ^ d3`
  - `p2 = d1 ^ d2 ^ d3`

####  Write Operation (`we == 1`):
- Compute the 3-bit **ECC parity code** from the 4-bit `data_in` using Hamming(7,4).
- Store the original `data_in` into `ram_data[addr_a]`.
- Store the computed ECC bits into `ram_ecc[addr_a]`.

####  Read Operation:
- Fetch both `data_word` and `ecc_word` from memory arrays at `addr_b`.
- Recompute ECC from `data_word`.
- Calculate **syndrome** using XOR: `syndrome = ecc_word ^ computed_ecc`.
- If `syndrome != 3'b000`, assert `ecc_error = 1`, else `ecc_error = 0`.
- Always output uncorrected `data_word` on `data_out`.

---

###  Memory Organization

- `ram_data`: Stores 4-bit words (default `DATA_WIDTH = 4`)
- `ram_ecc`: Stores 3-bit ECC codes (default `ECC_WIDTH = 3`)
- `MEM_DEPTH = 2 ** ADDR_WIDTH` (default `ADDR_WIDTH = 5`, so 32 entries)

---

###  Reset Behavior

On `rst_n == 0`:
- `data_out` is cleared to 0.
- `ecc_error` is cleared to 0.
- Contents of `ram_data` and `ram_ecc` are **not reset or modified**.

---

###  Interface Parameters

| Parameter     | Description                                          |
|---------------|------------------------------------------------------|
| `DATA_WIDTH`  | Width of input/output data (default: 4 bits)         |
| `ECC_WIDTH`   | Width of ECC code (default: 3 bits for Hamming)      |
| `ADDR_WIDTH`  | Width of the address bus (default: 5 bits)           |
| `MEM_DEPTH`   | Number of memory locations (2<sup>ADDR_WIDTH</sup>)  |

---

###  Functional Constraints

- All ECC codes must be computed using **Hamming(7,4)** parity logic.
- Only **single-bit error detection** is required using the `ecc_error` signal.
- No correction or masking is required — `data_out` always shows uncorrected data.
- No internal hazard detection is required — assume testbench avoids simultaneous read/write to same address.

---

###  Output Behavior

- On ECC match: `ecc_error = 0`, `data_out = valid data`
- On ECC mismatch (1-bit error detected): `ecc_error = 1`, `data_out = same (uncorrected) data`

---

### Prompt 80 ###
The `dual_port_memory` module's `specification.md` is in the `docs` folder. Write a SystemVerilog testbench `tb_dual_port_memory.sv` in the `verif` directory to generate **only stimulus** for the `dual_port_memory` module to achieve **maximum coverage** of the DUT.

---

###  Include the Following:

#### **1. Module Instance**
- Instantiate the `dual_port_memory` module as `dut`.
- Connect all input and output ports for testing.
- Parameters `DATA_WIDTH`, `ECC_WIDTH`, `ADDR_WIDTH`, and `MEM_DEPTH` must be configurable at the top of the testbench.

#### **2. Input Generation**
- The testbench must apply the following test cases to stimulate the DUT:

#####  Functional & Stimulus-Based Test Cases:
| **Test #** | **Stimulus Description**                                                                |
|------------|-----------------------------------------------------------------------------------------|
| 1          | Write and read from the same address.                                                   |
| 2          | Back-to-back sequential writes and reads to multiple addresses.                         |
| 3          | Sequential read-after-write hazard (write to `i`, read from `i-1`).                     |
| 4          | Same data (`4'b1111`) to different addresses.                                           |
| 5          | Inject single-bit **data** corruption after a valid write.                              |
| 6          | Inject single-bit **ECC** corruption while data remains intact.                         |
| 7          | Write to **minimum (0)** and **maximum (MEM_DEPTH - 1)** addresses.                     |
| 8          | Write and read **walking 1s** pattern.                                                  |
| 9          | Fill the memory with all `0`s and read back to verify.                                  |
| 10         | Write valid data and corrupt ECC on every 4th address.                                  |
| 11         | Simultaneous read and write to the **same** address.                                    |
| 12         | One-hot addressing pattern (e.g., 1, 2, 4, 8...).                                       |
| 13         | Write all possible 4-bit patterns (0 to 15) to the same address.                        |
| 14         | Invert a value read from memory and write it back to a new address.                     |
| 15         | Read-modify-write test: read, update, and re-write the value.                           |
| 16         | Full corruption: invert **data** and **ECC** bits.                                      |
| 17         | Flip each ECC bit individually and verify error detection.                              |
| 18         | Flip each data bit individually and verify error detection.                             |
| 19         | Toggle between writing to min and max addresses.                                        |
| 20–36      | Random writes/reads, including even/odd patterns, address gaps, wraparounds, and reuse. |
| 37–45      | Repeating write-read cycles with incrementing data to stress address space.             |

#### **3. Computation Period**
- After applying each input (especially `we = 0` for read), wait **until `data_out` and `ecc_error` settle** or a **timeout of 50 clock cycles**, whichever comes first.
- Ensure the testbench never enters an infinite loop while waiting for an ECC response.

#### **4. Monitoring and Tracing**
- Use `$display` to mark the beginning of each test case (e.g., `[Test 5] ECC Error - Data Flip`).
- Use `$monitor` to track changes in key signals:
  - `clk`, `rst_n`, `we`, `addr_a`, `addr_b`, `data_in`, `data_out`, and `ecc_error`.

---

### Prompt 81 ###
Design a SystemVerilog `dynamic_equalizer` (in `rtl/dynamic_equalizer.sv`) module, using signed fixed-point notation Q2.13 for all data signals. Refer to the specification files located in the `docs/` directory. These files contain the definition of the dynamic equalizer’s structure, the specifications of its internal modules, and a description of common algorithms used for error calculation. Review the specifications carefully and implement the modules using the LMS (Least Mean Squares) algorithm. Since the internal modules of the `dynamic_equalizer` do not yet exist, you are required to develop them as well (should be defined within `rtl/error_calc.sv` and `rtl/coeff_update.sv`).

### Prompt 82 ###
There is a SystemVerilog `dynamic_equalizer` module in the `rtl/` directory. The module and its internal modules are designed for the LMS (Least Mean Squares) algorithm, change them to use the MCMA (Multimodulus Constant Modulus Algorithm) algorithm. Refer to the specification files located in the `docs/` directory. These files contain the definition of the dynamic equalizer’s structure, the specifications of its internal modules, and a description of common algorithms used for error calculation.

### Prompt 83 ###
There is a SystemVerilog `dynamic_equalizer` module in the `rtl/` directory. The module and its internal modules are designed for the MCMA (Multimodulus Constant Modulus Algorithm) algorithm. Refer to the specification files located in the `docs/` directory and integrate the `dynamic_equalizer` with two `awgn` modules, one for the real data and other for the imaginary data, inside of a top module `equalizer_top`. These files contain the definition of the dynamic equalizer’s structure, the specifications of its internal modules, and a description of common algorithms used for error calculation. The top module `equalizer_top` should be defined in `rtl/equalizer_top.sv`, and the internal `awgn` should be in `rtl/awgn.sv`.

### Prompt 84 ###
Modify the elevator control system to support overload detection and direction indicators (LEDs), while retaining its core functionality of managing multiple floors, handling call requests, and responding to emergency stops. The updated module now includes an `overload` input to simulate elevator weight overload, and additional outputs `up_led`, `down_led`, and `overload_led` to reflect current operational status.

---

### **Design Specification**

The `elevator_control_system` module is an FSM-based design that manages elevator movement across `N` floors, processes floor requests, handles emergency stops, and opens/closes doors automatically. The enhanced version now includes **overload protection** and **direction indication via LEDs**.

**New Functional Features**
1. **Overload Detection**
   - Input signal: `overload`
   - When `overload = 1`, the elevator halts in its current state and transitions to the `DOOR_OPEN` state if not already there.
   - Doors remain open during overload.
   - Elevator movement is disabled until the overload is cleared (`overload = 0`).
   - Output signal: `overload_led = 1` when overload is active.

2. **Direction LEDs**
   - `up_led = 1` when the elevator is moving up (`MOVING_UP` state).
   - `down_led = 1` when the elevator is moving down (`MOVING_DOWN` state).
   - Both LEDs are deactivated in `IDLE`, `DOOR_OPEN`, or `EMERGENCY_HALT` states.

---

### **Operational Behavior**

**State Transitions**
- **IDLE**: Waits for a request. If `overload` is active, it transitions directly to `DOOR_OPEN`.
- **MOVING_UP / MOVING_DOWN**: Moves floor-by-floor based on pending requests. Transitions to `DOOR_OPEN` when a requested floor is reached.
- **DOOR_OPEN**: Keeps doors open for a predefined duration. If `overload = 1`, the doors remain open indefinitely until the overload clears.
- **EMERGENCY_HALT**: Activated by `emergency_stop`. Resumes to IDLE once the signal is deactivated.

**Priority Logic**
- Requests are served based on current direction:
  - Upward requests take priority when going up.
  - Downward requests take priority when descending.
- If no request remains in the current direction, the system returns to IDLE.

---

### **Example Scenarios**

**Example 1: Overload During Movement**
- **Input**:
  - Current floor: 5, Requested floor: 2
  - `overload` = 1 triggered while elevator is moving down
- **Expected Behavior**:
  - Elevator halts immediately
  - Door opens and stays open
  - `overload_led` = 1
  - After clearing overload, elevator resumes to floor 2

**Example 2: Direction LED Behavior**
- **Input**:
  - Request floor 3 from ground floor
- **Expected Behavior**:
  - `up_led` = 1 while elevator ascends
  - `down_led` = 0
  - Once door opens, both LEDs turn off

**Example 3: Overload While Idle**
- **Input**:
  - No active requests, `overload = 1`
- **Expected Behavior**:
  - Elevator stays in `DOOR_OPEN` state
  - `overload_led` = 1
  - No movement until overload clears

### Prompt 85 ###
Design a SystemVerilog RTL module named `ethernet_mii_tx.sv` in the `rtl` directory. Refer to the specification in `docs/tx_specification.md`, which defines an Ethernet transmitter compatible with the MII interface. The module must accept Ethernet frame data via an AXI-Stream interface and transmit it over a 4-bit MII data interface (`mii_txd_out`) along with an accompanying transmit enable signal (`mii_tx_en_out`).

The design must include:

1. FIFO logic for clock domain crossing (CDC) between the AXI-Stream and MII transmit domains. Use the existing FIFO module (`rtl/ethernet_fifo_cdc.sv`) to instantiate and integrate into the `ethernet_mii_tx` top module. The FIFO should support full-frame buffering of up to 1518 bytes and maintain synchronization across domains using dual-clock FIFO techniques.

2. TX logic to convert AXI data into MII format. This includes sending the preamble, start frame delimiter (SFD), payload, and CRC. The CRC must be calculated using the Ethernet CRC-32 polynomial with bit reversal as per standard Ethernet conventions. The transmit state must be managed with a finite state machine (FSM).

### Prompt 86 ###
Implement an Ethernet MAC TX subsystem in `rtl/ethernet_mac_tx.sv`, integrating with a dual-port memory (DP-RAM) module for frame data buffering, as specified in `docs/tx_mac_specification.md`.

**Step 1:**  
- Implement the Dual-Port RAM module in `rtl/ethernet_dp_ram.sv` with:
  - Single-clock operation using `clk_in`
  - Two access ports:
    - **Port 0 (Configuration Port):**
      - Inputs: `addr0_in` (word-aligned address), `data0_in`, and `wr0_in`
      - Output: `data0_out` (data available after one clock cycle delay)
    - **Port 1 (Transmit Port):**
      - Input: `addr1_in` for sequential reading
      - Output: `data1_out` (data available with one clock cycle read latency)
      
**Step 2:**  
- Implement the Ethernet MAC TX subsystem in `rtl/ethernet_mac_tx.sv` with DP-RAM integration, including:
  -  Configuration Interface.
  - **Operational Modes:**
    - **Normal Mode:** Program complete frame data (MAC addresses and payload) before triggering transmission
    - **MAC Program Mode:** Update only the MAC addresses and reuse previously programmed payload data by asserting the PROGRAM bit with the BUSY indicator
  - **AXI-Stream Interface:**
    - Generate outputs: `axis_tdata_out` (32-bit), `axis_tstrb_out` (4-bit), `axis_tvalid_out`, and `axis_tlast_out`
    - Respect the `axis_tready_in` signal for flow control
  - **Interrupt Generation:**
    - Generate an interrupt upon complete frame transmission if enabled via register 0x07F8

### Prompt 87 ###
Design an `event_scheduler` module in SystemVerilog. Refer to the specification provided in `docs/specs.md` and ensure you understand its content. The specification details parameterization (MAX_EVENTS=16, TIMESTAMP_WIDTH=16, PRIORITY_WIDTH=4, TIME_INCREMENT=10 ns), dynamic event addition and cancellation with error signaling, and event triggering based on `current_time`. Use temporary arrays for atomic state updates and select eligible events with the highest priority when multiple events are pending. Generate complete RTL code that implements the event scheduler with proper handling of add, cancel, and trigger operations. The design must include state update mechanisms to ensure operation and error-checking logic to validate event addition and cancellation requests.

### Prompt 88 ###
I have a module named `event_scheduler` in the rtl directory that implements a programmable event scheduler for real-time systems. The original module supports dynamic event addition and cancellation by maintaining arrays of timestamps, priorities, and validity flags for up to 16 events. It increments an internal system time by a fixed step of 10 ns each clock cycle and triggers events when their scheduled time is reached. When multiple events are eligible, it selects the one with the highest priority. The module also signals an error if an event is added to an already active slot or if an attempt is made to cancel a non-existent event.

Your task is to modify the existing SystemVerilog code to enhance the functionality of the event scheduler while retaining the original interface ports. The modified module should still be named event_scheduler and remain in the same file (`rtl/event_scheduler.sv`). The specification detailing the architecture of the modified RTL is available in `docs` directory


**The modifications must include the following new features**:

## Event Modification/Rescheduling:

Add a new control input called `modify_event` and two additional inputs: `new_timestamp` and `new_priority.

When `modify_event` is asserted, the module should update the timestamp and priority for an existing event (identified by `event_id`), provided that the event is already active.

The module must assert the error signal if the event is inactive.

## Recurring Events:

Introduce two new inputs: `recurring_event` (a flag) and `recurring_interval` (a 16-bit value).

If an event is marked as recurring (i.e. recurring_event is high), then when that event is triggered, its timestamp should be automatically updated by adding the recurring_interval rather than deactivating the event.

This feature allows the scheduler to support periodic events.

## Event Logging:

Add two new outputs: `log_event_time` and `log_event_id`.

These outputs should capture the system time at which an event is triggered and the corresponding event ID.

The logging must occur in the same cycle as the event trigger.

## Additional requirements:

The modified module must retain the original interface for `clk`, `reset`, `add_event`, `cancel_event`, `event_id`, `timestamp`, and `priority_in`.

All additional functionality must be added by introducing extra inputs and outputs without altering the existing ones.

The design must continue to increment the internal `current_time` by 10 ns per cycle and use temporary arrays for atomic updates.

The error handling should remain intact: the module must assert an error if a duplicate event addition is attempted or if a modification/cancellation is attempted on a non-existent event.

The selection logic should continue to choose the highest priority event among those that are due, based on the updated time.

The module should update all temporary state and then commit the changes at the end of the clock cycle to ensure proper synchronization.

## Deliverable :
Your deliverable is the modified SystemVerilog code in the file `rtl/event_scheduler.sv` that implements these enhancements while maintaining similar timing characteristics and behavior as the original design.

### Prompt 89 ###
The `event_storage` module in rtl directory synchronously stores events from the input `i_event` in a register bank. Each `i_event` input has an equivalent register. If the interface signal `i_en_overflow` is asserted, the register bank may wrap around when it reaches its maximum value, and an event occurs. If not asserted, the data stored in the register bank must be saturated.

The signals `i_bypass`, `i_data`, `i_raddr` are used to set the `o_data` signal such as:
- If `i_bypass == 1`, then `o_data = i_data`.
- If `i_bypass == 0`, then `o_data = reg_bank[i_raddr]`.

**Modify** the module `event_storage` so that it is fully parameterizable. The parameters for this block are:

- `NBW_STR`: Defines the bit width of the input and output data, as well as the bit width of each register in the register bank.
- `NS_EVT`: Defines the number of parallel events stored by the module.
- `NBW_EVT`: Defines the bit width of the read address used to select one of the event counters in `reg_bank`.

----------

The `event_array` module implements a **2D pipeline of event processors** (called `event_storage` units), structured as a grid of **NS_ROWS × NS_COLS**. Each processor operates on a stream of input data and associated events, performing updates and passing data to the next row in the same column. **All of the top module connections are fully combinational**. A testbench for it is provided.

**Create** an `event_array` module in the rtl directory, and make sure it is fully parameterizable.

### Specifications

- **Module Name**: `event_array`

- **Parameters**:
    - `NS_ROWS`: Number of rows in the 2D processing array.
        - Default value: 4.
        - Related interface signals: `i_en_overflow`, `i_event`, `i_bypass`.
    - `NS_COLS`: Number of columns in the 2D processing array.
        - Default value: 4. Must always be $`2^{NBW\_COL}`$
        - Related interface signals: `i_en_overflow`, `i_event`, `i_data`, `i_col_sel`.
    - `NBW_COL`: Bit width of the column selection signal.
        - Default value: 2.
        - Related interface signals: `i_col_sel`.
    - `NBW_STR`: Bit width of the data processed in each `event_storage`.
        - Default value: 8.
        - Related interface signals: `i_data`, `o_data`.
    - `NS_EVT`: Number of event bits handled by each `event_storage`.
        - Default value: 8. Must always be $`2^{NBW\_EVT}`$
        - Related interface signals: `i_event`.
    - `NBW_EVT`: Bit width of the read address used for event selection inside each `event_storage`.
        - Default value: 3.
        - Related interface signals: `i_raddr`.

### Interface Signals

- **Clock** (`clk`): Synchronizes operation at the rising edge.
- **Reset** (`rst_async_n`): Active-low asynchronous reset. Resets the internal storage elements.
- **Column Select** (`[NBW_COL-1:0] i_col_sel`): Selects which column’s output from the last row will be assigned to `o_data`.
- **Overflow Enable** (`[NS_ROWS*NS_COLS-1:0] i_en_overflow`): One-bit flag per `event_storage`. When high, enables overflow in `event_storage`'s internal registers.
- **Event Input** (`[(NS_ROWS*NS_COLS*NS_EVT)-1:0] i_event`): All events (flattened) to be applied across the array. Each `event_storage` receives `NS_EVT` bits.
- **Input Data** (`[(NS_COLS*NBW_STR)-1:0] i_data`): Parallel input data for the **first row only**, one value per column.
- **Bypass Control** (`[NS_ROWS-1:0] i_bypass`): One bit per row. When high, it bypasses the event logic in that row's `event_storage`.
- **Read Address** (`[NBW_EVT-1:0] i_raddr`): Address input used to read specific event-mapped data from each `event_storage`.
- **Output Data** (`[NBW_STR-1:0] o_data`): Output from the selected column in the **last row**.

### Functional Description

The `event_array` module is structured as a **2D pipeline** of `event_storage` units. Each unit represents a processing cell that performs bit-based updates to its internal data register according to the received `i_event` bits and the `i_en_overflow` flag.

The array is organized as `NS_ROWS` rows and `NS_COLS` columns.

#### Input Flow:
- Input data (`i_data`) is injected only into the **first row** of the array.
- Each subsequent row receives the processed output from the `event_storage` directly above it in the same column.
- All `event_storage` receive a unique slice of the flattened `i_event` and `i_en_overflow` arrays:
   - In `event_array`, the `i_event` input is a flat vector that holds all event bits for every cell in the grid, with each `event_storage` requiring `NS_EVT` bits. The module slices this vector by assigning `NS_EVT` bits to each `event_storage` based on its row and column. The slicing starts from the most significant bit and moves left to right across columns, then top to bottom across rows — like reading a table row by row. This way, each cell gets exactly the bits intended for its position in the array.
      - For example, if `NS_ROWS = 2`, `NS_COLS = 2`, and `NS_EVT = 4`, then `i_event` is 16 bits wide. The cell at row 0, column 0 gets the top 4 bits `[15:12]`, row 0, column 1 gets `[11:8]`, row 1, column 0 gets `[7:4]`, and row 1, column 1 gets the lowest 4 bits `[3:0]`.

   - The `i_en_overflow` input is a flat bit vector with one bit per `event_storage` in the grid. The vector is sliced using a row-major order: starting from the least significant bit, it maps left to right across columns, then top to bottom across rows.
      - For example, if `NS_ROWS = 2` and `NS_COLS = 2`, then `i_en_overflow` is 4 bits wide. The cell at row 0, column 0 gets bit `[0]`, row 0, column 1 gets bit `[1]`, row 1, column 0 gets bit `[2]`, and row 1, column 1 gets bit `[3]`.


#### Output Logic:
- After data has propagated through all rows, each column's final output is collected:
   - A `data_col_sel` signal is constructed by collecting the output data from each column in the last row of the array. For each column, the module takes the `data_out` of the `event_storage` cell at row `NS_ROWS - 1` and column `col`. These outputs are concatenated from **left to right** in **increasing column index order**, meaning **column 0 goes into the most significant bits**, and **column `NS_COLS - 1` goes into the least significant bits**. This signal is then connected to the input of the `column_selector` module.
      - For example, if `NS_COLS = 4` and `NBW_STR = 8`, then `data_col_sel` is 32 bits wide. The output from column 0 goes into bits `[31:24]`, column 1 into `[23:16]`, column 2 into `[15:8]`, and column 3 into `[7:0]`.

- The `column_selector` submodule then selects one column based on `i_col_sel` to produce the module's final output `o_data`.

### Prompt 90 ###
I have a `fixed_priority_arbiter` module available in the `rtl` directory, and its specification is located in the `docs` directory. Kindly modify the module by adding SystemVerilog assertions to ensure the arbiter operates according to fixed-priority arbitration rules.

## Assertion Details

The assertions should verify the following conditions:

### 1. Single Grant Validity  
- Ensure that when a grant is valid (`valid == 1`), **only one bit** in the `grant` signal is high.  
- This enforces a **one-hot grant encoding** policy.

### 2. Priority-Based Arbitration  
- When `priority_override` is not asserted (i.e., `priority_override == 8'b0`), the `grant` signal must correspond to the **lowest-indexed active request** in the `req` signal.  
- This ensures fixed-priority arbitration from `req[0]` (highest) to `req[7]` (lowest).

### 3. Priority Override Enforcement  
- When `priority_override` is asserted (non-zero), the arbiter must **honor the override** and grant only the overridden request, **regardless of `req`**.

### 4. Correct Grant Index Encoding  
- The `grant_index` output must always reflect the **bit position** of the active `grant` line, encoded as a **3-bit binary number**.

---

## Expected Behavior on Assertion Failure

If any of the above assertions fail, the simulation should generate a clear and descriptive error message, such as:

- Assertion Failed: More than one grant active when valid = 1.
- Assertion Failed: Grant does not match request with no override.
- Assertion Failed: Priority override is asserted but grant does not match.
- Assertion Failed: grant_index does not match the granted bit.

---

### Prompt 91 ###
Modify the fixed_priority_arbiter module(`rtl/fixed_priority_arbiter.sv`) to support Active Grant Tracking, Manual Clear, and Enable Control.

## Functional Enhancements

1. **Enable Control**
   - Add a new input `enable`.
   - Arbitration logic must only operate when `enable` is high.
   - If `enable` is low, the outputs must retain their previous values.

2. **Manual Clear**
   - Add a new input `clear`.
   - When `clear` is asserted, all outputs (`grant`, `valid`, `grant_index`, and `active_grant`) must reset to their default values, similar to `reset`.

3. **Active Grant Tracking**
   - Add a new output `active_grant`.
   - This must reflect the current granted request index in binary format, even during priority override.

## Modified Interface

### Inputs
- `enable`: Arbiter enable control  
- `clear`: Manual clear control  

### Outputs
- `active_grant[2:0]`: Reflects the currently granted request index

---

### Prompt 92 ###
I have a specification for a `fixed_priority_arbiter` module in the docs directory and a testbench that only generates a stimulus for that design. Modify the System Verilog testbench `fixed_priority_arbiter_tb.sv` in the verif directory to verify the results of the design in the `fixed_priority_arbiter` module.

### Add the following in the generated testbench:

**Add logic to verify the correctness of the outputs**
For each test case, compare the `grant`, `grant_index`, and `valid` outputs with the expected values based on the `req` and `priority_override` inputs.

**Enhance the existing `run_test` task**
Modify the task to:
- Check if the `grant` output is **one-hot encoded**.
- Ensure that `grant_index` matches the granted bit position.
- Validate that `valid` is asserted only when a request or override is active.

**Print meaningful test result messages**
- Display a **"PASS"** message for each successful test case.
- Display a **"FAIL"** message with detailed debug output if the outputs do not match expectations.
- Use `$error` to exit the simulation immediately on failure.

**Include reset behavior validation**
- After reset, confirm that all outputs (`grant`, `grant_index`, `valid`) are cleared to zero.

### Prompt 93 ###
Design a cryptographic accelerator that performs RSA-like encryption operations, details of which are given in the specification provided in the `docs` folder.
The required RTL files are present in the `rtl` folder, and their corresponding specifications are in the `docs` directory. Choose the appropriate RTL modules based on the descriptions given in the RTL specification documents, and create the System Verilog RTL module `crypto_accelerator` and add it to the `rtl` directory.
Use the existing module that calculates the GCD using Stein's algorithm (as described in the specification) to perform the check for coprimes. If the public exponent (e) and totient φ(n) are coprimes, then perform the encryption using the module that performs modular exponentiation of the inputs.

The existing modular_exponentiation provides incorrect output. Resolve the RTL issues in the module and update it.

Below is the port list of the `crypto_accelerator` module that you have to generate:
```verilog
module crypto_accelerator #(
    parameter WIDTH = 8
)(
    input                     clk,
    input                     rst,
    input      [WIDTH-1:0]    candidate_e,     // Candidate public exponent.
    input      [WIDTH-1:0]    totient,             // Euler's totient φ(n).
    input                     start_key_check,
    output logic              key_valid,
    output logic              done_key_check,
    input      [WIDTH-1:0]    plaintext,
    input      [WIDTH-1:0]    modulus,
    output logic [WIDTH-1:0]  ciphertext,
    output logic              done_encryption
);
```

### Prompt 94 ###
Design a hierarchical **HDBN Encoder/Decoder module** in SystemVerilog according to the provided specification in `docs/specification.md`. The design should consist of a top-level module named **`hdbn_top`**, which instantiates two submodules: **`hdbn_encoder`** and **`hdbn_decoder`**. Ensure your implementation adheres strictly to the specification, including:

- Parameterized selection between HDB3 and HDB2 encoding (`encoder_type`).
- Configurable pulse active state (`pulse_active_state`).

The encoder module (`hdbn_encoder`) must:

- Register input digital data and encode it into bipolar pulses (`P` and `N`).
- Implement zero-counting logic to insert violations, preventing DC bias.
- Alternate pulse polarity correctly, considering violation conditions.

The decoder module (`hdbn_decoder`) must:

- Register incoming bipolar pulse inputs (`P` and `N`).
- Decode the bipolar pulses back into digital data.
- Detect and indicate encoding errors, including violations, simultaneous pulses, and excessive consecutive zeros.

### Prompt 95 ###
The `hdbn_top` module's specification document is in the `docs/specification.md` folder. Write a SystemVerilog testbench, `tb_hdbn_top.sv`, in the `verif` directory to only generate stimulus for the `hdbn_top` module to achieve maximum coverage of the UUT.

Include the following in the generated testbench:

### 1. **Module Instance**  
The `hdbn_top` module should be instantiated as **uut**, with the input and output signals connected for testing.

### 2. **Input Generation**  
The testbench must generate diverse and comprehensive input patterns to drive the encoder and decoder paths:

- Pseudorandom PRBS streams and deterministic sequences, including edge cases like long runs of zeros and alternating bits.
- Clock enable gating and reset sequences that simulate real-world startup and active operation.
- Error injection can be controlled by the `inject_error` flag, introduced after a specified startup delay.
- Optional inversion of polarity between encoder and decoder.

### Prompt 96 ###
I have the below submodules in the `rtl/` directory that together implement a dynamic, frequency-calibrated audio processing system based on Helmholtz resonance principles:

- `helmholtz_resonator`: Performs band-pass filtering with internal automatic calibration logic that adjusts resonance frequency to match a target input frequency using a feedback loop. The `calibrate` input initiates calibration, and `cal_done` indicates when it is complete.
- `modulator`: Generates a modulation waveform that varies the target frequency dynamically over time.
- `soft_clipper`: Applies non-linear soft-clipping to the processed output signal to prevent overflow and simulate analog saturation.
- `resonator_bank`: Instantiates three `helmholtz_resonator` submodules (low, mid, high bands) and manages their calibration and output mixing.
- `helmholtz_top_module`: Serves as the full system integration point, combining modulation, frequency-calibrated filtering, and output shaping.

The specification for the system’s top-level interface is defined in `docs/Helmholtz_Audio_Spec.md`. Follow this spec precisely when defining ports, calibration signals, modulation behavior, and audio path integration.

The final top-level module `helmholtz_top_module` should:

1. **Integrate all submodules** with appropriate signal routing per the specification.
2. **Support automatic calibration** for each of the three internal resonators in `resonator_bank`, which must report completion via `cal_done_flags`.
3. **Drive target frequencies** per resonator using the base frequency input plus modulation offsets.
4. **Conditionally enable modulation** of the base frequency using the `modulator` when `mod_enable` is high.
5. **Pass the filtered audio signal** through the `soft_clipper` for final shaping.
6. **Expose all control and status ports**, including:
   - `calibrate` (start calibration)
   - `cal_done_flags` (per-band calibration completion)
   - `audio_in`, `audio_out`
   - `base_freq`, `q_factor`, and `mod_enable`
7. **Support fixed-point signed audio processing ** parameterized with [15:0] 16-bit width and [7:0] 8-bit fractional resolution internally.

---

###  Testbench Requirement

In addition to creating the `helmholtz_top_module`, develop a **SystemVerilog testbench** named `tb.sv` that:

- Instantiates `helmholtz_top_module` and applies a range of input signals for functional testing.
- Initializes system clock and reset.
- Drives multiple audio test patterns into `audio_in`, including:
  - Constant tones
  - Amplitude modulation (AM)
  - Silence (zero input)
  - Fast waveform transitions
- Asserts `calibrate` and waits for all `cal_done_flags` to be set, verifying calibration behavior.
- Toggles `mod_enable` to test with and without modulation.
- Monitors `audio_out` and ensures it stays within expected limits (i.e., clipped properly).
- Includes at least:
  - One **modulated calibration test**
  - One **static tone test** (no modulation)
  - One **zero-input pass-through test**
- Logs `cal_done_flags`, frequency settings, and audio output results for analysis.
- Optionally introduces edge-case conditions:
  - Minimum and maximum values for `base_freq` and `q_factor`
  - Rapid toggling of `calibrate` and `mod_enable`
  - Observes soft-clipper limits on high-amplitude input

Implement the top module in a single file named `tb.sv` and the associated testbench in `tb_helmholtz_top.sv. ' Ensure all behaviors comply with the provided spec and are verified via simulation.

---

### Prompt 97 ###
The specification document for the `helmholtz_top_module` is present in the `docs` folder. Write a SystemVerilog testbench, `helmholtz_top_module_tb.sv`, in the `verif` directory to only generate stimulus for the `helmholtz_top_module` to achieve maximum coverage of the DUT.

Include the following in the generated testbench:

### 1. **Module Instance**:
The `helmholtz_top_module` should be instantiated as `dut`, with all input and output ports properly connected.

### 2. **Input Generation**:
The testbench must generate a comprehensive range of stimuli for all inputs:
- Signed `audio_in` values, including edge cases (`0`, `±32767`, alternating polarity)
- A sweep and random values for `base_freq` and `q_factor` across their entire valid range
- Control signal combinations:
  - `calibrate` = `0`/`1`
  - `mod_enable` = `0`/`1`
  - Rapid toggling and corner case behavior (e.g., toggling mid-operation)
- Include sine wave approximations and burst stimulus for realistic input simulation

### 3. **Computation Period**:
After applying a stimulus input set, the testbench should wait a sufficient number of cycles for the pipeline and FSMs to settle. During this time:
- Display the `cal_done_flags` and `audio_out` outputs
- Ensure at least 8–12 clock cycles pass before applying the next set of inputs
- Ensure inputs are only changed when the design is not in reset or calibration unless intentionally testing those conditions

### 4. **Logging**:
The testbench must include `$display` statements that log the input values and relevant control signals for every test cycle to assist with waveform analysis and debugging.

---

### Prompt 98 ###
We currently have a SystemVerilog testbench `image_stego_tb.sv` in the `verif` directory that provides stimulus for the `image_stego` module. The design specification of `image_stego` is outlined in the `docs` directory. We want to enhance this testbench to not only generate stimuli but also verify the DUT (Device Under Test) outputs against expected results. This will improve our confidence in the design by providing pass/fail checks.

**Goal**  
1. Implement checker logic in the testbench to compare DUT outputs (`img_out` and `data_out`) with expected results for each test scenario.  
2. Add a method to compute the expected output based on `img_in`, `data_in`, `bpp`, and `key` for all supported modes (0 through 7).  
3. Integrate systematic coverage to ensure various combinations of inputs are tested and verified.  
4. Expand the testbench with additional sequences and tasks to enhance coverage (e.g., random tests, reset checks, hold conditions, etc.).  
5. Maintain a fail counter to track any mismatches; the testbench should exit with a non-zero code if mismatches are found.

---

## Required Additions

1. **Task/Function to Compute Expected Outputs**  
   - Create a `compute_expected` task (or function) that takes in `img_in`, `data_in`, `mode`, `bpp`, and `key`.
   - Within this task/function, implement logic to determine the expected `img_out` and `data_out`. For example:
     - For mode `3'd0`, embed bits from `data_in` into `img_in` based on `bpp`.
     - For mode `3'd1`, extract bits from `img_in` into `data_out`.
     - For other modes (`3'd2` through `3'd5`), implement bitwise operations (e.g., inversion, XOR with key, addition with saturation, rotations) on `img_in`.
     - Set any unused or irrelevant outputs to 0.

2. **Checker Logic**  
   - After each transaction (once `done` is asserted), compare the DUT output (`img_out`, `data_out`) to the expected output from the `compute_expected` task/function.
   - Print a “PASS” or “FAIL” message for each comparison.
   - Maintain a counter (`fail_count` or similar) to track the number of mismatches.

3. **Enhance Existing Tasks**  
   - In tasks like `drive_inputs`, `drive_inputs_hold`, and others, invoke the `compute_expected` task after the DUT completes processing (i.e., after `done` is high).  
   - Use the generated expected values to verify the actual DUT output, logging the result.

4. **Systematic and Random Coverage**  
   - Include loops for random stimulus generation (e.g., random `mode`, `bpp`, `key`, etc.).  
   - Introduce systematic iteration through all `mode` values (0–7) combined with multiple `bpp` values (0–7).  
   - Insert debug information or `$display` statements where beneficial, showing each combination of inputs.

5. **Reset and Corner Cases**  
   - Test asynchronous or synchronous resets to confirm that `img_out` and `data_out` are driven to known states after reset.  
   - Keep the existing tasks like `drive_inputs_reset` and add checks to confirm correct reset behavior.

6. **Final Pass/Fail Summary**  
   - At the end of the simulation, if `fail_count` is non-zero, exit using `$fatal(1)` or a suitable mechanism to indicate failure.  
   - Otherwise, log that all tests have passed and terminate cleanly.

---

### Prompt 99 ###
I have a `top_inv_manchester_codec` module available in the `rtl` directory. Kindly modify the module by adding concurrent SystemVerilog assertions. These assertions should display error messages when the following signal conditions are violated during simulation:

**Assertions to Implement:**
1. Verify that the encoder valid output (`enc_valid_out`) is asserted only if the encoder input valid (`enc_valid_in`) was asserted in the previous clock cycle.
2. Verify that the decoder valid output (`dec_valid_out`) is asserted only if the decoder input valid (`dec_valid_in`) was asserted in the previous clock cycle.
3. Ensure that all outputs (`enc_data_out`, `dec_data_out`, `enc_valid_out`, and `dec_valid_out`) are zeroed when both encoder and decoder inputs (`enc_valid_in`, `dec_valid_in`) are invalid.

#### **Module Interface Details:**
- **Parameters:**
  - `N` (default = 16): Width of the input and output data.
  
- **Input Ports:**
  - `clk_in`: Positive-Edge triggered Clock input.
  - `rst_in`: Active high Asynchronous reset input.
  - `enc_valid_in`: Active HIGH Valid signal for encoder input.
  - `enc_data_in[N-1:0]`: N-bit input data for encoding.
  - `dec_valid_in`: Active HIGH Valid signal for decoder input.
  - `dec_data_in[2*N-1:0]`: 2*N-bit input data for decoding.

- **Output Ports:**
  - `enc_valid_out`: Active HIGH Valid signal for encoder output.
  - `enc_data_out[2*N-1:0]`: 2*N-bit encoded output data.
  - `dec_valid_out`: Active HIGH Valid signal for decoder output.
  - `dec_data_out[N-1:0]`: N-bit decoded output data.

#### **Functionality:**
- The module performs inverse Manchester encoding and decoding.
- **Encoder:**
  - When `enc_valid_in` is high, the module encodes the input `enc_data_in` into `enc_data_out` using the inverse Manchester encoding scheme.
  - Each bit of `enc_data_in` is encoded into 2 bits in `enc_data_out`:
    - `0` is encoded as `01`.
    - `1` is encoded as `10`.
- **Decoder:**
  - When `dec_valid_in` is high, the module decodes the input `dec_data_in` into `dec_data_out` using the inverse Manchester decoding scheme.
  - Each 2-bit pair in `dec_data_in` is decoded into a single bit in `dec_data_out`:
    - `01` is decoded as `0`.
    - `10` is decoded as `1`.
    - Any invalid pair (e.g., `00` or `11`) is decoded as `0`.

### Prompt 100 ###
Integrate a JPEG run-length encoder consisting of a **run-length stage module (`jpeg_runlength_stage1`)** and a **zero-run suppression module (`jpeg_runlength_rzs`)**, and implement a top-level pipelined encoder at **`rtl/jpeg_runlength_enc.sv`**. The design must follow the JPEG compression protocol and stream over 8×8 DCT coefficient blocks. All module behavior must strictly conform to the design rules and compression behavior defined in **`docs/specification.md`**.

Use the following steps for module integration:

- Implement the **run-length stage** in `rtl/jpeg_runlength_stage1.sv` and **zero-run suppression stage** in `rtl/jpeg_runlength_rzs.sv`.
  - Run-length encoding stage module must detect and distinguish between DC and AC terms, maintain a sample counter for 8×8 block traversal, track zero run-lengths, compute coefficient category (bit size), format the amplitude accordingly, and assert valid output and DC indicators for downstream processing.
  - Zero-run suppression stage module must suppress repeated zero-blocks (run-length = 15, size = 0) using a compact FSM, emit an End-of-Block (EOB) marker when applicable, and ensure proper sequencing of run-length, size, amplitude, and control signals through the pipeline.

- Integrate the full encoding pipeline in the top-level module at `rtl/jpeg_runlength_enc.sv`, connecting the stage-1 run-length encoder(`jpeg_runlength_stage1`) to **four cascaded zero-run suppression stages(`jpeg_runlength_rzs`)**. The top-level module must manage pipeline control (clock/reset/enable), accept incoming 12-bit DCT data, and emit the final encoded run-length, size, amplitude, and control flags with full JPEG compliance.

### Prompt 101 ###
Enhance the design by incorporating SystemVerilog Assertions (SVA) to ensure robust verification of internal control, functional behavior in the `jpeg_runlength_enc` module. The project, located in the **rtl** directory, implements a hierarchical JPEG Run-Length Encoding scheme consisting of three interrelated modules:

- **jpeg_runlength_enc** (Top‑Level Interface & Pipeline Integration)  
  This module is the central integration block that connects the processing pipeline stages. It instantiates:
  - **jpeg_runlength_stage1** – the encoding stage responsible for:
    - Separating DC from AC coefficients.
    - Calculating run‑length for AC coefficients.
    - Determining coefficient size (category) and adjusting amplitude.
    - Generating the control flag (`dcterm_out`) when processing the DC term.
  - **jpeg_runlength_rzs** – the zero‑run suppression stage used in multiple instances (stages 2–5) to:
    - Detect complete zero‑blocks from the input signals.
    - Suppress the output enable (`den_out`) when required.
    - Propagate data through pipeline registers while ensuring signal timing and integrity.
    - Manage state transitions between zero‑suppression and normal operation via an internal state machine.
 
### Assertion Requirements

Please implement SVA  to check that the design module `jpeg_runlength_enc` satisfies the following functional and safety properties:

1. **Pipeline Delay Consistency**  
   - In **jpeg_runlength_enc**, the `douten_out` signal must follow the assertion of `dstrb_in` after a defined pipeline delay.  

2. **Block Start Validity**  
   - When `bstart_out` is high, the output valid signal (`douten_out`) must also be asserted, and the run‑length output (`rlen_out`) must equal 0, indicating a proper block start.

3. **DC Marker Uniqueness**  
   - Ensure that the DC marker (originating from `stage1_dc` in **jpeg_runlength_enc**) is asserted only once per block. Once the DC term is issued, it must not be repeated until a new block begins.

4. **Valid Data Output Integrity**  
   - Whenever `douten_out` is high, the corresponding encoded outputs (`rlen_out`, `size_out`, and `amp_out`) must carry valid data. At least one bit of `amp_out` should be set for non-DC data, and for DC terms, `rlen_out` must be 0.

### Expected Behavior

- The assertion properties must be placed in a separate module named `jpeg_run_length_assertion_check` in the `verif` directory, which instantiates the `jpeg_runlength_enc` module as the Device Under Test (DUT).
- The properties must reference internal DUT signals directly for verification purposes.

### Notes

- All assertions must use **SystemVerilog Assertions (SVA)** syntax.
- Create the new **verif** directory file (`jpeg_run_length_assertion_check.sv`)  that should have these assertions implemented.

### Prompt 102 ###
I have a **Linear Feedback Shift Register (LFSR) module** at `rtl/lfsr_8bit.sv` and a **test bench** at `verif/lfsr_8bit.sv`. The testbench simulation shows **errors**, resulting in a test failure.

## Module Specifications

### RTL (rtl/lfsr_8bit.sv)
The **8-bit LFSR module** has the following characteristics:

#### Inputs:
- `clk`: Clock signal  
- `rst`: Reset signal (active high)  
- `seed`: 8-bit **user-defined initial seed**

#### Output:
- `lfsr_out`: 8-bit **LFSR output**

#### Internal Logic:
- On **reset**, the LFSR is initialized with the user-defined **seed** value.
- The feedback is generated using the polynomial:
```verilog
  lfsr_out = {lfsr_out[6:0], lfsr_out[7] ^ lfsr_out[5] ^ lfsr_out[4] ^ lfsr_out[3]};
```
- On every **clock edge**, the LFSR shifts and updates its state.

### Testbench (verif/lfsr_8bit.sv)
The testbench is designed to validate the correctness of the LFSR module.

#### Clock Generation
- A **10ns clock period** (`#5 clk = ~clk;`)

#### Stimulus and Self-Checking
- **Initialization**
- The LFSR is initialized with the **seed** (`8'b10101010`) on reset.
- **Functional Test**
- Runs the LFSR for **20 cycles**, updating an expected **shift register** with the same feedback polynomial.
- Compares `lfsr_out` against `expected_lfsr`.
- **Error Checking**
- If the expected and actual outputs **do not match**, it prints an error message:
  ```verilog
  $error("ERROR at cycle %d: Expected %b, Got %b", i, shift_reg, lfsr_out);
  ```

#### Waveform Dumping
- Creates a waveform dump (`lfsr_8bit.vcd`) for debugging.

## Issue Observed
The testbench simulation **reports mismatches** between the expected and actual LFSR outputs.  

Could you help debug and fix the RTL to ensure the LFSR operates correctly?

### Prompt 103 ###
The `bit16_lfsr` module is designed to generate pseudo-random 16-bit sequences under Galois configuration, following the primitive polynomial x<sup>16</sup>+x<sup>5</sup>+x<sup>4</sup>+x<sup>3</sup>+1. However, during testing, it was observed that the module fails to generate valid pseudo-random sequences and exhibits incorrect behavior for certain bits, resulting in incomplete sequences and compromising the expected functionality of the module.

Below is a table showing the expected values and the actual values for the lfsr_8bit module:

| Clock Cycle                | Input Seed | Expected Value | Actual Value |
|----------------------------|------------|----------------|--------------|
| Clock cycle = 1, reset = 0 | FFFF       | FFFF           | FFFF         |
| Clock cycle = 2, reset = 1 | FFFF       | 5555           | D555         |
| Clock cycle = 3, reset = 1 | FFFF       | 2AAA           | EAAA         |
| Clock cycle = 4, reset = 1 | FFFF       | 1555           | F555         |
| Clock cycle = 5, reset = 1 | FFFF       | 0AAA           | FAAA         |

Identify and Fix the RTL Bug to Ensure Correct LFSR Behavior.

### Prompt 104 ###
I have a documentation `docs/8Bit_lfsr_spec.md` for the `lfsr_8bit` module. Write a SystemVerilog testbench `tb_lfsr_8bit.sv` in the verif directory that generates stimulus to thoroughly test and achieve maximum functional coverage for the `lfsr_8bit` module.
___
### The interface of `lfsr_8bit` RTL module is given below:

### **Inputs:**
   - `clk`: Clock signal for synchronous operation, design works on Positive edge of clock.
   - `reset`: Asynchronous active-low reset signal.
   - `lfsr_seed [7:0]`: A 8-bit register providing the initial seed value to the LFSR.
   - `sel`: A 1-bit signal selecting the operation type (`NAND = 1`, `NOR = 0`).
   - `dir`: A 1-bit signal indicating the direction of the shift (`0 = LSB to MSB`, `1 = MSB to LSB`).
   - `weight [2:0]`: A 3-bit control signal specifying the weight of the feedback logic.
 
### **Outputs:**
   - `lfsr_new [7:0]`: A 8-bit wire representing the LFSR's output after feedback and shifting.
___
### Input Generation and Validation
**Input Generation:**
  1. Random Input Generation:
     - Randomly generate seed values (`lfsr_seed`) to test various initial states of the LFSR.
     - Vary `weight` from 0 to 7 to test feedback logic across all configurations.
     - Randomize `sel` and `dir` to verify behavior for NAND/NOR operations and both shift directions.

  2. Parameterized Testing:
     - Cover cases for all combinations of `sel` (`NAND/NOR`) and `dir` (`LSB to MSB/MSB to LSB`).
     - Include scenarios for:
       - Minimum weight (`weight = 0`).
       - Maximum weight (`weight = 7`).
       - Boundary weight values like `weight = 1`, `weight = 7`.

  3. Edge Cases:
     - Reset Behavior:
       - Assert reset as logic LOW to apply seed value to the LFSR.
     - No Shift (`weight = 0`):
       - Apply `weight` input as logic LOW to test the status of `lfsr_new` 
     - Maximum Weight:
       - Test heavily weighted feedback logic (e.g., `weight = 7`) for both `NAND` and `NOR` operations.
     - Alternating Feedback:
       - Test with patterns that toggle bits in a predictable way to verify correct feedback propagation.

___

### **Instantiation**
Name the instance of the RTL as `uut`.

### **Module Functionality:**

  - Feedback Logic:
    - Compute feedback using weighted `NOR` or `NAND` operations based on the `sel` signal.
    - Support direction control (`LSB to MSB` or `MSB to LSB`) for shift and feedback propagation.
  - Shift Logic:
    - Propagate bits according to the selected direction.
    - Inject feedback into the appropriate end of the register.

### Prompt 105 ###
I need to implement a **low-power communication channel** that efficiently manages **data transfer, wakeup control, and Q-channel handshaking**. The **`low_power_channel.sv`** module needs to integrate a **synchronous FIFO (`sync_fifo.sv`) for buffering writes** and a **control unit (`low_power_ctrl.sv`) for managing data flow and power states**. The system should properly handle **FIFO overflow/underflow, wakeup signals, and flush operations** while ensuring minimal power consumption.  

I have the **FIFO module at `/code/rtl/sync_fifo.sv`** and the **control unit at `/code/rtl/low_power_ctrl.sv`**, and I need to create the **top-level module `/code/rtl/low_power_channel.sv`** that correctly integrates them. The module should **instantiate and connect the FIFO and control logic**, implement **Q-channel signaling (`qreqn`, `qacceptn`, `qactive`)**, and handle **read/write transactions** efficiently. To verify functionality, a testbench is available at **`/code/verif/tb_low_power_channel.sv`**. The final implementation should ensure **proper synchronization, low-latency operation, and power efficiency**

### Prompt 106 ###
I have a memory scheduler module `memory_scheduler.sv` available in the rtl directory. Please modify the module by adding SystemVerilog Assertions (SVA) to check its internal functionality comprehensively. The assertions should verify the following conditions:

**1. Reset Initialization (reset_initialization)**:
Ensure that all internal registers and outputs are correctly initialized when the reset signal is asserted (active high). In particular, it shouldcheck that:

`current_priority` is set to 2'b11.

`round_robin_index` is set to 2'b00.

`mem_cmd_valid` is deasserted (0).

`grant` is reset to 4'b0000.

`mem_address` is reset to 32'd0.

`mem_cmd_type` is set to 2'b00.

**2. No Request, No Command (no_request_no_cmd)**:
Ensures that if no request is active (i.e., all bits in the request vector are 0), then the scheduler does not issue any command. It requires that when no request is present, both `mem_cmd_valid` remains low and `grant` is 4'b0000.

**3. One-Hot Grant in Priority Mode (one_hot_grant_priority)**:
Ensure that if, in the previous cycle, any request channel’s QoS matches the previous cycle’s current_priority, then in the current cycle the scheduler must produce a valid memory command (`mem_cmd_valid` asserted) with a one-hot encoded grant. It ensures that only one request (the highest-priority one in the combinational search) is granted.

**4. One-Hot Grant Output (one_hot_grant)**:
Ensure that whenever `mem_cmd_valid` is asserted and the grant is nonzero, the grant output is one-hot. In other words, if a command is active, exactly one bit in the grant vector must be high.

**5. Memory Address Mapping (mem_address_mapping)**:
Ensure that when a memory command is active, the output memory address (`mem_address`) correctly corresponds to the granted request. For example, if the grant equals 4'b0001, then mem_address should equal address 0; if 4'b0010, then it should equal address 1; and so on for channels 2 and 3.

**6. Fixed Memory Command Type (mem_cmd_type_fixed)**:
Ensure that whenever a memory command is valid (`mem_cmd_valid` is asserted), the memory command type (`mem_cmd_type`) remains fixed at 2'b00. This is a constant design attribute.

**7. Valid Next Granted Request (valid_next_granted_request)**:
This property should check the combinational logic output `next_granted_request`. It asserts that the value is either zero (indicating no valid request is granted) or it is a valid one-hot encoded value (exactly one bit set). This helps verify that the scheduler’s internal grant computation is correct.

**8. Valid Request When Command (valid_request_when_cmd)**:
Verify that if a memory command is issued (i.e., `mem_cmd_valid` is asserted), then there must be at least one active request in the request vector. In other words, the scheduler should never produce a command when no request is active.

**9. No Priority Match Implies Next Grant Equals Temp (no_prio_implies_next_grant_equals_temp)**:
Ensure that when no request matches the current priority (i.e., `local_found_prio` is 0), the computed `next_granted_request` must equal `temp_granted`. This confirms that the scheduler uses the round-robin branch’s computed grant when no priority match is found.

**10. Local Found RR Flag Set When Request Active (local_found_rr_if_request)**:
Ensure that if no priority match is found (i.e., `local_found_prio is 0`) and at least one request is active, then the round-robin flag (`local_found_rr`) must be asserted (set to 1). This ensures that the round-robin mechanism is correctly triggered when priority-based selection fails.

If any of these conditions are violated during simulation, an appropriate error message should be displayed.

### Prompt 107 ###
The `monte_carlo_dsp_monitor_top` module is a cross-clock-domain data monitor designed to apply randomized transformations to incoming data samples using LFSRs, synchronize data safely across domains, and output processed results while tracking cross-domain transfers.

####  Functional Overview:

- **Input Processing:**
  The module receives a stream of samples on `clk_a`. Each valid sample is masked with a pseudo-random sequence generated by an LFSR. This randomized data is prepared for transfer to the output domain.

- **Cross-Domain Synchronization:**
  The masked input data and valid signal are transferred across to the `clk_b` domain using a synchronization mechanism intended to safely cross clock domains.

- **Output Transformation and Monitoring:**
  On the output domain (`clk_b`), another LFSR-generated mask is applied to further scramble the incoming data. The output is marked valid, and an internal counter (`cross_domain_transfer_count`) is incremented to track the number of valid samples that successfully traversed the clock boundary.

The `rtl` directory should have the following files.
- `cross_domain_sync.sv`
- `dsp_input_stage.sv`
- `dsp_output_stage.sv`
- `lfsr_generator.sv`
- `monte_carlo_dsp_monitor_top.sv`

---

### **Test Case Details – monte_carlo_dsp_monitor_top**

---

#### **1. Static Patterns**
- **Test Scenario**: Apply well-known fixed patterns (all-zero, all-one, alternating bits) to verify masking and data transfer integrity across the clock domain.
- **Observed Failures**: Randomized output doesn’t match expected masking for known patterns. Output count mismatch also observed in some buggy RTL cases.

| **Cycle** | **Input (`data_in_a`)** | **`valid_in_a`** | **Expected Randomized Masked Output** | **Actual (`data_out_b`)** |
|-----------|-------------------------|------------------|---------------------------------------|---------------------------|
| 1         | `0x0000`                | `1`              | LFSR_A XOR `0x0000`                   | `0xBCDE`                  |
| 2         | `0xFFFF`                | `1`              | LFSR_A XOR `0xFFFF`                   | `0x4321`                  |
| 3         | `0xAAAA`                | `1`              | LFSR_A XOR `0xAAAA`                   | `0xBABA`                  |
| 4         | `0x5555`                | `1`              | LFSR_A XOR `0x5555`                   | `0xEFEF`                  |

---

#### **2. Random Burst Sequences**
- **Test Scenario**: Apply 40+ random valid samples at `clk_a` to verify consistent valid transfer, correct LFSR masking, and synchronized delivery at `clk_b`.
- **Observed Failures**: `cross_domain_transfer_count` does not match `valid_out_b` count in buggy RTL. Some samples are lost or duplicated due to `valid_src` synchronization bug.

| **Cycle** | **Input (`data_in_a`)** | **`valid_in_a`** | **Expected Transfer** | **Received (`data_out_b`)** |
|-----------|-------------------------|------------------|-----------------------|-----------------------------|
| 5         | `0x3A9F`                | `1`              | Masked & Transferred  | `0x3A9F`                    |
| 6         | `0x7E3C`                | `1`              | Masked & Transferred  | *Missing*                   |
| 7         | `0x4B21`                | `1`              | Masked & Transferred  | `0x1122`                    |
| 8         | `0x0011`                | `1`              | Masked & Transferred  | `0xFFEE`                    |


---

#### **3. Toggle Validity**
- **Test Scenario**: Alternate the `valid_in_a` signal every other cycle to test CDC handling, backpressure, and masking logic consistency.
- **Observed Failures**: When `valid_in_a` is `0`, input is still masked and latched due to bug in `dsp_input_stage`. Junk data seen in `data_out_b`.

| **Cycle** | **Input (`data_in_a`)** | **`valid_in_a`** | **Expected**         | **Actual (`data_out_b`)** |
|-----------|-------------------------|------------------|----------------------|---------------------------|
| 9         | `0xAAAA`                | `1`              | Transferred (masked) | `0x0000`                  |
| 10        | `0xBBBB`                | `0`              | No transfer          | `0x1234`                  |
| 11        | `0xCCCC`                | `1`              | Transferred (masked) | `0xABCD`                  |
| 12        | `0xDDDD`                | `0`              | No transfer          | `0x7777`                  |

---

#### **4. Output Counter Integrity**
- **Test Scenario**: Ensure that `cross_domain_transfer_count` increments only on valid transfers, matching the actual number of `valid_out_b` assertions.
- **Observed Failures**: In buggy RTL, `transfer_count` increments on every clock edge, regardless of `valid_in`.

| **Metric**                    | **Expected `transfer_count`** | **Actual `transfer_count`** |
|-------------------------------|-------------------------------|-----------------------------|
| Valid inputs sent             | > 100                         | 102                         |
| `valid_out_b` assertions      | 102                           | 94                          |
| `cross_domain_transfer_count` | 102                           | 150                         |

---

#### **5. LFSR Pattern Validation**
- **Test Scenario**: Apply known seed and verify pseudo-random patterns generated by `lfsr_generator`.
- **Observed Failures**: LFSR produces repeating or invalid sequences. Indicates incorrect tap configuration.

| **Cycle** | **LFSR Seed (A)** | **Expected LFSR Output** | **Actual LFSR Output** |
|-----------|-------------------|--------------------------|------------------------|
| 1         | `0xACE1`          | `0x5790`                 | `0x5790`               |
| 2         | `0x5790`          | `0x2BC8`                 | `0x5790`               |
| 3         | `0x2BC8`          | `0x15E4`                 | `0x2BC8`               |

---

###  **Testbench for Validation**

A comprehensive SystemVerilog testbench is provided in `verif/monte_carlo_dsp_monitor_top_tb.sv` that systematically targets the aforementioned issues through a variety of stimulus patterns.

####  **Validation Strategy**

The testbench includes over **100 stimulus patterns** including:

- **Static Patterns:** All-zeros, all-ones, and alternating bit patterns
- **One-Hot and Inverse-One-Hot Tests:** To exercise single-bit toggling
- **Counter Sequences and Wraparound Tests:** To validate correct masking and transfer behavior
- **Random Bursts and Gapped Random Inputs:** To test data stability across domains
- **Delayed Valid Assertion Cases:** To challenge timing correctness
- **Noise-Injection and Slow Ramp-Up Sequences:** To evaluate resilience against data irregularity

---
Please solve the bugs mentioned and make sure to use the testbench to validate your fixes.

### Prompt 108 ###
Design a `multiplexer` module in SystemVerilog within a file `multiplexer.sv` at the location: `rtl/multiplexer.sv`. Refer to the specification provided in `docs/multiplexer_specification.md` and ensure you understand its content. The specification details the functionality of a configurable multiplexer with the following parameters:

- **DATA_WIDTH**: Configurable data width of inputs.
- **NUM_INPUTS**: Number of input channels.
- **REGISTER_OUTPUT**: Option to register the output for pipelining.
- **HAS_DEFAULT**: Determines if a default value is used when `sel` exceeds `NUM_INPUTS`.
- **DEFAULT_VALUE**: The default output value when `HAS_DEFAULT` is enabled.

The module takes a `clk` and `rst_n` signal for synchronous reset behavior. It selects one of the `NUM_INPUTS` data inputs based on `sel`. If `bypass` is high, it forces `out` to always select `inp_array[0]`. The output is either combinational or registered based on `REGISTER_OUTPUT`.

Generate the complete RTL code that implements the `multiplexer` with the described behavior, ensuring that the code is optimized for performance and area efficiency.

### Prompt 109 ###
I have a `multiplexer` module available in the `rtl` directory, and its specification is in the `docs` directory. Kindly modify the module by adding SystemVerilog assertions. The assertions should ensure that the multiplexer logic is accurately implemented for different `sel` values, the optional `bypass` path, and the optional default behavior.

## **Assertion Details**
The assertions should verify the following conditions:
- **Bypass Path:** Confirm that when the `bypass` signal is active, the output is driven by the first input.
- **Selected Input:** Ensure the `sel` signal routes the correct input to the output if `bypass` is disabled.
- **Default Behavior (if enabled):** Check that the default value is output if `sel` is out of range and `HAS_DEFAULT` is true.

## **Expected Behavior**
If any of the assertions fail, they should generate an **error message** pointing to the incorrect behavior in the multiplexer logic.

### Prompt 110 ###
Design an `nbit_swizzling` with binary to gray code conversion module in SystemVerilog. Refer to the specification provided in `docs/nbit_swizzling_spec.md` to implement the RTL. The specification describes a parameterizable module that takes an n-bit input data vector and performs various **reversal** operations on it based on a **2-bit selection signal**. It also requires generating a Gray-coded version of the reversed data. 

**1. Parameterizable Data Width (default 64 bits)**  
   - The module must allow configuring its width for different bit sizes (e.g., 32, 64, 128 bits).  

 **2. 2-bit Selection (`sel`) for Reversal Operation**  
   - `00`: Reverse the entire input data.  
   - `01`: Split the input into two halves and reverse each half.  
   - `10`: Split the input into four quarters and reverse each quarter.  
   - `11`: Split the input into eight segments and reverse each segment.  
   - Any invalid selection should cause a default pass-through (i.e., `data_out` = `data_in`).

 **3. Gray Code Generation**  
   - After the data is reversed (based on the selected mode above), generate a Gray-coded version of the reversed output.

The code should be well-documented with clear comments explaining the functionality of each major block. Follow best practices in SystemVerilog coding to ensure readability, reusability, and maintainability.

### Prompt 111 ###
I have a specification of a `nbit_swizzling` module in the `docs` directory. Write a system verilog testbench `nbit_swizzling_tb.sv` in the verif directory to only generate stimulus and achieve maximum coverage for the `nbit_swizzling` module.

Include the following in the generated testbench:

1. **Module instance:**
    - Instantiate the `nbit_swizzling` module as `dut`.
    - Connect all input and output signals for testing, as described in the specification.

2. **Input generation:**
    - Generate the inputs `data_in` in the range of 0 to 2<sup>`DATA_WIDTH`</sup>-1 and `sel` in the range of 0 to 3.
    
3. **Additional Requirements:**
    - Use the Parameter `DATA_WIDTH` = 16 to generate input stimulus.
    - Test edge cases such as:
        - Random data inputs.
        - unknown value of input sel.

### Prompt 112 ###
I have a specification of a `nbit_swizzling` module in the `docs` directory and a testbench that only generates stimulus for that design. Modify the System Verilog testbench `nbit_swizzling_tb.sv` in the `verif` directory to verify the results of the design in the `nbit_swizzling` module.

Add the following in the generated testbench:

- Add a task to calculate the `calculate_expected_data_out`.
- Add a task to calculate the `calculate_expected_gray_out`.
- Display appropriate messages when there is a pass or fail and incase of a mismatch in the results, exit the simulation with an error.

### Prompt 113 ###
I have an` nmea_decoder` module available in the `rtl` directory and its specification in the `docs` directory. The existing `nmea_decoder` module implements a finite state machine (FSM) that parses NMEA sentences and extracts the first 2-character field after the sentence type $GPRMC.

Modify the code to:

- Add binary conversion logic by extracting numeric characters and converting the 2-character ASCII field to an 8-bit binary output (`data_out_bin`), with a `data_bin_valid` flag.

- Add watchdog timeout detection, enabled via the `watchdog_timeout_en` signal, which asserts `watchdog_timeout` if no carriage return  is received within a configurable cycle window.

- Add buffer overflow detection during sentence parsing. If the internal buffer exceeds its capacity, assert `error_overflow` and reset the parser.

The enhancements introduce robustness and reliability to the parser while retaining its original FSM-driven design. All outputs are updated synchronously and registered.

### Prompt 114 ###
I have a specification of a `nmea_decoder` module in the `docs` directory and a testbench `nmea_decoder_tb.sv` in the `verif` directory that only generates stimulus for the design. Modify the testbench to verify the results of the `nmea_decoder`.

Add the following in the testbench:

- Implement a task `check_result()` to verify the DUT outputs against expected behavior.
    - The task must compare `data_out` with the expected value for each test case.
    - It must check that the `data_valid` signal is high when the data is valid.
    - For each test case, ensure that the output `data_out` matches the expected hexadecimal value and is displayed correctly.

- Modify the existing test sequence to verify expected results after sending the sentence to the DUT.

    - Add appropriate test cases to check for valid sentences, invalid sentences, short fields, and variety checks.
   
- Display appropriate messages when a test passes or fails.
    - For each test, print a message indicating whether the test passed or failed.

**Constraints:**
- The additions to the testbench must focus solely on **verifying DUT outputs** based on known input conditions.

### Prompt 115 ###
Design a `phase_rotation_viterbi` module (`phase_rotation_viterbi.sv`) in **SystemVerilog** that implements **phase estimation and correction** using **fourth-power phase detection**. The module takes complex input samples (**I, Q**) and processes them through a hierarchical pipeline structure, integrating the following submodules `power4`, `saturation`, `phase_lut` and `top_phase_rotation`.
 
Please refer to `docs/spec_viterbi.md` for design requirements and specifications.

### Prompt 116 ###
### `slicer_top` (`slicer_top.sv`)

The **slicer_top** module must be updated with the following changes:

- Introduce a new parameter: **`NBW_OUT`**, which configures the bit width of the output signal of `slicer` module.
- **Remove** the parameter **`NS_TH`**.
- Replace the current threshold interface. The input signal **`i_threshold`** must now be a single **packed signal** with a bit width of **`NBW_TH`**.
- **Remove** the following input signals:
  - `i_sample_0_pos`
  - `i_sample_0_neg`
  - `i_sample_1_neg`
- **Rename** the signal `i_sample_1_pos` to `i_sample_pos`.

#### Parameter Constraint

The parameter **`NBW_OUT`** must be large enough to represent the result of adding two signed values (this ensures proper bit width to handle the signed addition without overflow):
- One using **`NBW_TH`** bits
- One using **`NBW_REF`** bits

---

### `slicer` (`slicer.sv`)

At the module level of **`slicer`**, the **same interface and parameter changes** applied to `slicer_top` must be mirrored:

- Add the **`NBW_OUT`** parameter.
- Remove the **`NS_TH`** parameter.
- Update the input **`i_threshold`** to be a single **packed signal** with bit width **`NBW_TH`**.
- Remove the following signals:
  - `i_sample_0_pos`
  - `i_sample_0_neg`
  - `i_sample_1_neg`
- Rename `i_sample_1_pos` to `i_sample_pos`.

---

### Comparison and Processing Logic

In the **`slicer`** module, all comparisons must rely solely on the updated **`i_threshold`** signal.

- When comparing the input to thresholds, use **`i_threshold`** and its **negated value** to define the positive and negative limits.
- The output signal **`o_data`** must receive a result based on **accumulated sums** of `i_sample_pos` and `i_threshold`, where the **sign of the sample** depends on whether the input value is above or below the defined thresholds.
- Internally, use the unified `i_sample_pos` signal and apply the appropriate **sign (positive or negative)** based on input value comparisons with the threshold.

### Prompt 117 ###
The **top_phase_rotation** module must be updated with the following changes to its interface and internal connections:

#### Interface Modifications

Add the following **4 new 1-bit input signals**:
- `i_bypass`
- `i_en_capture_data`
- `i_en_capture_cos_sin`
- `rst_async_n`

#### Functional Description

- **`i_en_capture_data`**:
  - Acts as a **data-gate** for the input signals `i_data_re` and `i_data_im`.
  - When low, the input data is held (not updated).
  - Introduce **one cycle of latency** for this gated data path.
  - Implement a **reset mechanism** using **`rst_async_n`** (active-low, asynchronous reset) to ensure that gated registers reset to `0`.

- **`i_en_capture_cos_sin`**:
  - This signal must be forwarded to the **`gen_cos_sin_lut`** module (the same input signal should be created on this module interface).
  - The **`gen_cos_sin_lut`** module must be made **sequential**, with a **1-cycle latency**.
  - On reset (`rst_async_n` asserted low), its output values must be cleared to `0`.

- **`rst_async_n`**:
  - Must be connected to the **`phase_rotation`** and **`gen_cos_sin_lut`** modules.
  - Inside those modules, all internal registers must be reset to `0` when `rst_async_n` is low (**asynchronous active-low reset**).
  - The **`rst_async_n`** input signal should be created on blocks interface.

- **`i_bypass`**:
  - Must be connected to the **`phase_rotation`** module (the same input signal should be created on this module interface).
  - Internally, the module must implement **combinational bypass logic**:
    - When `i_bypass == 1'b1`: forward input data directly to the output.
    - When `i_bypass == 1'b0`: perform the normal phase rotation operation.
    - Should be change only once per reset.

### Prompt 118 ###
The original `phase_lut` module has `i_data_i` and `i_data_q` as inputs (each 6 bits wide) and `o_phase` as a 9-bit output. The output is generated based on the inputs, which are used to access an internal lookup table (LUT). For each pair of input values, the module produces an output using a `case` statement that covers all possible input combinations.

The **phase_lut** module must be updated with the following interface and internal behavior:

---

### Interface Modifications

- Add **2 input ports**:

  - A **clock input** for sequential logic: `clk`.
  - An **asynchronous active-low reset input**: `rst_async_n`.

- Add **2 new parameters**:
  - A parameter to define the number of **integer bits** in the input data (fixed value: `1`): `NBI_IN`.
  - A parameter to define the number of **integer bits** in the output phase (fixed value: `1`): `NBI_PHASE`.

- The existing parameters are fixed as:
  - Input width (`NBW_IN`): `6` bits.
  - Output width (`NBW_PHASE`): `9` bits.

---

### Derived Configuration (fixed values)

- The number of **fractional bits** in the inputs is `5`.
- The number of **fractional bits** in the output is `8`.

- The LUT will only store phase values corresponding to the **first quadrant** of the trigonometric circle.

- The LUT must have **1089 entries**, each representing a **normalized approximation of the arctangent function** between two positive fixed-point values.

- This number of entries is derived from all possible combinations of two 5-bit unsigned fractional values (representing the absolute values of the inputs), computed as:

  ```
  LUT_SIZE = 2^(2 × NBF_IN) + 2 × (2^NBF_IN) + 1
           = 2^10 + 2 × 2^5 + 1
           = 1024 + 64 + 1
           = 1089 entries
  ```

- These terms correspond to:
  - All combinations of I and Q: `2^10 = 1024`
  - Horizontal and vertical axis cases: `2 × 2^5 = 64`
  - One special case for zero input: `1`

---

### Combinational Logic

- Determine the **sign** of each input component.
- Compute the **absolute values** of both input components to map the vector into the first quadrant.
- Use a mathematical expression to generate a normalized index from the absolute values. This index must represent all combinations of two unsigned fixed-point numbers with `5` fractional bits each.
- Use this index to access a lookup table that contains **only the first-quadrant phase values**.
- With the signs previously captured, determine the **actual quadrant** of the original vector.
- Based on the quadrant, apply a **mathematical adjustment** to the LUT output:
  - If both components are **positive**, use the LUT value **directly**.
  - If the first component is **positive** and the second is **negative**, output the **negative** of the LUT value.
  - If the first component is **negative** and the second is **positive**, output the **difference between a full-scale constant and the LUT value**.
  - If both components are **negative**, output the **LUT value minus the full-scale constant**.

---

### Sequential Logic

- Register the calculated LUT index.
- Register the sign of each input component.
- On the rising edge of the clock, store these values to be used in the phase adjustment logic.
- On asynchronous reset (active low), all stored values must be cleared to `0`.

---

### LUT Construction

- The LUT must store precomputed values of the **arctangent function**, using only positive unsigned values for both input components.
- Each entry must be **normalized** to match the output format defined by the module parameters.
- The LUT can be generated using a fixed-point representation of the angle between two fractional inputs in the first quadrant.
- By using trigonometric symmetry, the LUT size is significantly reduced, and the output is reconstructed accurately across all four quadrants using simple transformations.

Unable to extract datapoint. Appear to have an binary file as part of the context/solution.

### Prompt 119 ###
I have a **cross_correlation** module that performs complex cross-correlation and energy computation over input I/Q data. This module handles the internal processing logic required for computing correlation with conjugate reference sequences.

Can you implement the top-level module **`detect_sequence`** by integrating the **cross_correlation** module at `detect_sequence.sv`?

The design should be fully parameterizable and support flexible configurations to adapt to different processing requirements. Additional glue logic must be implemented both before and after the instantiation of the **cross_correlation** module to handle input data preparation and output result processing.

Please refer to `docs/spec_detect_sequence.md` for design requirements and specifications.

### Prompt 120 ###
The **detect_sequence** module must be updated with the following changes to its interface and internal behavior.

#### Interface Modifications

- **Remove** the input signal `i_static_threshold` and its associated parameter.
- **Add** a new **parameter** `NBW_TH_UNLOCK`, default value: `3`.
- **Add** a new **input signal** `i_static_unlock_threshold` with width `NBW_TH_UNLOCK`.
- **Add** a new **1-bit output signal** `o_locked`.

#### Functional Description

- A new **finite state machine (FSM)** must be implemented with two operational states:
  - `ST_DETECT_SEQUENCE`: handles initial detection monitoring.
  - `ST_DETECT_PROC`: maintains a locked state and monitors detection quality.

- The FSM begins in the `ST_DETECT_SEQUENCE` state. While in this state, the module continuously evaluates incoming data for detection events. The signal responsible for defining the operation mode of the `correlate` module must be held low in this state, and the output `o_locked` must also remain low. A transition to the `ST_DETECT_PROC` state occurs only when both the output `o_proc_detected` is high and a signal returned from the `adder_2d_layer` module is high. This signal confirms that the detected values meet the criteria of being less than three valid modules.

- In the `ST_DETECT_PROC` state, the system assumes that detection has been achieved. A cycle counter begins tracking the number of processing cycles. If detection fails during a cycle (i.e., the detection output is low), a secondary counter increments to record consecutive failed sequences. The FSM transitions back to the `ST_DETECT_SEQUENCE` state when three conditions are met simultaneously: (1) the processing cycle counter reaches its maximum count, (2) no detection is reported, and (3) the failure counter reaches the value defined by the input `i_static_unlock_threshold`.

- While in `ST_DETECT_PROC`, if detection continues successfully, the FSM remains in this state, and the failure counter is reset. In this condition, the output `o_locked` is asserted high, and the mode selector for operation remains in its active configuration.

- The FSM uses an internal cycle counter to monitor the progress of a detection processing window. This counter increments on each valid cycle while the FSM is in the `ST_DETECT_PROC` state. When it reaches the predefined number of cycles that constitute a full processing window, the FSM evaluates detection outcomes and determines whether to maintain or exit the locked state.

- The output signal `o_locked` is asserted during the `ST_DETECT_PROC` state only when detection is actively being confirmed within the current processing window.

- Two counters are used by the FSM: one to count regular processing cycles and another to count undetected sequences. The regular processing cycle counter tracks the number of cycles processed during a locked window, and the undetected counter increments only when no detection occurs at the end of a window. Both counters must have a bit-width large enough to count up to the total number of 32-bit words defined in the external specification.

- The required counter size must accommodate a total number of words as specified in the `words_counting.md` document.

- All counters and state logic must respond to an asynchronous active-low reset (`rst_async_n`), which clears internal state and resets both counters.

- A condition influencing state transitions is provided by the `cross_correlation` module, which must be connected internally but requires no changes to that module's interface.

#### Cross Correlation Module Updates

- The **cross_correlation** module must be updated to include the following new interface signals:
  - An asynchronous active-low reset input (`rst_async_n`) received from the top-level.
  - A new input signal `i_mode`, which is provided by the FSM from the top-level module.
  - A new 1-bit output signal `o_aware_mode`, indicating internal awareness status.

- The `rst_async_n` and `i_mode` signals must be propagated internally to the **adder_2d_layers** submodule.
- Additionally, the `i_mode` signal must be connected to the **correlate** submodule.

These updates ensure consistent control and synchronization across internal components, and align the interface of the `cross_correlation` module with new detection and locking logic defined at the top level.

#### Adder 2D Layers Module Update

- The **adder_2d_layers** module must be modified to incorporate logic that monitors the value of the operation mode input.
- A new synchronous output flag must be raised when the mode input corresponds to a valid mode value.
- Valid mode values are defined externally and must be interpreted according to the list provided in the `valid_modes.md` document.
- This flag must be updated synchronously with the system clock and used to inform the FSM in the `detect_sequence` module that the current operation mode is valid.

#### Correlate Module Update

- The **correlate** module must be updated to support operation based on a new 2-bit input signal `i_mode`.
- When `i_mode` is set to `0`, the module should perform its original behavior without modification.
- When `i_mode` is set to `1`, all index computations must apply subtraction between relevant inputs.
- When `i_mode` is set to `2`, all index computations must apply addition between relevant inputs.
- When `i_mode` is set to `3`, the output indices must be forced to zero, effectively disabling dynamic computation.

### Prompt 121 ###
Design a SystemVerilog module named `control_fsm` that implements a five-state finite state machine (FSM) for managing the data and processing control flow of a signal processing system. The FSM operates based on various input signals such as enable, valid flags, failure detection, and timeout counters.

The design includes:

**Five-State FSM**:  
Define a sequential FSM with five operational states:
- `PROC_CONTROL_CAPTURE_ST`
- `PROC_DATA_CAPTURE_ST`
- `PROC_CALC_START_ST`
- `PROC_CALC_ST`
- `PROC_WAIT_ST`

State transitions must be based on a combination of control enable signals, counter values, and processing result flags.

**Asynchronous Reset and Clocking**:  
Implement the FSM driven by a rising edge clock and an asynchronous active-low reset (`rst_async_n`).

**Counter-Driven Logic**:  
Integrate two counters:
- A general-purpose counter that governs data capture and calculation phases.
- A timeout counter that tracks processing wait periods.

**Output Control Logic**:  
The outputs must be derived using combinational logic based on the current FSM state. 

For further details, refer to the specification in `docs/proc_fsm_spec.md`.

### Prompt 122 ###
You are required to design a System Verilog module `poly_decimator`. The `poly_decimator` is a top-module and it must integrate a number of provided files. The detailed specification of `poly_decimator` is provided in the document `docs/poly_decimator.md`.

## Integration Instructions
- The **`poly_decimator`** module, that should be defined in `rtl/poly_decimator.sv`, must serve as the top-level design. It is responsible for handling the overall decimation operation of M samples.

You are also provided with a library of pre-designed modules that must be integrated into the target module. The library modules are:

- **adder_tree**  
  - **Design File:** `rtl/adder_tree.sv`  
  - **Specifications:** `docs/adder_tree.md`  
  - **Functionality:** Implements a pipelined adder tree for summing multiple data inputs.

- **shift_register**  
  - **Design File:** `rtl/shift_register.sv`  
  - **Specifications:** `docs/shift_register.md`  
  - **Functionality:** Implements a shift register that stores a history of input samples.

- **coeff_ram**  
  - **Design File:** `rtl/coeff_ram.sv`  
  - **Specifications:** `docs/coeff_ram.md`  
  - **Functionality:** Provides a synchronous memory block for storing filter coefficients.

- **poly_filter**  
  - **Design File:** `rtl/poly_filter.sv`  
  - **Specifications:** `docs/poly_filter.md`  
  - **Functionality:** Implements the filtering operation for each polyphase branch: it multiplies a subset of input samples by the proper coefficients, then sums the products.

Ensure that you fully understand the functionality and interfaces of these modules as described in their specification documents. They must be integrated properly to achieve the desired polyphase decimation functionality

### Prompt 123 ###
Develop assertion properties to verify the sanity of the `poly_interpolator` module. The module is available in the `rtl` directory and its documentation is available in `docs` directory. Please use **SystemVerilog Assertions (SVA)** to verify correctness of internal control, functional behavior and state sequencing of the design.

### Assertion Requirements

Please implement assertions covering the following properties:

1. **Inready Behavior**  
   When the FSM is in the `WAIT_INPUT` state and an input sample is valid (i.e. `in_valid` is high), the design must assert `in_ready` to signal that it is ready to accept a new sample.

2. **FSM Transition: WAIT to PROCESS**  
   When in the `WAIT_INPUT` state with `in_valid` asserted, the FSM must transition to the `PROCESS_PHASES` state in the next cycle.

3. **FSM Transition: PROCESS to OUTPUT**  
   In the `PROCESS_PHASES` state, if the polyphase filter indicates a valid result (`valid_filter` is high) and the phase counter equals `N-1`, the FSM must transition to `OUTPUT_STATE`.

4. **FSM Transition: OUTPUT to WAIT**  
   When in the `OUTPUT_STATE` and the output index equals `N` (i.e. all outputs have been released), the FSM must transition back to `WAIT_INPUT`.

5. **Output Validity**  
   In the `OUTPUT_STATE`, while `output_index` is less than `N`, the output valid signal (`out_valid`) must be asserted on next cycle.

6. **Result Buffer Data Storage**  
   In the `PROCESS_PHASES` state, when `valid_filter` is asserted, the filter result must be stored correctly in the `result_buffer` at the index indicated by the phase counter.

7. **Shift Register Data Drives filter_val_in**  
   In the `PROCESS_PHASES` state, if valid data is available from the shift register (i.e. `shift_data_val` is high) and `valid_filter` is not yet asserted, then `filter_val_in` must be driven high to trigger processing in the next cycle.


### Expected Behavior

If any of the above conditions are violated, the assertion must fail and produce an informative error message that clearly identifies the failure scenario.

### Notes

- All assertions must use **SystemVerilog Assertions (SVA)** syntax.
- The assertion properties must be placed in a separate module named `poly_interpolator_assertions` located in the `verif` directory.
- These assertion properties must be **bound** to the `poly_interpolator` module using the SystemVerilog `bind` construct. In the bind file (which should act as the top-level module and be named `poly_interpolator_bind` in the `verif` directory), the `poly_interpolator` module must be instantiated as `poly_dut` and the assertions module should be instantiated as `inst_poly_assert`.
- The properties can reference internal DUT signals directly for verification.

### Prompt 124 ###
Develop assertion properties to verify the sanity of the `poly_filter` module. The module is available in the `rtl` directory and its documentation is available in `docs` directory. Please use **SystemVerilog Assertions (SVA)** to verify correctness of internal control, functional behavior and state sequencing of the design.

### Assertion Requirements

Please implement assertions covering the following properties:

1. **Invalid Registration**  
   When `valid_in` is asserted, the entire `sample_buffer` must be registered into `sample_reg`, enabling `valid_stage0` in the next cycle.

2. **Coefficient Fetch Address Consistency**
   For tap 0, ensure the computed coefficient fetch address equals `**phase_reg * TAPS + 0**`.

3. **Per-tap Multiplication Consistency**
   When valid_stage1 is asserted, confirm that products[0] equals `sample_reg[0] * coeff[0]`.

4. **Sum Result Latency Check**
   Once valid_stage1 is asserted, `valid_adder` must be asserted exactly two clock cycles later.

5. **Adder Tree Output Consistency**
   Ensure that within three cycles after valid_stage1, filter_out equals `sum_result` while valid_adder is high.

6. **Output Registration Reset Behavior**
   On reset, confirm that `filter_out` is cleared and `valid` is deasserted.

7. **Sum Result Stability Check**
   Once `valid_adder` is asserted, the value of `sum_result` must remain stable (unchanged from the previous cycle).


### Expected Behavior

If any of the above conditions are violated, the assertion must fail and produce an informative error message that clearly identifies the failure scenario.

### Notes

- All assertions must use **SystemVerilog Assertions (SVA)** syntax.
- The assertion properties must be placed in a separate module named `poly_filter_assertions` located in the `verif` directory.
- These assertion properties must be **bound** to the `poly_filter` module using the SystemVerilog `bind` construct. In the bind file (which should act as the top-level module and be named `poly_filter_bind.sv` in the `verif` directory), the `poly_filter` module must be instantiated as `poly_dut` and the assertions module should be instantiated as `inst_poly_filter_assert`.
- The properties can reference internal DUT signals directly for verification.

### Prompt 125 ###
I have a **prbs_gen_check** module that generates or checks  pseudo-random bit sequence (PRBS) data,

The **prbs_gen_check** module is available at `/rtl/prbs_gen_check.sv` and its' specification in the `/docs` directory. Can you implement the **`scrambler_descrambler.sv`** in the `/rtl` folder? Details of the `scrambler_descrambler` module is as given below

### Purpose
The **`scrambler_descrambler`** module should perform a simple data scrambling or descrambling function using a pseudo-random bit sequence (PRBS). It should instantiate the `prbs_gen_check` module to generate the random sequence used for XOR-based scrambling/descrambling. Scrambling involves XORing data with a pseudo-random bit sequence to randomize its pattern. Descrambling uses the same pseudo-random sequence to restore the original data from the scrambled stream.

- It should support a parameterizable data bus width (`WIDTH`).  
- It should rely on a specific polynomial length (`POLY_LENGTH`) and tap (`POLY_TAP`) for the underlying PRBS generation.  
- Following features should be added:
   - Add the input bypass_scrambling. When asserted the input data should be sent unmodified to data_out with a latency of 1 clock cycle.
   - Add parameter CHECK_MODE. When 0, operate normally as a scrambler or a descrambler. When 1, check if the incoming data is a PRBS pattern or not.
   - Add output bit_count. This will be used to check the throughput of the module and should be equal to the total valid data bits sent out from this module.
- Latency considerations: This module should have the following latencies for the cases given:
   - bypass_scrambling asserted: 1 clk latency
   - bypass_scrambling deasserted and CHECK_MODE=0 (perform scrambling or descrambling): 1 clk latency.
   - bypass_scrambling deasserted and CHECK_MODE=1 (perform data_in checking for PRBS): 2 clk latency.

## Interface Definition


| **Parameter**   | **Type** | **Default** | **Description**                                                 |
|-----------------|----------|-------------|-----------------------------------------------------------------|
| `POLY_LENGTH`   | int      | 31          | Length of the LFSR in the PRBS generator/checker.               |
| `POLY_TAP`      | int      | 3           | Tap position(s) in the LFSR polynomial for feedback.            |
| `WIDTH`         | int      | 16          | Data width (in bits) for `data_in` and `data_out`.              |
| `CHECK_MODE`    | bit      | 0           | 0 => Generator mode (scrambler), 1 => Checker mode (PRBS check).|

| **Port Name**         | **I/O** | **Width**           | **Description**                                                                                 |
|-----------------------|---------|---------------------|-------------------------------------------------------------------------------------------------|
| `clk`                 | Input   | 1                   | Primary clock input. Rising edge triggered.                                                     |
| `rst`                 | Input   | 1                   | Active-high synchronous reset.                                                                  |
| `bypass_scrambling`   | Input   | 1                   | 1 => pass data directly from `data_in` to `data_out`. 0 => normal scrambler/descrambler path.   |
| `data_in`             | Input   | `WIDTH` bits        | Data word input for scrambling, descrambling, or checking.                                      |
| `valid_in`            | Input   | 1                   | Indicates `data_in` is valid on the current cycle. Active-high.                                 |
| `data_out`            | Output  | `WIDTH` bits        | Scrambled/descrambled (or pass-through) data.                                                   |
| `valid_out`           | Output  | 1                   | Indicates `data_out` is valid on the current cycle. Active-high.                                |
| `bit_count`           | Output  | 32 bits             | Total number of valid bits processed (increments by `WIDTH` every time `valid_in`=1).           |

### Prompt 126 ###
# Review and Improvement Request for FSM RTL

I have a **Finite State Machine (FSM)** RTL module located at `rtl/fsm.sv` that currently implements **statically encoded** state logic. I would like to convert it to a **dynamically encoded** FSM. Below is a summary of the current design, a clear set of modifications to be made, and the evaluation criteria.

---

## Module Specifications

### RTL (rtl/fsm.sv)

**Inputs**:
- **clk:** Posedge Clock signal.
- **reset:** Active-high reset. When ACTIVE HIGH, the `state`, `current_state`, and `error_flag` are initialized to zero.
- **input_signal:** A 4‑bit signal used to drive state transitions.
- **config_state_map_flat:** A 64‑bit flattened state map that holds an 8‑bit configuration for each of the 8 states.
- **config_transition_map_flat:** A 128‑bit flattened transition map for calculating the next state.

**Outputs (Static FSM)**:
- **current_state:** The current internal state (directly driven by the state register).
- **error_flag:** Indicates if an invalid state transition (next state > 7) is detected.
- **operation_result:** A result computed based on the current state and input signal using a user-defined operation.

---

## Proposed Modifications for Dynamic State Encoding

The current design outputs the internal state directly, which is suitable for static state encoding. To improve flexibility and allow run-time reconfiguration for area and power optimizations, the following modifications are proposed:

1. **Decouple Internal and External State Representation:**
   - **Current Behavior:** The internal state is directly output as `current_state`.
   - **Modification:** Remove the direct assignment and instead implement a lookup mechanism using `config_state_map_flat` to generate an **encoded_state**. This separates the internal binary state from its external representation.

2. **Implement Additional Dynamic Transformation:**
   - **Current Behavior:** Operations are computed directly using the statically encoded state.
   - **Modification:** Introduce a second output called **dynamic_encoded_state** that is derived from the **encoded_state** using an additional transformation (for example, an XOR with the input signal). This extra transformation enables further flexibility in the external representation and can be tuned at run time.

3. **Preserve Transition and Error Handling Logic:**
   - **Current Behavior:** The next state is computed from the transition map, and error detection is performed if the next state exceeds 7.
   - **Modification:** Retain this state transition logic, error detection, and the user-defined operations (e.g., addition, subtraction, bitwise operations) so that the functional behavior remains consistent.

---

## Evaluation Criteria

To evaluate the dynamic FSM against the current static design, consider the following criteria:

- **Functional Correctness:**
  - The dynamic FSM must maintain the same state transitions and operation results as the static FSM for identical inputs.
  
- **Reconfigurability:**
  - The external state outputs (**encoded_state** and **dynamic_encoded_state**) must accurately reflect the configuration provided by `config_state_map_flat` and adapt correctly based on the input signal.

- **Error Detection:**
  - The error flag must be correctly set when the computed next state exceeds the valid range (i.e., greater than 7), and the state should be safely reset to 0 as in the original design.

- **Flexibility:**
  - The modifications should allow for on-the-fly changes to the state encoding without impacting the underlying state machine functionality. 

----
**Block Diagram for the Existing Architecture**:

                     +---------------------------+
                     |   Internal State (reg)    |
                     |         (state)           |
                     +------------+--------------+
                                  |
                                  | (state, input_signal)
                                  v
                     +--------------------------------+
                     |   Config Transition Map        |
                     |      (128-bit lookup)          |
                     +------------+-------------------+
                                  |  (computes next_state)
                                  v
                     +----------------------------------+
                     |      Next State Logic            |
                     | (generates next_state and        |
                     |  error_flag based on next_state) |
                     +------------+---------------------+
                                  |  (error_flag output here)
                                  |
                                  | (next_state is passed on)
                                  v
                     +----------------------------+
                     |   Internal State (reg)     |
                     |     (updated state)        |
                     +----------------------------+
                                  |
                                  | (direct mapping)
                                  v
                           +---------------------+
                           |    current_state    |
                           +---------------------+
                                  |
                                  | (state used to select slice)
                                  v
                     +------------------------------+
                     |    Config State Map Lookup   |
                     |  (64-bit lookup: 8-bit per     |
                     |       state slice)           |
                     +------------+-----------------+
                                  | (provides operand for)
                                  v
                     +------------------------------+
                     |  Operation Computation Logic |
                     |  (case: using config slice   |
                     |   & input_signal for arithmetic)|
                     +-------------+------------------+
                                   |
                                   v
                           +---------------------+
                           |  operation_result   |
                           +---------------------+
                                  |
                                  v
                           +---------------------+
                           |     error_flag      |
                           +---------------------+


----

---
**Block Diagram of the Proposed Modification** :

                     +---------------------------+
                     |   Internal State (reg)    |
                     |         (state)           |
                     +------------+--------------+
                                  |
                                  | (state, input_signal)
                                  v
                     +--------------------------------+
                     |   Config Transition Map        |
                     |      (128-bit lookup)          |
                     +------------+-------------------+
                                  |  (computes next_state)
                                  v
                     +----------------------------------+
                     |      Next State Logic            |
                     |  (generates next_state and       |
                     |   error_flag based on next_state)|
                     +------------+---------------------+
                                  |  (error_flag output here)
                                  |
                                  | (next_state is passed on)
                                  v
                     +----------------------------+
                     |   Internal State (reg)     |
                     |     (updated state)        |
                     +----------------------------+
                                  |
                  +---------------+--------------+
                  |                              |
                  v                              v
     +------------------------------+   +------------------------------+
     |    Config State Map Lookup   |   |   Operation Computation      |
     | (64-bit lookup: 8-bit per state) |  |    Logic (using config slice  |
     |                              |   |       & input_signal)         |
     +-------------+----------------+   +-------------+----------------+
                   |                                  |
                   v                                  v
          +-------------------+               +---------------------+
          |    encoded_state  |               |  operation_result   |
          +-------------------+               +---------------------+
                   |                                  
                   | (Dynamic Transformation: 
                   |  encoded_state ^ {4'b0, input_signal})
                   v                                  
          +----------------------------+
          |   dynamic_encoded_state    |
          +----------------------------+

              (error_flag is generated in Next State Logic
               and is output separately; it is not used in
               updating the internal state)


-----


## Summary

**Static FSM (Current Implementation)**:  
- Directly outputs the internal state as `current_state`.  
- Uses fixed, unmodifiable state encoding.

**Dynamic FSM (Proposed Improvement)**:  
- Separates the internal state from its external representation using a configurable state map to generate **encoded_state**.  
- Further refines the external state via a dynamic transformation (e.g., XOR with the input) to produce **dynamic_encoded_state**.  
- Retains the same state transition, operation, and error detection logic.

Please review the current FSM implementation at `rtl/fsm.sv` and make the above modifications to convert the statically encoded design into a dynamically encoded FSM. The evaluation will be based on functional equivalence, improved flexibility in state representation, robust error handling, and the ability to adjust state encoding dynamically at runtime.

### Prompt 127 ###
Design a `queue` module in SystemVerilog based on the specification provided in `docs/specs.md`. Ensure you fully understand its structure, including parameterized depth and data width. The design should implement a fall-through mechanism where data shifts on a read, ensuring the first word is always available at the output. Support simultaneous read/write operations such that when the queue is empty, a write operation immediately updates the output at index 0. Implement programmable almost-empty and almost-full threshold signals to facilitate proactive flow control. Ensure proper asynchronous reset via `rst_ni`, synchronous clear via `clr_i`, and synchronous operation with `clk_i`. The module must update status signals (empty, full, almost_empty, almost_full) based on the queue pointer and configurable thresholds, and be synthesizable and optimized for hardware deployment. Refer to `docs/specs.md` for detailed implementation requirements, pointer management, and data-shifting logic.

### Prompt 128 ###
I have a specification for the `queue` module in the `docs` directory (`specification.md`). Write a SystemVerilog testbench `tb_queue.sv` in the `verif` directory to generate a stimulus for the `queue` module.

Include the following in the generated testbench:

---

### 1. **Module Instance:**
- Instantiate the `queue` module as `dut`.
- Set parameters as follows:
  - `DEPTH = 4`
  - `DBITS = 32`
  - `ALMOST_EMPTY_THRESHOLD = 1`
  - `ALMOST_FULL_THRESHOLD = 4`
- Connect all input/output signals for functional stimulus testing.

---

### 2. **Input Generation:**
- Provide input sequences that stimulate all interface operations:
  - Write-only (`we_i = 1`, `re_i = 0`)
  - Read-only (`we_i = 0`, `re_i = 1`)
  - Simultaneous read/write (`we_i = 1`, `re_i = 1`)
  - Idle (`we_i = 0`, `re_i = 0`)
- Include a reset sequence at the start (`rst_ni` = 0 → 1).
- Include clear signal assertion (`clr_i = 1`) during the test.
- Enable signal `ena_i` must toggle during the test and include disabled cycles (`ena_i = 0`) to cover control FSM "else" branches.

---

### 3. **Coverage Requirements:**
- Exercise all internal RTL blocks, including:
  - Pointer updates for all read/write combinations.
  - Data shift and insertion logic.
  - Programmable `almost_empty_o` and `almost_full_o` thresholds.
  - `empty_o` and `full_o` status signal behavior.
- Trigger edge cases such as:
  - Overflow condition (`we_i` when queue is full).
  - Underflow condition (`re_i` when queue is empty).
  - Simultaneous read/write when `queue_wadr == 0`.
  - `ena_i == 0` during active clocking.
  - Re-asserting reset (`rst_ni`) mid-simulation to exercise reset path.

### Prompt 129 ###
Design RTL module `rc5_enc_16bit` in `rtl` directory for a RC5 symmetric block-cipher encryption process based on the following specification and functionality. The design must support encryption of 16-bit plaintext input. The RTL design may assume one round of operation for encryption. The number of S-box variables and their values to be incorporated for encryption can be chosen accordingly. Following interface details have to be used for RTL design of RC5 encryption.

## Interface details

### Inputs:
- **clock (1-bit)**: A single-bit input clock that drives the Finite State Machine executing the encryption algorithm at the positive edge. The clock typically has a 50:50 duty cycle.
- **reset (1-bit)**: A control signal that resets the internal states of the encryption system. The reset can be configured as synchronous active low signal.
- **enc_start (1-bit)**: After this signal becomes HIGH, the encryption process begins
- **p (16-bit,[15:0])** : The 16-bit plaintext input of RC5 encryption 

### Output:
- **c (16-bit,[15:0])** : The 16-bit ciphertext output of RC5 encryption 
- **enc_done (1-bit)**: A HIGH in this output signal indicates the end of RC5 encryption and stable output at `c`, the ciphertext output

## Functionality

### RC5 Encryption algorithm

- The RC5 algorithm is a symmetric block cipher known for its simplicity and effectiveness in converting plaintext to ciphertext and vice versa. 
- It offers flexible options for adjusting block size, key size, and the number of encryption rounds. 
- The RC5 algorithm employs operations such as modulo addition, left rotation, modulo subtraction, right rotation, and XOR in its encryption and decryption processes.

In order to understand the RC5 block cipher encryption, the following parameters are needed:
1. Plaintext (P)
2. Plaintext as w-bit registers (A & B)
2. Data width (2w)
3. S-box key array (S)
4. Rounds of operation (r)
5. Ciphertext (C)

The RC5 encryption algorithm works as follows:

A = A + S[0];\
B = B + S[1];\
for i = 1 to r do\
&nbsp;&nbsp;&nbsp;&nbsp;A = ((A XOR B) <<< B) + S[2&times;i];\
&nbsp;&nbsp;&nbsp;&nbsp;B = ((B XOR A) <<< A) + S[(2&times;i)+1];\
C = {A,B}

Here, <<< : Left rotation; + : Modulo 2<sup>w</sup> addition; A : MSB w-bits of plaintext P;\
B : LSB w-bits of plaintext P; S[0],S[1],S[2],....... : S-box keys ; {} : Concatenation

At the beginning of encryption, the MSB w-bits of plaintext are assumed as A, and the LSB w-bits of plaintext as B. Every step of this algorithm has to be carried out sequentially as the subsequent steps utilize the result of previous computations. Even though the encryption can be carried out on any data width, the recommended plaintext widths are 16,32 or 64. The number of S-box keys for the encryption is 2*(r+1), where 'r' represents the number of rounds. As the number of rounds increases, the algorithm requires more number of S-box keys. In general, S-box keys are assumed by the user during the encryption process which need to be shared for executing the decryption.

## Considerations

- The RTL design specifically should encrypt 16-bit data using four 8-bit S-box constants to meet operational needs. 
- Encryption has to be performed by a Finite State Machine (FSM) that completes one round of the RC5 algorithm in four clock cycles. The FSM progresses through four states: initial addition, computation of the most significant 8-bits (MSB), computation of the least significant 8-bits (LSB), and finally, output of the ciphertext. The system has to operate on 2w bits, where w is 8, fitting the 16-bit encryption scheme.
- The encryption process requires 2(r+1) S-box entries, where r represents the number of rounds. Since the RTL module for RC5 encryption has to operate with a single round, it can incorporate four 8-bit S-box entries. These S-box entries, based on design assumptions, are to be set as follows:
  - Implement Cellular Automata for PRNG: Develop a Cellular Automata-based PRNG specifically designed to generate four 8-bit random values. These values will be used as S-box keys in the RC5 encryption process.
  - Ensure that the Cellular Automata configuration is capable of generating maximal length sequences. This is crucial for maintaining high entropy in the key stream and enhancing the cryptographic strength of the RC5 cipher.
  - Implement a combination of Rule 90 and Rule 150 in your Cellular Automata design. These rules are selected for their properties in producing complex, pseudorandom patterns, suitable for cryptographic applications.
   - Rule 90: A simple XOR of each cell with its two immediate neighbors (i.e., left and right cells).
   - Rule 150: Involves XORing each cell with its left and right neighbors and itself, resulting in a more complex pattern.
 - The CA based PRNG has to be constructed with a combination of rules R90-R90-R150-R90-R150-R90-R150-R90 with 8-bit seed of 8'hFF
 - This CA should be capable of generating (2<sup>8</sup> - 1) pseudorandom sequences.
- The encryption shall employ arithmetic and logical operations such as modulo 256 addition, left rotation, and XOR. These operations have to be executed sequentially, as each step of the algorithm depends on the output from the previous step to generate the 16-bit ciphertext.

## Working example 

### RC5 Encryption

Let us consider the following parameters:

P = 16'hFFFF ; w = 8 ; r = 1 ; S[0] = 8'h20;S[1] = 8'h10;S[2] = 8'hFF;S[3] = 8'hFF;

Solution:

A = 8'hFF; B = 8'hFF

A = (8'hFF + 8'h20) mod 256 = 1F\
B = (8'hFF + 8'h10) mod 256 = 0F

(Loop computation)\
&nbsp;&nbsp;&nbsp;&nbsp;A = (((8'h1F XOR 8'h0F) <<< 8'h0F) + 8'hFF) mod 256 = (8'h08 + 8'hFF) mod 256 = 8'h07\
&nbsp;&nbsp;&nbsp;&nbsp;B = (((8'h0F XOR 8'h07) <<< 8'h07) + 8'hFF) mod 256 = (8'h04 + 8'hFF) mod 256 = 8'h03

The ciphertext output is C = 16'h0703

The `rtl` directory has four different CA implementations namely `CA_1.sv`, `CA_2.sv`, `CA_3.sv`,  and `CA_4.sv` and choose the appropriate CA design for S-box generation.

### Prompt 130 ###
Design a `rgb_color_space_hsv` module in SystemVerilog within a file `rgb_color_space_hsv.sv` at the location: `rtl/rgb_color_space_hsv.sv`. Refer to the specification provided in `docs/specification.md`. The specification details an algorithm overview for converting Red Green Blue (RGB) to Hue Saturation Value (HSV), the required module interface, internal architecture, and latency requirements. Generate the complete RTL code that implements the `rgb_color_space_hsv` module.

### Prompt 131 ###
The existing RTL module `rgb_color_space_conversion` (located in the `rtl/` directory) currently supports RGB to HSV and HSL color space conversions. This module is implemented using pipelined and fixed-point arithmetic and receives 8-bit RGB inputs. Modify the module to include **CMYK (Cyan, Magenta, Yellow, Key/Black)** conversion logic, while maintaining existing HSV/HSL functionality and preserving pipeline structure. The CMYK conversion behavior, equations, and fixed-point scaling details are defined in the specification available in the `docs/` directory.

### **New Port Additions**

Add the following CMYK-specific output ports to the `rgb_color_space_conversion` module:

| Port Name             | Direction | Width     | Description                              |
|-----------------------|-----------|-----------|------------------------------------------|
| `cmyk_channel_c`      | Output    | 16-bit    | Cyan component in fx8.8 format.          |
| `cmyk_channel_m`      | Output    | 16-bit    | Magenta component in fx8.8 format.       |
| `cmyk_channel_y`      | Output    | 16-bit    | Yellow component in fx8.8 format.        |
| `cmyk_channel_k`      | Output    | 8-bit     | Black (Key) component in Integer format. |


### **Functional and Timing Constraints**

- CMYK logic should be pipelined and operate in parallel with existing HSV and HSL paths.
- All CMYK outputs (`cmyk_channel_c`, `cmyk_channel_m`, `cmyk_channel_y`, `cmyk_channel_k`) should align with `valid_out`, i.e., be valid in the same cycle as HSV and HSL outputs.
- Ensure proper reset behavior: all CMYK outputs should be cleared to `0` on reset.


### **Assumptions & Notes**

- The inputs (`clk`, `rst`, `valid_in`, `r_component`, `g_component`, `b_component`) remain unchanged until `valid_out` is HIGH.
- You may reuse the existing multi-port RAM for reciprocal lookup (i.e., 1 / i_max).
- Intermediate CMY computations may be staged across multiple clock cycles.

### Prompt 132 ###
I have a `rgb_color_space_hsv` module available in the `rtl` directory and its' specification is in the `docs` directory. Please modify the module by adding System Verilog assertions to validate the following conditions during simulation. The assertions should display clear error messages when any condition is violated.

**Required Assertions:**

1. **Valid Signal Latency:**  
   Ensure that `valid_out` is asserted exactly after the expected processing latency from the assertion of `valid_in`.

2. **Zero Outputs When i_max is Zero:**  
   Confirm that when `i_max` is zero, all outputs (`h_component`, `s_component`, and `v_component`) are driven to zero when the outputs are valid.

3. **Zero h_component and s_component When delta_i is Zero:**  
   Validate that `h_component` and `s_component` are driven to zero when `delta_i` is zero and the outputs are valid.

4. **V Component Accuracy:**  
   Verify the correctness of `v_component` relative to `i_max` when the outputs are valid. If there is a mismatch, provide detailed debugging information.

5. **H Range Check:**  
   Ensure that `h_component` does not exit the maximum upper bound under all input conditions.

6. **Input Stability Check:**  
   Ensure that the inputs (`r_component`, `g_component`, `b_component`) remain stable throughout the processing period until valid outputs are available.

### Prompt 133 ###
The specification document for the `rgb_color_space_conversion` module is present in the `docs` folder. Write a SystemVerilog testbench, `tb_rgb_color_space_conversion.sv`, in the `verif` directory to only generate stimulus for the `rgb_color_space_conversion` module to achieve maximum coverage of the UUT.

Include the following in the generated testbench:

### 1. **Module Instance**:
The `rgb_color_space_conversion` module should be instantiated as `uut`, with the input and output signals connected for testing.

### 2. **Input Generation**:
The testbench must generate inputs to cover all possibilities, including corner cases, edge cases, and high-range values. 

### 3. **Computation Period**:
After setting each pair of inputs, the testbench should wait until the assertion of the `valid_out` signal to ensure the outputs have stabilized before providing the next input.

### Prompt 134 ###
I have a specification of a `linear_search_top` module in the `docs` directory. Write a SystemVerilog testbench `tb_linear_search.sv` in the `verif` directory to only generate stimulus for the `linear_search_top` module and achieve maximum coverage of the design.

Include the following in the generated testbench:

- **Module Instance**: Instantiate the `linear_search_top` module as `linear_search_top_inst`, with all ports connected appropriately. 
- **Clock and Reset**: Generate a 10ns clock and include a synchronous, active-high reset task to initialize the DUT before applying any stimulus.
- **Memory Initialization Stimulus**: Use the memory write interface (`mem_write_en`, `mem_write_addr`, `mem_write_data`) to populate memory with a variety of patterns before each search.
- **Search Control Stimulus**: Drive the `start` signal to initiate the search, and optionally use the `pause` signal to temporarily suspend it. Resume the search by deasserting `pause`.
- **Test Scenarios** (generate input stimulus for each of the following):
  - Write a pattern where the `key` appears at every 4th address.
  - Write memory such that the `key` appears only once.
  - Fill memory completely with the `key` to trigger match buffer overflow.
  - Repeat the full-match test but insert a `pause` during the search.
  - Write exactly `MAX_MATCHES` instances of the `key` to test buffer boundaries without overflow.
  - Test edge cases where the `key` is placed only at the first, last, or middle address.
  - Perform back-to-back searches with different `key` values and spacing patterns.
  - Randomize memory contents and the `key` for a randomized match pattern test.
  - Apply high-volume randomized testing (e.g., 10,000 iterations) with varying numbers and locations of matches.

Do not include any assertions or output checking logic. The testbench must focus only on applying stimulus to the DUT and observing outputs passively.

### Prompt 135 ###
I have a specification of a `linear_search_top` module in the `docs` directory and a testbench `tb_linear_search.sv` in the `verif` directory that only generates stimulus for the design. Modify the testbench to **verify the results of the `linear_search_top`**.

Add the following in the testbench:

- Implement a task `check_results()` to verify the DUT outputs against expected behavior.
  - The task must compare `match_count` with the number of expected matches.
  - It must extract `match_indices` and verify that all expected addresses appear in order.
  - It must also check the correctness of the `match_overflow` flag depending on whether the number of matches exceeds `MAX_MATCHES`.

- Track expected match addresses in a dynamic array within each test scenario.
  - For the randomized high-volume test, filter duplicates and sort the addresses before comparison.
  
- Modify the existing test sequence to ensure expected results are verified after search operation is complete.
  
- Display appropriate messages when a test **passes or fails**.
  - On mismatch, print detailed debug information and exit the simulation with an error using `$finish`.

**Constraints**:
- The additions to the testbench must focus solely on **verifying DUT outputs** based on known input conditions.

### Prompt 136 ###
I have a **APBGlobalHistoryRegister** module located at `rtl/APBGlobalHistoryRegister.v`. This module currently lacks access control and can operate without any restriction. I want to enhance the system to be **secure**, such that the global history shift register only functions after a proper unlock sequence has been successfully completed.

---

### **Modification Goals**

Create a new module, named "security_module" in file "security_module.v" that acts as a **security gatekeeper**. This module must implement a finite state machine that enforces an **unlock sequence** before enabling the global history shift register. The unlock sequence consists of two steps:
1. First, the hexadecimal value `0xAB` must be written to internal address `0`.
2. Next, the value `0xCD` must be written to internal address `1`.

Only when both steps are performed in sequence should the system be considered **secure**. Any deviation (incorrect value or incorrect order) should cause the state machine to reset, requiring the entire sequence to be redone. The secure module is resettable and must return to the locked state upon system reset.

Once the unlock is complete, the secure module should assert a signal that enables the global history shift register. Until then, the global history shift register must remain inactive. Modify the "APBGlobalHistoryRegister" such that it will enable when the module is secure.

---

### **Top-Level Integration and module modification**

Create a new top-level module named "APBGlobalHistoryRegister_secure_top.v" that integrates both the security module and the global history shift register. Ensure correct data flow and signal connection between them. The security module interface should use the existing 8-bit apb interface but with a different clock named "i_capture_pulse". 
Below are the IOs.

```verilog 
module APBGlobalHistoryRegister_secure_top  #(                  
    parameter p_unlock_code_0 = 8'hAB,            
    parameter p_unlock_code_1 = 8'hCD            
) (
    input  wire         pclk,  
    input  wire         presetn,  
    // APB signals
    input  wire [9:0]   paddr,  
    input  wire         pselx,  
    input  wire         penable,  
    input  wire         pwrite, 
    input  wire [7:0]   pwdata, 
    input  wire         history_shift_valid,  
    input  wire         clk_gate_en,  
    
    input wire          i_capture_pulse,    

    output reg          pready, 
    output reg  [7:0]   prdata, 
    output reg          pslverr,  
    output reg          history_full, 
    output reg          history_empty,  
    output reg          error_flag, 
    output reg          interrupt_full, 
    output reg          interrupt_error       
);
```

---

### **Clocks and Reset**

The secure module operates on a clock derived from a **capture pulse** signal, while the global history shift register runs on its own **pclk clock**. These clocks are asynchronous. The reset signal is shared across both modules. 

---

### **Expected Deliverable**

A complete design containing:
1. The **modified global history shift register** that responds to a secure-enable condition.
2. A new **security module** enforcing the unlock logic.
3. A **top-level module** instantiating and integrating both components, managing control flow and asynchronous clocks.

The system must ensure that the global history shift register never functions unless the unlock sequence is properly followed.

### Prompt 137 ###
Design a Verilog module for `sigma_delta_audio`. Refer to the specification in the specification in `docs/specification.md`, which defines a 1-bit sigma-delta modulator for stereo audio signals, inspired by Amiga's Paula sound hardware. The module accumulates input samples, applies error feedback and dithering via LFSRs, and produces modulated 1-bit outputs. It includes noise shaping and synchronous state updates with reset logic.

### Prompt 138 ###
Design a `signed_comparator` module in SystemVerilog within a file `signed_comparator.sv` at the location: `rtl/signed_comparator.sv`. Refer to the specification provided in `docs/signed_comparator_specification.md` and ensure you understand its content. The specification details the functionality of a configurable signed comparator with the following parameters:

- **DATA_WIDTH**: Configurable bit width of the input values.
- **REGISTER_OUTPUT**: Enables or disables registered output.
- **ENABLE_TOLERANCE**: Allows approximate equality comparison by considering a tolerance range.
- **TOLERANCE**: Defines the maximum absolute difference for approximate equality when `ENABLE_TOLERANCE` is enabled.
- **SHIFT_LEFT**: Left-shift amount applied to both input values before comparison.

The module takes two signed input values, `a` and `b`, and compares them to determine greater-than (`gt`), less-than (`lt`), and equal (`eq`) conditions. If `ENABLE_TOLERANCE` is enabled, values within the specified `TOLERANCE` range are treated as equal. Additionally, an optional `bypass` mode forces the equality output (`eq = 1`) regardless of the input values.

### Functional Behavior

1. **Input Preprocessing:**  
   - Both inputs `a` and `b` are left-shifted by `SHIFT_LEFT` bits before comparison.
   - A signed subtraction computes the difference `diff = a_shifted - b_shifted`.

2. **Equality with Tolerance:**  
   - If `ENABLE_TOLERANCE` is enabled, the absolute difference `abs_diff` is compared to `TOLERANCE`.
   - If `abs_diff <= TOLERANCE`, `eq` is asserted (`eq = 1`).

3. **Comparison Logic:**  
   - If `bypass` is active, `eq` is forced to `1`, and `gt` and `lt` are set to `0`.
   - If `enable` is asserted:
     - If `eq_tolerance` is met, `eq = 1`, `gt = 0`, `lt = 0`.
     - Otherwise, normal signed comparison is performed to set `gt`, `lt`, and `eq` accordingly.

4. **Registering Output (Optional):**  
   - If `REGISTER_OUTPUT` is enabled, the comparison results (`gt`, `lt`, `eq`) are updated synchronously on the clock edge.
   - If `REGISTER_OUTPUT` is disabled, the outputs are updated combinationally.

Generate the complete RTL code for the `signed_comparator`, ensuring optimized performance and compliance with the given specification.

### Prompt 139 ###
Design a SystemVerilog module named `simd_matrix_engine_top` that implements a **two‑level SIMD-based matrix arithmetic engine**. The module processes two flattened square input matrices using **SIMD vector instructions** and produces a flattened result matrix through parallel lane computation.

---

### Module Requirements:

The module should accept two sets of flattened matrix inputs, one for matrix A and one for matrix B, and apply a specified vector operation (ADD, SUB, or MUL) in **SIMD-width chunks**. It should generate a flattened result matrix as output and indicate when the computation is complete using a `done` signal.

---

### Two‑Level Execution Logic:

#### Primary Level: FSM-Based Matrix Traversal
Use a finite state machine (FSM) to manage matrix traversal row-by-row and column-by-column. The FSM must include the following states:

- `IDLE`: Waits for `start` to assert.
- `COMPUTE`: Slices rows into `SIMD_WIDTH` chunks and feeds them into the SIMD datapath.
- `STORE`: Captures and writes the SIMD results into the output buffer.
- `DONE`: Asserts `done` and resets the FSM to IDLE.

#### Secondary Level: SIMD Lane Computation
The sliced matrix chunks are passed into a `simd_datapath` submodule that instantiates parallel `simd_lane` units. Each lane performs the selected operation (ADD, SUB, or MUL) and returns individual results. These are packed into the output result vector for storage.

---

###  Default Behavior:

- If no valid operation is selected (`op_select` outside `000`, `001`, `010`), default all SIMD results to 0.
- If `start` is not asserted, the FSM remains in the `IDLE` state, and all outputs remain inactive.
- If no lane is valid, the result should be zero, and `ready` should be asserted immediately.

---

### Interfaces

 Parameterization

- N: Defines the number of rows and columns in each square matrix (default: 8).

SIMD_WIDTH:
- Number of parallel processing lanes (default: 4). This allows row slices to be processed in parallel across the SIMD datapath.

DATA_WIDTH:
- Bit-width of each matrix element (default: 16).

#### Clock and Reset

- `clk` (1-bit): Clock input
- `rst` (1-bit): Synchronous active-high reset

#### Data Inputs

- `mat_a_flat` (N×N×DATA_WIDTH): Flattened input matrix A
- `mat_b_flat` (N×N×DATA_WIDTH): Flattened input matrix B

#### Control Inputs

- `start` (1-bit): Start computation
- `op_select`: Operation code:
  - `3'b000`: ADD
  - `3'b001`: SUB
  - `3'b010`: MUL

#### Outputs

- `mat_result_flat` (N×N×DATA_WIDTH): Flattened result matrix
- `done` (1-bit): Asserted for one cycle when processing is complete

---

### Comprehensive Testbench:

Develop a complete SystemVerilog testbench that:

- Instantiates the `simd_matrix_engine_top` module
- Applies a wide range of **matrix operand test vectors** including:
  - All-zero matrices
  - All-maximum-value matrices
  - Alternating bit patterns
  - Identity matrix patterns
  - Fully randomized values
- Applies all supported operations (ADD, SUB, MUL)
- Includes matrix slicing and flattening helpers (`flatten_matrix`, `unflatten_matrix`)
- Uses `$display` to report:
  - Current test ID
  - Operation performed
  - Input and output matrix content
- Uses `$monitor` to trace signal transitions (e.g., FSM states, `done`)
- Ends simulation with `$finish` after all test cases are completed

---

### Design Reference:

Refer to the functional specification in `docs/simd_datapath_specs.md` and `docs/simd_lane_specs.md` for functional specifications and creation.

---

### Prompt 140 ###
I have a `sorting_engine` module available in the `rtl` directory, and its' specification is in the `docs` directory. Kindly modify the module by adding system verilog assertions. The assertions should ensure that the module accurately implements the Parallel merge sort algorithm.

## **Assertion Details**  
The assertions should verify the following conditions:  
- **Intermediate sort results:** Verify that the intermediate arrays and the final array are sorted after each state based on the expected operation of that state.
- **Sort latency:** Make sure the module latency is correct based on the RTL given.

## **Expected Behavior**  
If any of the assertions fail, they should generate an **error message** indicating the incorrect behavior.

### Prompt 141 ###
I have a `sorting_engine` module available in the `rtl` directory and its' specification in the `docs` directory. The existing sorting_engine module implements the sorting of an unsigned integer array using a parallel merge sort algorithm in 20 clock cycles.

Modify the code to reduce the latency to 17 clock cycles by merging FSM states that can be executed in parallel.

Make sure to follow the given constraints:
- The reset behavior and constraints of the existing `sorting_engine` module should still be valid.
- Retain the original module (`sorting_engine`) port list interface.
- Retain the behavior where sorting arranges the elements of the array in ascending order, such that the smallest element is at index 0 and the largest element is at index N−1.

### Prompt 142 ###
I have a specification of a `sorting_engine` module in the docs directory and a testbench that only generates stimulus for that design. Modify the System Verilog testbench `sorting_engine_testbench.sv` in the `verif` directory to verify the results of the design in the `sorting_engine` module.

Add the following in the generated testbench:
- Add a function to calculate the expected sorted array based on the described merge sort algorithm.
- Modify the existing `apply_test` task to check the `sorting_engine` output and latency.
- Display appropriate messages when there is a pass or fail and incase of a mismatch in the results, exit the simulation with an error.

### Prompt 143 ###
I have a **sorting_engine** module that sorts the input data in ascending order.

The **sorting_engine** module is available at `/rtl/sorting_engine.sv` and its' specification in the `/docs` directory.
Can you implement the **`order_matching_engine.sv`** in the `/rtl` folder? Details of the `order_matching_engine` module is as given below

**Description - Order Matching Engine**

The goal is to build a module that efficiently processes and matches buy (bid) and sell (ask) orders. Here’s what the design must accomplish:

- **Input Handling:**  
  The engine accepts two flat input vectors—one for bid orders and one for ask orders. Each vector contains 8 orders (prices) of configurable bit-width (`PRICE_WIDTH`).

- **Sorting:**  
  Use the provided sorting engine to sort each set of orders:
  - Bid orders are sorted in ascending order (so the highest bid is at the last position).
  - Ask orders are sorted in ascending order (so the lowest ask is at the first position).

- **Order Matching:**  
  After sorting, extract the best bid (highest bid) and best ask (lowest ask). If the best bid is greater than or equal to the best ask, a match occurs. The matching price is taken as the best ask.

- **Latency Requirement:**  
  The design must contain logic to measure and ensure that the total processing latency, from the issuance of a start signal to the output being valid, is exactly 21 clock cycles.

- **Port List:**
```verilog
   module order_matching_engine #(
    parameter PRICE_WIDTH = 16  // width of the price field
)(
    input                      clk,
    input                      rst,
    input                      start,         // start matching operation
    input  [8*PRICE_WIDTH-1:0] bid_orders,    // 8 bid orders (flat vector)
    input  [8*PRICE_WIDTH-1:0] ask_orders,    // 8 ask orders (flat vector)
    output reg                 match_valid,   // high if a match occurs
    output reg [PRICE_WIDTH-1:0] matched_price, // matched price (best ask)
    output reg                 done,          // matching engine done
    output reg                 latency_error  // asserted if latency ≠ 20 cycles
);
```

### Prompt 144 ###
I have a testbench that only generates stimulus for an `order_matching_engine` design. The design specification of the top module and the `sorting_engine` modules used in it are provided in `docs` directory. Modify the System Verilog testbench `order_matching_engine_testbench.sv` in the `verif` directory to add checker logic to verify the results of the design in `order_matching_engine` module.

Add the following in the generated testbench:
- Add a function to calculate all the expected outputs.
- Modify the existing `run_test` task to check the outputs and latency.

### Prompt 145 ###
I have a few **sorting_engine** modules that sort the input data in ascending order. The **sorting_engine** modules are available at `rtl/` directory. Each module present in the folder implements a different sorting algorithm to perform the sorting operation. The sorting algorithm used by a module is mentioned in the name of the module.

Can you implement the **`order_matching_engine.sv`** in the `rtl` folder? Details of the `order_matching_engine` module are as given below

**Description - Order Matching Engine**

The goal is to build a module that efficiently processes and matches buy (bid) and sell (ask) orders. Here’s what the design must accomplish:

- **Input Handling:**  
  The engine accepts two flat input vectors—one for bid orders and one for ask orders. Following are the bid and ask order vectors:
Bid: 42,74,10,21,108,53,95,106
Ask: 130,108,205,129,192,213,244,141

- **Sorting:**  
  Select the sorting_engine module that has the lowest latency for the provided input to sort each set of orders. Use the same sorting algorithm implementation for sorting both bid and ask orders.
  - Bid orders are sorted in ascending order (so the highest bid is at the last position).
  - Ask orders are sorted in ascending order (so the lowest ask is at the first position).

- **Order Matching:**  
  After sorting, extract the best bid (highest bid) and best ask (lowest ask). If the best bid is greater than or equal to the best ask, a match occurs. The matching price is taken as the best bid.

- **Safeguarding:**
   The design should have a safeguard to cap the total loss in the event this module is used for trading purpose. Use the input circuit breaker that should disable any successful matches irrespective of the incoming bid and ask orders.

- **Latency:**
   The order_matching_engine that is generated should add a latency of exactly 1 clock cycle on top of the latency of the sorting_engine module it uses.

- **Port List:**
```verilog
   module order_matching_engine #(
    parameter PRICE_WIDTH = 16  // width of the price field
)(
    input                      clk,
    input                      rst,
    input                      start,         // Active high. Start matching operation
    input                      circuit_breaker, //Active high. Circuit breaker
    input  [8*PRICE_WIDTH-1:0] bid_orders,    // 8 bid orders (flat vector)
    input  [8*PRICE_WIDTH-1:0] ask_orders,    // 8 ask orders (flat vector)
    output reg                 match_valid,   // High if a match occurs
    output reg [PRICE_WIDTH-1:0] matched_price, // Matched price (best bid)
    output reg                 done          // Active high. Matching engine done
);
```

### Prompt 146 ###
Design a Verilog module for `spi_complex_mult`. Refer to the specification in `docs/specification.md`, which defines a SPI Slave that receives the complex number components Ar, Ai, Br, and Bi (real and imaginary parts) via SPI and performs complex multiplication using DSP operations. The results are stored in internal registers and can be transmitted back through SPI. Additionally, the module supports SPI Mode 0 (CPOL=0, CPHA=0).

### Prompt 147 ###
Design a SystemVerilog testbench, `spi_complex_mult_tb.sv`, in the verif directory to only generate stimulus and achieve maximum coverage for the module on the file in `rtl/spi_complex_mult.sv`. Refer to the specification in  `docs/specification.md`, which defines a SPI Slave that receives the complex number components Ar, Ai, Br, and Bi (real and imaginary parts) via SPI and performs complex multiplication using DSP operations. The results are stored in internal registers and can be transmitted back through SPI.

Include the following in the generated testbench:

Module instance: The module should be instantiated as dut, with the input and output signals connected for testing.
Input generation: The testbench must generate random inputs for the data signals.

### Prompt 148 ###
I have an `spi_complex_mult` module located in the `rtl` directory, and its specification is available in the `docs` directory. Please modify the module by adding **SystemVerilog assertions** to ensure it correctly handles SPI communication.

## **Assertion Details**  
The assertions should verify the following conditions:

1. **Reset behavior**: Ensure that `rst_async_n` properly resets all necessary signals.
2. **Bit counter**: Verify that `bit_count` increments correctly with each SPI clock cycle.
3. **Data readiness**: Check that the `data_ready` flag is asserted at the appropriate time.
4. **MOSI shift register**: Validate the correct shifting behavior of the `spi_mosi` input.
5. **Byte counter**: Verify that `byte_count` increments correctly after each byte.
6. **Operand storage**: Confirm that `shift_reg` data is correctly stored into the operands `Ar`, `Ai`, `Br`, and `Bi`.
7. **Multiplication result**: Ensure that the parallel multiplier output is valid and stable when expected.
8. **MISO output**: Verify that the `spi_miso` signal correctly reflects the expected bits of the result based on the protocol.

## **Expected Behavior**  
If any of the assertions fail, they should generate an **error message** indicating the specific condition that was violated.

### Prompt 149 ###
Design a `swizzler` module in SystemVerilog within a file `swizzler.sv` at the location: `rtl/swizzler.sv`. Refer to the specification provided in `docs/swizzler_specification.md` and ensure you understand its content. The specification details an advanced lane remapping mechanism (swizzling) that performs the following operations:

- **Data Unpacking:** Unpacks a flattened input data bus into an array of lanes.
- **Swizzle Mapping Unpacking:** Converts a flat, encoded swizzle map into an array, where each element indicates the source lane for a particular output lane.
- **Lane Remapping:** Rearranges the input lanes according to the swizzle map. If the `bypass` signal is asserted, the module passes the lanes through unchanged.
- **Parity Checking (Optional):** Computes the parity for each remapped lane and asserts an error signal if any lane’s parity is nonzero, based on the `ENABLE_PARITY_CHECK` parameter.
- **Output Packing:** Packs the remapped lanes back into a flat output bus.
- **Output Registering (Optional):** Registers the output data on the rising edge of the clock if `REGISTER_OUTPUT` is enabled.

Generate the complete RTL code that implements the `swizzler` module with all the features described above.

### Prompt 150 ###
I have a **swizzler** module that performs complex cross-correlation and energy computation over input I/Q data. This module handles the internal processing logic required for computing correlation with conjugate reference sequences. It unpacks the input data into individual lanes, applies a swizzle map for remapping the lanes, detects invalid mappings, computes parity errors (if enabled), and finally performs a bit reversal on each lane before packing the data back into a flat output vector. The **swizzler** module is available at `/rtl/swizzler.sv` and its detailed specification is provided in the `/docs` directory.

Can you implement a top-level module called **`swizzler_supervisor`** ? The supervisor should integrate the **swizzler** module and augment its functionality with additional glue logic as described below.

The **swizzler_supervisor** module is designed to enhance the raw functionality of the **swizzler** subcomponent by:
  
- **Input Handling:**  
  - Pre-processing the input I/Q data to ensure proper formatting and conditioning prior to processing by the swizzler.
  - Applying potential reordering or scaling operations to align with the swizzler’s processing requirements.

- **Processing the Swizzler's Output:**  
  - Performing post-processing on the swizzler’s output, which includes computing a checksum across all lanes.
  - Comparing the computed checksum with a pre-defined expected value.
  - Generating error flags if a parity error, invalid mapping, or checksum mismatch is detected.
  - Applying additional bit manipulations (such as inverting the least significant bit in each lane) to produce the final data output.

- **Parameterization:**  
  - The design must be fully parameterizable to adapt to various configurations. Key parameters include:
    - **NUM_LANES**: Number of data lanes.
    - **DATA_WIDTH**: Bit-width of each lane.
    - **REGISTER_OUTPUT**: Option to pipeline outputs.
    - **ENABLE_PARITY_CHECK**: Toggle for parity error computation.
    - **OP_MODE_WIDTH**: Width of the operation mode signal.
    - **SWIZZLE_MAP_WIDTH**: Derived width for swizzle mapping.
    - **EXPECTED_CHECKSUM**: The checksum value against which the output is verified.

- **Error Supervision:**  
  - Integrate supervisory logic that validates the swizzler output by comparing the computed checksum with the expected value.
  - Assert a top-level error signal if any discrepancies arise (i.e., parity errors, invalid mapping errors, or checksum mismatches).

```verilog
module swizzler_supervisor #(
  parameter integer NUM_LANES           = 4,
  parameter integer DATA_WIDTH          = 8,
  parameter integer REGISTER_OUTPUT     = 1,
  parameter integer ENABLE_PARITY_CHECK = 1,
  parameter integer OP_MODE_WIDTH       = 2,
  parameter integer SWIZZLE_MAP_WIDTH   = $clog2(NUM_LANES)+1,
  parameter [DATA_WIDTH-1:0] EXPECTED_CHECKSUM = 8'hA5
)(
  input  wire                           clk,
  input  wire                           rst_n,
  input  wire                           bypass,
  input  wire [NUM_LANES*DATA_WIDTH-1:0] data_in,
  input  wire [NUM_LANES*SWIZZLE_MAP_WIDTH-1:0] swizzle_map_flat,
  input  wire [OP_MODE_WIDTH-1:0]         operation_mode,
  output reg  [NUM_LANES*DATA_WIDTH-1:0]  final_data_out,
  output reg                            top_error
);
  // [Internal implementation...]
endmodule
```

Please refer to `docs/swizzler_specification.md` for detailed design requirements and specifications of the subcomponent swizzler.

### Prompt 151 ###
Design an `sync_serial_communication` with binary to gray code conversion module in SystemVerilog. Refer to the specification provided in `docs/sync_serial_communication_spec.md` to implement the RTL. The specification describes a module that takes 64 bit input data input and performs various transmit & receive operations on it based on a 3-bit selection signal. It also requires generating a Gray-coded version of the receive data.

**1. Hierarchical Design**

- The top-level module is `sync_serial_communication_tx_rx`, integrating `tx_block`, `rx_block`, and `binary_to_gray_conversion`.
- `tx_block` (transmitter) serializes and transmits data.
- `rx_block` (receiver) deserializes the data.
- `binary_to_gray_conversion` converts the received binary data into Gray code.

**2. Functional Details**

- **`tx_block` (Transmitter):**

    - Serializes `data_in` based on `sel`.
    - Supports 8-bit, 16-bit, 32-bit, and 64-bit transmission.
    - Generates a serial clock .

- **`rx_block` (Receiver):**

    - Deserializes output of  `tx_block` and reconstructs `data_out`.
    - Uses a counter to track received bits.


- **binary_to_gray_conversion:**

    - Converts `data_out` to Gray code when `done` is asserted.

**3. Timing & Synchronization**

- The system is synchronous to `clk`, with a serial clock  for RX operations.
- Reset (`reset_n`) initializes registers and buffers.
- `done` is asserted upon completion of transmission/reception.

The code should be well-documented with clear comments explaining the functionality of each major block. Follow best practices in SystemVerilog coding to ensure readability, reusability, and maintainability.

### Prompt 152 ###
I need to implement a **systolic array architecture** for **matrix multiplication acceleration** by integrating four **`weight_stationary_pe`** processing elements (PEs) in a **2x2 configuration**. Each PE performs **multiply-accumulate (MAC) operations** and passes intermediate results to its neighboring PE in a wavefront manner. The system should correctly **load weights, propagate input data, accumulate partial sums, and assert the `done` signal** when computations are complete.  

I have the **Processing Element module at `/code/rtl/weight_stationary_pe.sv`** and need to create the **top-level `systolic_array.sv` module**. This module must **instantiate and connect all 4 PEs**, ensure **proper data flow and synchronization**, and implement **latency-aware pipeline control**. To verify functionality, a testbench is available at **/code/verif/systolic_array_tb.sv`**. The final design should use **registered outputs for `y0` and `y1`**, maintain **low-latency operation**, and assert `done` after the computation cycles complete.

### Prompt 153 ###
I have a **thermostat** module located at `code/rtl/thermostat.v`. This module currently lacks access control and can operate without any restriction. I want to enhance the system to be **secure**, such that the thermostat only functions after a proper unlock sequence has been successfully completed.

---

### **Modification Goals**

Create a new module, named "security_module" in file "security_module.v" that acts as a **security gatekeeper**. This module must implement a finite state machine that enforces an **unlock sequence** before enabling the thermostat. The unlock sequence consists of two steps:
1. First, the hexadecimal value `0xAB` must be written to internal address `0`.
2. Next, the value `0xCD` must be written to internal address `1`.

Only when both steps are performed in sequence should the system be considered **secure**. Any deviation (incorrect value or incorrect order) should cause the state machine to reset, requiring the entire sequence to be redone. The secure module is resettable and must return to the locked state upon system reset.

Once the unlock is complete, the secure module should assert a signal that enables the thermostat. Until then, the thermostat must remain inactive.

---

### **Top-Level Integration**

Create a new top-level module named "thermostat_secure_top.v" that integrates both the security module and the thermostat. Ensure correct data flow and signal connection between them.
Below are the IOs.

```verilog 
module thermostat_secure_top  #(
    parameter p_address_width = 8,                
    parameter p_data_width = 8,                  
    parameter p_unlock_code_0 = 8'hAB,            
    parameter p_unlock_code_1 = 8'hCD            
) (
    input wire [5:0] i_temp_feedback, 
    input wire i_fan_on,             
    input wire i_fault,              
    input wire i_clr,               
    input wire i_clk,                
    input wire i_rst,                
    input wire [p_address_width-1:0]   i_addr,             
    input wire [p_data_width-1:0]      i_data_in,          
    input wire                         i_read_write_enable, 
    input wire                         i_capture_pulse,    

    output reg o_heater_full,
    output reg o_heater_medium,
    output reg o_heater_low,
    output reg o_aircon_full,
    output reg o_aircon_medium,
    output reg o_aircon_low,
    output reg o_fan,
    output reg [2:0] o_state         
);
```

---

### **Clocks and Reset**

The secure module operates on a clock derived from a **capture pulse** signal, while the thermostat runs on its own **thermostat clock**. These clocks are asynchronous. The reset signal is shared across both modules. The top-level module must handle **clock domain crossing** between the two domains in a safe and reliable manner.

---

### **Expected Deliverable**

A complete design containing:
1. The **modified thermostat** that responds to a secure-enable condition.
2. A new **security module** enforcing the unlock logic.
3. A **top-level module** instantiating and integrating both components, managing control flow and asynchronous clocks.

The system must ensure that the thermostat never functions unless the unlock sequence is properly followed.

### Prompt 154 ###
I have an `traffic_controller_fsm` module that controls a traffic light, located at `/rtl/traffic_light_controller.sv`.  
I want to modify the current design such that the light changes are driven by both short and long time intervals using the timer module, named `timer_module` in file `timer_module.sv` with below specification. Instantiate this timer module alongside the existing traffic-light FSM in a new top-level module, `traffic_light_controller_top` in file `traffic_light_controller_top.sv`.
The expected outcome is that short and long timing behaviors are cleanly separated into a new timer-based module, then integrated with the existing FSM in a new top-level design.

---

### **Timer Module Behavior**
- The timer module tracks two different intervals, a “short” duration and a “long” duration.  
- When a short-timer trigger becomes active, the module counts cycles until it reaches the short duration limit. At that moment, it raises a signal indicating the short interval has expired.  
- When a long-timer trigger becomes active, the module counts cycles until it reaches the long duration limit. At that moment, it raises a signal indicating the long interval has expired.  
- If neither trigger is active, both timers are idle (or reset), and no expiration indication is set.  
- When reset is asserted, all internal counters and any expired signals are cleared immediately.

---

### **Top-Level Integration**
- Connect the timer’s short and long triggers from the FSM, and feed the timer’s expiration signals back into the FSM to drive state transitions.  
- Pass the short and long duration thresholds (e.g., `SHORT_COUNT` and `LONG_COUNT`) from the top-level to the timer module.

### **TOP LEVEL IOs**
| **Port Name**             | **Direction** | **Bit Width**  | 
|---------------------------|---------------|----------------|
| `i_clk`                   | Input         | 1              |
| `i_rst_b`                 | Input         | 1              |
| `i_vehicle_sensor_input`  | Input         | 1              |
| `o_main`                  | Output        | 3              |
| `o_side`                  | Output        | 3              |

### Prompt 155 ###
Design a `ttc_counter_lite` module in SystemVerilog within a file ttc_counter_lite.sv at the location:rtl/ttc_counter_lite.sv Refer to the specification provided in `docs/specification.md` and ensure you understand its content. The specification describes the functionality of a lightweight timer counter with optional interrupt support and configurable modes. It includes a description of the register interface, internal behavior, timing characteristics, and how the counter behaves in different configurations.

Generate the complete RTL code that implements the `ttc_counter_lite` module as described in the specification. The design must include:
- A 16-bit up counter  
- Configurable match and reload values  
- Support for interval and single-shot operation modes  
- Programmable prescaler
- An interrupt output that asserts when the counter reaches the match value and interrupt_enable is set  
- Read/write access to registers via a simplified AXI-like register interface

### Prompt 156 ###
I have a `ttc_counter_lite` module available in the `rtl` directory. Kindly modify the module by adding SystemVerilog Assertions (SVA) to check its internal functionality comprehensively. The assertions should verify the following conditions:

- **Reset Consistency:** Upon `reset`, all internal registers  must be cleared to their default values.
- **Prescaler Logic:** After a valid write to the ADDR_PRESCALER register, the internal prescaler must reflect the written value in the next cycle.
- **Match Value Behavior:** After writing to the ADDR_MATCH_VALUE register, the match_value must be updated correctly in the next cycle.
- **Reload Value Behavior:** After writing to the ADDR_RELOAD_VALUE register, the reload_value must reflect the correct value in the next cycle.
- **Control Register Behavior:** A write to the ADDR_CONTROL register should correctly update the enable, interval_mode, and interrupt_enable bits.
- **Interrupt Generation:** When count equals match_value and interrupt_enable is set, the interrupt signal must be asserted.
- **Interrupt Clear:** Writing to the ADDR_STATUS register while `axi_write_en` is high must clear the interrupt signal in the next cycle.
- **Counter Range Validity:** The counter must remain within the range of [reload_value, match_value] while enabled, especially in interval mode.
- **Read Behavior Consistency:** Ensure that AXI reads from known addresses return the correct content as per the internal register values.

If any of these conditions are violated during simulation, an appropriate error message should be displayed.

### Prompt 157 ###
I have a specification of a `ttc_counter_lite` module in the `docs` directory. Write a SystemVerilog TB `ttc_counter_lite_tb.sv` in the `verif` directory to only generate stimuli and achieve maximum functional coverage for the `ttc_counter_lite` module.

Include the following in the generated testbench:

- **Module Instance**: Instantiate the `ttc_counter_lite` module as `dut`, appropriately connecting all input and output signals.
- **Clock Generation**: Use a 100 MHz clock with a 10ns period (`clk_in`).
- **Reset Procedure**: Create an apply_reset task that
   - Asserts reset for 10 clock cycles.
   - Desserts it before the stimulus begin
   - Reapplies reset mid-operation to test FSM recovery behavior.
- **Basic Register Access Tasks**
   Implement the following tasks to drive valid AXI-style register-level operations:
     - axi_write: Drives write transactions using `axi_addr`, `axi_wdata`, and `axi_write_en`.
     - axi_read: Performs read transactions and prints `axi_rdata` for traceability and debug visibility.
     - axi_read_force_toggle_full:  Forces and releases upper toggle bits in `axi_rdata` to stimulate data bus transitions.
     - drive_counter_to_upper_bits: Configures the control, match, and reload registers to run the counter long enough to 
         toggle the upper counter bits.
     - toggle_prescaler_bits: Writes and clears the prescaler register to trigger bit toggles and verify prescaler logic.

- **Stress and Coverage Stimulus**:
  Apply diverse stimuli to activate all reachable RTL states, signal transitions, and FSM paths:
    - Read all defined address registers after reset to cover initial state logic.
    - Write to `MATCH` and `RELOAD` registers using:
        - Minimum value: `0x00000000`
        - Maximum value: `0x0000FFFF`
    - Drive various `CONTROL` register modes including:
        - Enable / Disable
        - Reload mode
        - Interval mode
   - Cover counter wrap-around and overflow behavior using small reload and match values.
   - Perform writes/reads to invalid or unused addresses(e.g., `0xF`, `0x1000`) to trigger decoder edge cases.
   - Toggle enable modes during ongoing counting to test runtime configurability.
   - Apply **1-cycle read/write pulses** to target glitchy signal paths or edge-sensitive conditions.
   - Perform **reset mid-operation** and after multiple transactions to test FSM recovery behavior.
   - Write known upper-bit patterns to all writable registers and read them back to observe **toggle logic** in `axi_rdata`.
  - Repeat read/write sequences to:
     - `CONTROL`
     - `MATCH`
     - `RELOAD`
     - `PRESCALER`  
 
- **Stress and Sequence Coverage**
   Run repeated sequences and edge cases to validate internal behavior:
     - Enable timer → wait → read counter
     - Enable → Disable → Enable transitions
  - Write **invalid configuration values** to test FSM error handling
  - Perform `Write → Read` transitions with:
     - Short delays
     - Long idle intervals
  - Issue high-speed, back-to-back register accesses with minimal spacing
     - Vary `axi_addr` to cover:
     - All address bits
    - Edge and boundary cases
     
Do not include checkers, assertions, or internal state comparisons. The testbench should be structured strictly for applying input stimulus to the DUT and exercising its logic comprehensively.

### Prompt 158 ###
I have below submodules in `/code/rtl` directory that together implement the functionality of a UART system:

- `uart_tx`: Manages transmission including start/stop/parity handling.
- `uart_rx`: Manages reception with start detection, oversampling, and parity checking.
- `baud_gen`: Generates TX/RX baud clock pulses and manages enable signals.
- `cdc_sync`: Synchronizes asynchronous RX input into the core clock domain.
- `areset_sync`: Synchronizes asynchronous de-assertion of reset for clean transitions.

These modules need to be integrated into a top-level RTL module named `uart_top`.

The full specification for this top module is documented in **`docs/UART_Specifications.md`**. Please follow that spec precisely when wiring up ports, handling loopback behavior, and generating status outputs.

The final top-level module should:

1. **Integrate** all submodules and connect them per the specification.
2. **Support full-duplex UART** with loopback functionality when `i_lpbk_mode_en` is asserted.
3. **Generate internal resets** for `uart_tx` and `uart_rx` using `areset_sync` based on `rstn`, `i_tx_rst`, and `i_rx_rst`.
4. **Synchronize** the incoming RX signal using `cdc_sync`.
5. **Use** the `baud_gen` module to generate TX and RX baud clocks and manage TX/RX enable signals.
6. **Connect** valid-ready handshaking signals between the top-level and submodules.
7. **Expose** all required control/status ports as defined in the spec, including `o_tx_state`, `o_rx_state`, `o_rx_break`, `o_parity_err`, and `o_frame_err`.

#### Testbench Requirement:
In addition to creating the top module, develop a **SystemVerilog testbench** in `verif` directory that:
- Instantiates `uart_top` and drives it with appropriate stimulus.
- Initializes core and resets all domains.
- Sends a variety of TX payloads with different configurations of:
  - Parity (none/odd/even)
  - Stop bits (1 or 2)
  - Loopback mode enabled/disabled
  - Break frame generation
- Monitors and checks reception of expected data via the RX interface.
- Includes at least one **loopback test** and one **normal TX-RX test** using serial wiring.
- Logs and asserts for `parity_err`, `frame_err`, and `o_rx_break` for error-checking validation.
- Uses the valid/ready handshake mechanism for TX and RX.
- Covers corner cases like:
  - Minimum and maximum baud rate values
  - Data bursts and back-to-back transfers
  - Simulated framing errors and parity mismatches (if possible)

Please implement this integrated top-level UART module as `uart_top` in a single SystemVerilog file named `uart_top.sv` and a separate testbench file named **`tb_uart_top.sv`** to demonstrate functionality and compliance with the spec.

### Prompt 159 ###
Design a `universal_shift_register` module in SystemVerilog. Refer to the specification provided in `docs/Universal_Shift_Register_spec.md` to implement the RTL. The specification outlines a parameterizable, synchronous N-bit shift register that supports multiple operational modes, including Hold, Shift (left/right), Rotate (left/right), and Parallel Load.

### Prompt 160 ###
Modify the `universal_shift_register` module to expand its functionality by incorporating additional shift and bitwise operation capabilities while retaining its original functionality (including hold, shift, rotate, and parallel load operations). The module should now support arithmetic shifts, bitwise logical operations (AND, OR, XOR, XNOR), bit reversal, bitwise inversion, parity checking, zero detection, and overflow indication for shifts and rotations.
## Added/Modified  Inputs

- **[1:0] bitwise_op**: 2-bit input signal selects the bitwise logical operation.
- **en**: 1-bit Enable signal controls the register operation explicitly.
- **[2:0] op_sel**: Expanded from the previous 2-bit mode_sel to a 3-bit selector supporting additional modes:
     - 000: Hold (retain current value)
     - 001: Logical Shift (shift bits in/out)
     - 010: Rotate (rotate bits within the register)
     - 011: Parallel Load (load from input)
     - 100: Arithmetic Shift (shift with sign bit handling)
     - 101: Bitwise Logical Operations (AND, OR, XOR, XNOR)
     - 110: Bit Reversal (reverse bit order)
     - 111: Bitwise Inversion (invert all bits)

## Added/Modified Outputs:
- **Overflow**: 1-bit output that captures and outputs the bit shifted or rotated out during shift and rotate operations.
- **parity_out**: 1-bit output that computes and outputs the XOR of all bits in the register (parity checking).
- **zero_flag**: 1-bit output indicates when the register content is zero.
- **msb_out**: 1-bit direct output of the most significant bit of the register.
- **lsb_out**: 1-bit direct output of the least significant bit of the register.

## Design Modifications

### Expanded Operation Modes:

1. **Hold (000)**: Retains the current value in the register.
2. **Logical Shift (001)**: 
   - Right/Left shift controlled by `shift_dir`, using `serial_in` as input.
   - Overflow captures shifted-out bit.
3. **Rotate (010)**:
   - Right/Left rotate controlled by `shift_dir`.
   - Overflow captures rotated bit.
4. **Parallel Load (011)**: 
   - Loads the register directly from `parallel_in`.
5. **Arithmetic Shift (100)**:
   - Arithmetic shift right retains MSB.
   - Arithmetic shift left shifts in 0.
   - Overflow captures shifted-out bit.
6. **Bitwise Logical Operations (101)**:
   - Performs AND, OR, XOR, XNOR selected by `bitwise_op` against `parallel_in`.
7. **Bit Reversal (110)**:
   - Reverses the bit order of the register content.
8. **Bitwise Inversion (111)**:
   - Inverts all bits in the register.

### Behavioral Changes:
- The module behavior is expanded to include arithmetic shifts and bitwise logical operations while maintaining previous behaviors for existing operations.
- Overflow bit handling is clearly defined during shifts and rotations.
- Parity checking and zero detection provide additional status indicators based on the current register content.
- MSB (msb_out) provides the direct output of the register's most significant bit.
- LSB (lsb_out) provides the direct output of the register's least significant bit.
## Example Usage:

1. **Arithmetic Shift Left**:
   - `op_sel = 100`, `shift_dir = 1` (left), register shifts left logically, shifting in 0 from the right, capturing overflow bit from MSB.
   
2. **Bitwise XOR Operation**:
   - `op_sel = 101`, `bitwise_op = 10` (XOR), performs XOR between current register content and `parallel_in`.

3. **Bit Reversal**:
   - `op_sel = 110`, reverses the bit order of the current register content.

