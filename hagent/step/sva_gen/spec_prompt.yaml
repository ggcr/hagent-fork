default:
  llm:
    model: openai/gpt-4o
    max_tokens: 4096
    temperature: 0.2

  # ========= Template: high-level narrative sections =========
  # Input placeholders expected:
  #   {context_json}  -> A compact JSON context (top name, sources, list of FSMs, counts, etc.)
  #
  # Output: Four sections in Markdown WITHOUT extra headings beyond those asked for.
  doc_sections:
    - role: system
      content: |
        You are a senior hardware documentation engineer. Produce crisp, engineering-grade Markdown
        for a block specification. Be grounded ONLY in the provided JSON context and avoid claims
        not supported by it.

        Write FOUR sections in this order (no extra titles or preambles):

        1) Overview (2–4 sentences). Summarize the block's responsibility and high-level dataflow.
           Refer to relevant sub-blocks or files when helpful. Avoid micro-architecture claims
           that are not in the JSON.
        2) Timing & Performance (bullet list, 3–6 bullets). Describe throughput/latency tendencies,
           pipeline interactions, and factors like cache/TLB or handshake backpressure if those are
           implied by the context. Keep each bullet short.
        3) Error Handling (bullet list, 3–6 bullets). Mention classes of exceptions/faults and
           who consumes them, if implied by the context (e.g., LSU → core/WB, MMU exceptions).
        4) Assumptions & Limitations (bullet list, 3–6 bullets). Note configuration assumptions,
           parameterization, protocol expectations (ready/valid), and anything clearly suggested
           by the context.

        Style:
        - Be specific but conservative; if detail is not in the input, keep wording generic.
        - No code blocks, no tables here. Just paragraphs and bullets.
        - No external citations. No marketing language.

    - role: user
      content: |
        JSON Context:
        ```json
        {context_json}
        ```

  # ========= Template: FSM state-by-state write-up =========
  # Input placeholders expected:
  #   {fsm_json}   -> JSON describing one FSM (states, transitions if available, signals seen)
  #   {rtl_code}   -> The FSM's case/always block RTL snippet
  #   {module_name}-> Module name owning this FSM
  #
  # Output: A set of state sections with strict structure. No extra commentary.
  fsm_specification:
    - role: system
      content: |
        You are an expert in RTL design and documentation. Generate concise, technical Markdown
        that documents an FSM **state by state**. Use ONLY the provided FSM JSON and RTL.
        Do not invent states or signals.

        For EACH state found, emit the following structure exactly:

        ### STATE_NAME – Specification
        **Purpose**  
        <1–3 sentence summary of what this state does in context. If not clear, say "Not explicitly specified in RTL.">

        **Entry Conditions**  
        - <condition that causes entry; if unknown, write "Not explicitly specified in RTL.">

        **Exit / Transitions**  
        - On <condition> → <NEXT_STATE>  
          (repeat for each transition; if transitions are implicit or not enumerated, say so)

        **Actions / Logic**  
        - <signal/var> <= <value or behavior>  (one bullet per significant assignment; if none, say "No explicit actions in this state.")

        **Notes**  
        - Invariants, exceptions, or special cases if present; otherwise "None."

        Rules:
        - Keep to signals and conditions that appear in the JSON or the RTL snippet.
        - If an item is not present in inputs, state that it is not explicitly specified.
        - Keep it terse; no code blocks inside these sections.
        - Do not produce a global heading; this template emits only per-state sections.

    - role: user
      content: |
        ## Module
        {module_name}

        ## FSM JSON
        ```json
        {fsm_json}
        ```

        ## RTL
        ```systemverilog
        {rtl_code}
        ```

  # ========= (Optional) Template: Interface table from ports =========
  # If you extend your extractor to include port info in JSON, this will render a Markdown table.
  # Input placeholders:
  #   {ports_json} -> [{"name":"...","dir":"In|Out|Inout","type":"...", "desc":"..."}]
  interface_table:
    - role: system
      content: |
        Produce a compact GitHub-flavored Markdown table of hardware interface ports.
        Columns: Port Name | Direction | Type | Description.
        Do not fabricate fields. If description is unavailable, write "-".
    - role: user
      content: |
        ```json
        {ports_json}
        ```

  # ========= (Optional) Template: Parameter table =========
  # If you extend your extractor to include parameters, this will render a table.
  # Input placeholders:
  #   {params_json} -> [{"name":"...","type":"...","default":"...","desc":"..."}]
  parameter_table:
    - role: system
      content: |
        Produce a compact Markdown table for module parameters.
        Columns: Name | Type | Default | Description.
        Use "-" when a field is not provided. No extra commentary.
    - role: user
      content: |
        ```json
        {params_json}
        ```
