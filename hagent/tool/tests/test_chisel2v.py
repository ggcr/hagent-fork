# tests/test_chisel2v.py
# See LICENSE file for details

import pytest
from hagent.tool.chisel2v import Chisel2v
from unittest.mock import patch, MagicMock


def test_setup_success(tmp_path):
    # In real usage, ensure 'sbt' is available in PATH or provide a mock path
    # Here we mock it by creating a dummy 'sbt' file
    sbt_dir = tmp_path / 'fake_sbt_dir'
    sbt_dir.mkdir()
    sbt_bin = sbt_dir / 'sbt'
    sbt_bin.write_text("#!/usr/bin/env bash\necho 'Fake sbt running'\n")
    sbt_bin.chmod(0o755)

    dut = Chisel2v()
    ok = dut.setup(str(sbt_dir))
    assert ok is True
    assert dut._is_ready is True
    assert dut.error_message == ''


def test_setup_failure(tmp_path):
    dut = Chisel2v()

    assert dut.error_message == ''

    ok = dut.setup('/non/existent/path')

    assert not ok
    assert dut._is_ready is False
    assert dut.error_message != ''


def test_generate_verilog_not_ready():
    dut = Chisel2v()
    with pytest.raises(RuntimeError):
        dut.generate_verilog('class MyModule extends Module {}', 'MyModule')


def test_chisel_fix_basic():
    dut = Chisel2v()
    code = """
class FooModule extends Module {
  val io = IO(new Bundle {})
}
"""
    fixed = dut.chisel_fix(code, 'FooModule')
    assert 'import chisel3.util._' in fixed
    assert 'import _root_.circt.stage.ChiselStage' in fixed
    assert 'object Top extends App' in fixed
    assert 'new FooModule' in fixed


def test_generate_verilog_success(tmp_path):
    return # FIXME: DISSABLE TEST

    # Create a fake sbt environment
    sbt_dir = tmp_path / 'fake_sbt_dir'
    sbt_dir.mkdir()
    sbt_bin = sbt_dir / 'sbt'
    sbt_bin.write_text("#!/usr/bin/env bash\necho 'Fake sbt running'\n")
    sbt_bin.chmod(0o755)

    dut = Chisel2v()
    ok = dut.setup(str(sbt_dir))
    assert ok

    # Minimal valid Chisel code
    code = """
import chisel3._
class MyModule extends Module {
  val io = IO(new Bundle {
    val in = Input(UInt(6.W))
    val ou = Output(UInt(6.W))
  })
  io.ou := io.in
}
"""

    # Mock subprocess.run to simulate successful sbt execution
    mock_verilog = """
// Generated by CIRCT
module MyModule(
  input  [5:0] io_in,
  output [5:0] io_ou
);
  assign io_ou = io_in;
endmodule
"""

    with patch('subprocess.run') as mock_run, patch('tempfile.mkdtemp', return_value=str(tmp_path)), patch('shutil.copyfile'):
        # Mock successful subprocess execution
        mock_proc = MagicMock()
        mock_proc.returncode = 0
        mock_run.return_value = mock_proc

        # Create the expected output file
        verilog_file = tmp_path / 'MyModule.v'
        verilog_file.write_text(mock_verilog)

        out_txt = dut.generate_verilog(code, 'MyModule')

        assert 'Generated by CIRCT' in out_txt
        assert 'module MyModule' in out_txt
        assert mock_run.called
